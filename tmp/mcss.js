(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _tokenizer = __webpack_require__(1);\n\nvar _tokenizer2 = _interopRequireDefault(_tokenizer);\n\nvar _parser = __webpack_require__(3);\n\nvar _parser2 = _interopRequireDefault(_parser);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar content = '\\n.u-btn {\\n    background: red;\\n}\\n';\nvar content2 = '$test = $abc; $test = 4px;';\nvar content3 = '\\n.u-btn, .test {}\\n';\n\nvar tokenizer = new _tokenizer2.default();\nvar parser = new _parser2.default();\n\nvar tokens = tokenizer.tokenize(content);\nvar ast = parser.parse(tokens);\n\nconsole.log(ast);//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi90ZXN0L3NwZWNzL3BhcnNlci5qcz8xZTIzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7QUFDQTs7Ozs7O0FBRUEsSUFBSSxpREFBSjtBQUtBLElBQUksV0FBVyw0QkFBZjtBQUNBLElBQUksaUNBQUo7O0FBSUEsSUFBSSxZQUFZLHlCQUFoQjtBQUNBLElBQUksU0FBUyxzQkFBYjs7QUFFQSxJQUFJLFNBQVMsVUFBVSxRQUFWLENBQW1CLE9BQW5CLENBQWI7QUFDQSxJQUFJLE1BQU0sT0FBTyxLQUFQLENBQWEsTUFBYixDQUFWOztBQUVBLFFBQVEsR0FBUixDQUFZLEdBQVoiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBUb2tlbml6ZXIgZnJvbSAnLi4vLi4vc3JjL3Rva2VuaXplci5qcyc7XG5pbXBvcnQgUGFyc2VyIGZyb20gJy4uLy4uL3NyYy9wYXJzZXIuanMnO1xuXG5sZXQgY29udGVudCA9IGBcbi51LWJ0biB7XG4gICAgYmFja2dyb3VuZDogcmVkO1xufVxuYDtcbmxldCBjb250ZW50MiA9ICckdGVzdCA9ICRhYmM7ICR0ZXN0ID0gNHB4Oyc7XG5sZXQgY29udGVudDMgPSBgXG4udS1idG4sIC50ZXN0IHt9XG5gO1xuXG5sZXQgdG9rZW5pemVyID0gbmV3IFRva2VuaXplcigpO1xubGV0IHBhcnNlciA9IG5ldyBQYXJzZXIoKTtcblxubGV0IHRva2VucyA9IHRva2VuaXplci50b2tlbml6ZShjb250ZW50KTtcbmxldCBhc3QgPSBwYXJzZXIucGFyc2UodG9rZW5zKTtcblxuY29uc29sZS5sb2coYXN0KTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vdGVzdC9zcGVjcy9wYXJzZXIuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _util = __webpack_require__(2);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// >>>>>> 待优化\n// the more fast version\n// let toAssert2 = util.makePredicate;\n\nvar isUnit = (0, _util.toAssert)('% em ex ch rem vw vh vmin vmax cm mm in pt pc px deg grad rad turn s ms Hz kHz dpi dpcm dppx');\n// let isPseudoClass = toAssert2([\"dir\",\"lang\",\"any-link\", \"link\", \"visited\", \"local-link\",\"target\", \"scope\", \"current\", \"past\", \"future\", \"active\", \"hover\", \"focus\", \"active-drop\", \"valid-drop\", \"invalid-drop\", \"enabled\", \"disabled\", \"enabled\", \"disabled\", \"read-only\", \"read-write\", \"placeholder-shown\", \"default\", \"checked\", \"indeterminate\", \"valid\", \"invalid\", \"in-range\", \"out-of-range\", \"required\", \"optional\", \"root\", \"empty\", \"blank\", \"nth-child\", \"nth-last-child\", \"first-child\", \"last-child\", \"only-child\", \"nth-of-type\", \"nth-last-of-type\", \"first-of-type\", \"last-of-type\", \"only-of-type\", \"nth-match\", \"nth-last-match\", 'nth-column', 'nth-last-column', 'not', 'matches', 'before', 'after', '-moz-placeholder']);\n// let isBifs = toAssert2(bifs.concat(['rgb', 'rgba', 'url', 'counter', 'attr', 'calc', 'min', 'max', 'cycle', 'linear-gradient', 'radial-gradient', 'repeating-linear-gradient', 'repeating-radial-gradient']), true);\nvar isPseudoClassWithParen = (0, _util.toAssert)('current local-link nth-child nth-last-child nth-of-type nth-last-of-type nth-match nth-last-match column nth-column nth-last-column lang matches not');\n\n// [W3C]: http://dev.w3.org/csswg/css-syntax/\nvar MAX_ALLOWED_CODEPOINT = parseInt('10FFFF', 16); // [W3C#maximum-allowed-codepoint]\nvar REPLACEMENT_CHARACTER = parseInt('FFFD', 16);\n\n// Token Types\n// ===========================================\n// >>>>>> 什么意思\n// // inspectToken, get tokenName with TokenType(uid)\n// tokenizer.inspect = function(tokenType){\n//     let typeType = tokenType.type || tokenType;\n//     for(let i in tokenizer){\n//         if(typeof tokenizer[i] === 'number' && tokenizer[i] === tokenType) return i;\n//     }\n// }\n\n(0, _util.$)('nl', /\\r\\n|[\\r\\f\\n]/); // newline\n(0, _util.$)('w', /[ \\t\\r\\n\\f]/); // whitespace\n(0, _util.$)('d', /[0-9]/); // digital\n(0, _util.$)('escape', /\\\\[0-9a-f]{1,6}/); // escape char\n(0, _util.$)('nmchar', /[_-\\w\\u00A1-\\uFFFF]|{escape}/);\n(0, _util.$)('nmstart', /[_a-zA-Z\\u00A1-\\uFFFF]|{escape}/);\n(0, _util.$)('ident', /-?{nmstart}{nmchar}*/);\n\n// registed macros\n// =====================\nvar $rules = [{ // multiline comment | singleline comment\n    regexp: /\\/\\*([^\\x00]+?)\\*\\/|\\/\\/([^\\n\\r]*)/,\n    action: function action(yytext, mcomment, scomment) {\n        var isSingle = mcomment === undefined;\n        // >>>>>> ? 这个方法是怎么用的\n        this.options.comment && this.options.comment({\n            type: isSingle ? 'singleline' : 'multiline',\n            content: isSingle ? scomment : mcomment\n        });\n    }\n}, { // url [W3C]\n    regexp: (0, _util.$)(/(url|url\\-prefix|domain|regexp){w}*\\((['\"])?{w}*([^\\r\\n\\f]*?)\\2{w}*\\)/),\n    action: function action(yytext, name, quote, url) {\n        if (name === 'url') return { type: 'URL', value: url };else return { type: 'FUNCTION', value: name, args: [{ type: 'STRING', value: url }] };\n    }\n}, { // function [W3C]\n    regexp: (0, _util.$)(/(?:\\$?-?[_A-Za-z][-_\\w]*)(?=\\()/),\n    action: function action(value) {\n        return { type: 'FUNCTION', value: value };\n    }\n}, { // $variable\n    regexp: /\\$(-?[_A-Za-z][-_\\w]*)/,\n    action: function action(yytext, value) {\n        return { type: 'VAR', value: value };\n    }\n}, { // ident [W3C], 即 -o-webkit-xx 是允许的\n    regexp: (0, _util.$)(/{ident}/),\n    action: function action(value) {\n        if (value === 'false' || value === 'true') return { type: 'BOOLEAN', value: value === 'true' };else if (value === 'null') return { type: 'NULL', value: null };else return { type: 'TEXT', value: value };\n    }\n},\n// {    // @css at-rule no parse\n//     reg: /@css{w}*{/,\n//     action(yytext) {\n//     }\n// },\n{ // dimension: number + unit\n    regexp: (0, _util.$)(/(-?(?:{d}*\\.{d}+|{d}+))(\\w*|%)?/),\n    action: function action(yytext, value, unit) {\n        if (unit && !isUnit(unit)) this.error('Unexcept unit: \"' + unit + '\"');\n        return { type: 'DIMENSION', value: +value, unit: unit };\n    }\n}, { // class\n    regexp: (0, _util.$)(/\\.({nmchar}+)/),\n    action: function action(value) {\n        return { type: 'CLASS', value: value };\n    }\n}, { // at-keyword, @\n    regexp: /@(-?[_A-Za-z][-_\\w]*)/,\n    action: function action(yytext, value) {\n        return { type: 'AT_KEYWORD', value: value };\n    }\n}, { // !important\n    regexp: (0, _util.$)(/!{w}*important/),\n    action: function action(yytext) {\n        return { type: 'IMPORTANT' };\n    }\n}, { // pesudo-class\n    regexp: (0, _util.$)(':([-_a-zA-Z]+)' + // 伪类名\n    '(?:\\\\(' + // 括号开始\n    '([^\\\\(\\\\)]*' + // 第一种无括号\n    '|(?:' + // 有括号(即伪类中仍有伪类并且是带括号的)\n    '\\\\([^\\\\)]+\\\\)' + // 括号部分\n    /*'|[^\\\\(\\\\)]*' +*/')+)' + // 关闭有括号\n    '\\\\))'),\n    action: function action(yytext, value) {\n        // >>>>>> ?什么意思\n        // false 使用其它方式再token一次\n        if (!yytext.includes('(') && !isPseudoClassWithParen(value)) return null;\n\n        return { type: 'PSEUDO_CLASS', value: yytext };\n    }\n}, { // pesudo-element\n    regexp: (0, _util.$)('::({nmchar}+)'),\n    action: function action(value) {\n        return { type: 'PSEUDO_ELEMENT', value: value };\n    }\n}, { // attribute, [title=haha]\n    regexp: (0, _util.$)('\\\\[\\\\s*(?:{nmchar}+)\\\\s*(?:([*^$|~!]?=)\\\\s*[\\'\\\"]?(?:[^\\'\\\"\\\\[]*)[\\'\\\"]?)?\\\\s*\\\\]'),\n    action: function action(value) {\n        return { type: 'ATTRIBUTE', value: value };\n    }\n}, { // #hash\n    regexp: (0, _util.$)(/#{nmchar}+/),\n    action: function action(value) {\n        return { type: 'HASH', value: value };\n    }\n}, { // string\n    regexp: /(['\"])([^\\r\\n\\f]*?)\\1/,\n    action: function action(yytext, quote) {\n        var value = arguments.length <= 2 || arguments[2] === undefined ? '' : arguments[2];\n\n        return { type: 'STRING', value: value };\n    }\n}, { // punctuator can ignore 'WS'\n    regexp: (0, _util.$)(/{w}*(&&|\\|\\||[\\*\\$\\^~\\|>=<!?]?=|\\.\\.\\.|[\\{;,><]){w}*/),\n    action: function action(yytext, value) {\n        return { type: value };\n        // return {type: 'PUNCTUATOR', value};\n    }\n}, { // whitespace\n    regexp: (0, _util.$)('WS', /{w}+/),\n    action: function action(value) {\n        return { type: 'WS', value: value };\n    }\n}, {\n    // punctuator | operator | logic | other\n    // .. ::\n    // []{}() ; , : & #\n    // ->\n    // *= // $= // ^= ~= |=\n    // >= <= == != =\n    // < > / * + -\n    // ..  or .\n    regexp: /($|#\\{|:|::|[~!#()\\[\\]&\\.]|[\\}%\\-+*\\/])/,\n    action: function action(value) {\n        return { type: value ? value : 'EOF' };\n    }\n}, { // convert escaped unicode to TEXT\n    regexp: (0, _util.$)(/\\\\([0-9a-fA-F]{1,6})/),\n    action: function action(yytext, value) {\n        var hex = parseInt(value, 16);\n        if (hex > MAX_ALLOWED_CODEPOINT) hex = '�';\n        hex = '\\\\' + hex.toString(16);\n        return { type: 'TEXT', value: hex };\n    }\n}];\n\n$rules.forEach(function (rule) {\n    var reg = typeof rule.regexp !== 'string' ? String(rule.regexp).slice(1, -1) : rule.regexp;\n    if (!reg.startsWith('^(?')) rule.regexp = new RegExp('^(?:' + reg + ')');\n});\n\n/**\n * Tokenizer Class\n * @param {object}  options\n * @param {boolean} ignoreComment\n */\n\nvar Tokenizer = function () {\n    function Tokenizer() {\n        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n        _classCallCheck(this, Tokenizer);\n\n        this.options = options;\n        this.options.ignoreComment = true;\n    }\n\n    _createClass(Tokenizer, [{\n        key: 'tokenize',\n        value: function tokenize() {\n            var input = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n\n            // simplify newline token detect\n            this.input = input;\n            // remained input\n            this.remained = input;\n            this.lineno = 1;\n            this.states = ['init'];\n            this.state = 'init';\n            return this.pump();\n        }\n\n        // 一次性输出所有tokens\n\n    }, {\n        key: 'pump',\n        value: function pump() {\n            var tokens = [];\n            var token = void 0;\n            while (token = this.lex()) {\n                tokens.push(token);\n                if (token.type === 'EOF') break;\n            }\n            return tokens;\n        }\n\n        // >>>>>> 一定会有跳过的问题吗？\n        // 依赖next\n\n    }, {\n        key: 'lex',\n        value: function lex() {\n            var token = this.next();\n            return token ? token : this.lex(); // >>>>>> undefined;\n        }\n    }, {\n        key: 'next',\n        value: function next() {\n            var tmp = void 0,\n                token = void 0;\n\n            for (var i = 0; i < $rules.length; i++) {\n                var rule = $rules[i]; //[link[i]];\n                // 匹配\n                tmp = this.remained.match(rule.regexp);\n                if (!tmp) continue;\n                // 生成token\n                token = rule.action.apply(this, tmp);\n                if (token) break;\n            }\n\n            if (tmp && token) {\n                var lines = tmp[0].match(/(?:\\r\\n|[\\n\\r\\f]).*/g);\n                if (lines) this.lineno += lines.length;\n                token.lineno = this.lineno;\n                this.remained = this.remained.slice(tmp[0].length);\n                if (token.type === 'WS') {\n                    if (this._preIsWS) token = undefined;\n                    this._preIsWS = true;\n                } else this._preIsWS = false;\n                return token;\n            } else this.error('Unexpect token start');\n        }\n    }, {\n        key: 'pushState',\n        value: function pushState(condition) {\n            this.states.push(condition);\n            this.state = condition;\n        }\n    }, {\n        key: 'popState',\n        value: function popState() {\n            this.states.pop();\n            this.state = this.states[this.states.length - 1];\n        }\n    }, {\n        key: 'error',\n        value: function (_error) {\n            function error(_x2) {\n                return _error.apply(this, arguments);\n            }\n\n            error.toString = function () {\n                return _error.toString();\n            };\n\n            return error;\n        }(function (message) {\n            var err = new error.SyntaxError(message, this.lineno, this.options);\n            err.column = this._getColumn();\n            throw err;\n        })\n    }, {\n        key: '_getColumn',\n        value: function _getColumn() {\n            var newline = /^[\\n\\f\\r]/;\n            var n = this.input.length - this.remained.length;\n            var column = 0;\n            for (; n--;) {\n                if (newline.test(this.input.charAt(n)) && n >= 0) break;\n                column++;\n            }\n        }\n\n        // _traceError: function(message){\n        //     let matchLength = this.length - this.remained.length;\n        //     let offset = matchLength - 10;\n        //     if(offset < 0) offset = 0;\n        //     let pointer = matchLength - offset;\n        //     let posMessage = this.input.slice(offset, offset + 20)\n        //     // TODO: 加上trace info\n        //     return 'Error on line ' + (this.lineno + 1) + \" \" +\n        //         (message || '. Unrecognized input.') + \"\\n\" + (offset === 0? '':'...') +\n        //         posMessage + \"...\\n\" + new Array(pointer + (offset === 0? 0 : 3) ).join(' ') + new Array(10).join(\"^\");\n        // }\n\n    }]);\n\n    return Tokenizer;\n}();\n\nexports.default = Tokenizer;//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdG9rZW5pemVyLmpzPzg2NTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7QUFNQSxJQUFJLFNBQVMsb0JBQVMsOEZBQVQsQ0FBYjs7O0FBR0EsSUFBSSx5QkFBeUIsb0JBQVMsc0pBQVQsQ0FBN0I7OztBQUdBLElBQU0sd0JBQXdCLFNBQVMsUUFBVCxFQUFrQixFQUFsQixDQUE5QixDO0FBQ0EsSUFBTSx3QkFBd0IsU0FBUyxNQUFULEVBQWlCLEVBQWpCLENBQTlCOzs7Ozs7Ozs7Ozs7O0FBYUEsYUFBRSxJQUFGLEVBQVEsZUFBUixFO0FBQ0EsYUFBRSxHQUFGLEVBQU8sYUFBUCxFO0FBQ0EsYUFBRSxHQUFGLEVBQU8sT0FBUCxFO0FBQ0EsYUFBRSxRQUFGLEVBQVksaUJBQVosRTtBQUNBLGFBQUUsUUFBRixFQUFZLDhCQUFaO0FBQ0EsYUFBRSxTQUFGLEVBQVksaUNBQVo7QUFDQSxhQUFFLE9BQUYsRUFBVyxzQkFBWDs7OztBQUlBLElBQUksU0FBUyxDQUNULEU7QUFDSSxZQUFRLG9DQURaO0FBRUksVUFGSixrQkFFVyxNQUZYLEVBRW1CLFFBRm5CLEVBRTZCLFFBRjdCLEVBRXVDO0FBQy9CLFlBQUksV0FBVyxhQUFhLFNBQTVCOztBQUVBLGFBQUssT0FBTCxDQUFhLE9BQWIsSUFBd0IsS0FBSyxPQUFMLENBQWEsT0FBYixDQUFxQjtBQUN6QyxrQkFBTSxXQUFXLFlBQVgsR0FBeUIsV0FEVTtBQUV6QyxxQkFBUyxXQUFXLFFBQVgsR0FBc0I7QUFGVSxTQUFyQixDQUF4QjtBQUlIO0FBVEwsQ0FEUyxFQVdOLEU7QUFDQyxZQUFRLGFBQUUsdUVBQUYsQ0FEVDtBQUVDLFVBRkQsa0JBRVEsTUFGUixFQUVnQixJQUZoQixFQUV1QixLQUZ2QixFQUU4QixHQUY5QixFQUVtQztBQUM5QixZQUFHLFNBQVMsS0FBWixFQUNJLE9BQU8sRUFBQyxNQUFNLEtBQVAsRUFBYyxPQUFPLEdBQXJCLEVBQVAs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QVM7QUFDWCxnQkFBSSxNQUFNLElBQUksTUFBTSxXQUFWLENBQXNCLE9BQXRCLEVBQStCLEtBQUssTUFBcEMsRUFBNEMsS0FBSyxPQUFqRCxDQUFWO0FBQ0EsZ0JBQUksTUFBSixHQUFhLEtBQUssVUFBTCxFQUFiO0FBQ0Esa0JBQU0sR0FBTjtBQUNILFM7OztxQ0FFWTtBQUNULGdCQUFNLFVBQVUsV0FBaEI7QUFDQSxnQkFBSSxJQUFJLEtBQUssS0FBTCxDQUFXLE1BQVgsR0FBb0IsS0FBSyxRQUFMLENBQWMsTUFBMUM7QUFDQSxnQkFBSSxTQUFTLENBQWI7QUFDQSxtQkFBTSxHQUFOLEdBQVk7QUFDUixvQkFBRyxRQUFRLElBQVIsQ0FBYSxLQUFLLEtBQUwsQ0FBVyxNQUFYLENBQWtCLENBQWxCLENBQWIsS0FBc0MsS0FBSyxDQUE5QyxFQUNJO0FBQ0o7QUFDSDtBQUNKOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tCQWVVLFMiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7JCwgdG9Bc3NlcnR9IGZyb20gJy4vaGVscGVyL3V0aWwuanMnO1xuXG4vLyA+Pj4+Pj4g5b6F5LyY5YyWXG4vLyB0aGUgbW9yZSBmYXN0IHZlcnNpb25cbi8vIGxldCB0b0Fzc2VydDIgPSB1dGlsLm1ha2VQcmVkaWNhdGU7XG5cbmxldCBpc1VuaXQgPSB0b0Fzc2VydCgnJSBlbSBleCBjaCByZW0gdncgdmggdm1pbiB2bWF4IGNtIG1tIGluIHB0IHBjIHB4IGRlZyBncmFkIHJhZCB0dXJuIHMgbXMgSHoga0h6IGRwaSBkcGNtIGRwcHgnKTtcbi8vIGxldCBpc1BzZXVkb0NsYXNzID0gdG9Bc3NlcnQyKFtcImRpclwiLFwibGFuZ1wiLFwiYW55LWxpbmtcIiwgXCJsaW5rXCIsIFwidmlzaXRlZFwiLCBcImxvY2FsLWxpbmtcIixcInRhcmdldFwiLCBcInNjb3BlXCIsIFwiY3VycmVudFwiLCBcInBhc3RcIiwgXCJmdXR1cmVcIiwgXCJhY3RpdmVcIiwgXCJob3ZlclwiLCBcImZvY3VzXCIsIFwiYWN0aXZlLWRyb3BcIiwgXCJ2YWxpZC1kcm9wXCIsIFwiaW52YWxpZC1kcm9wXCIsIFwiZW5hYmxlZFwiLCBcImRpc2FibGVkXCIsIFwiZW5hYmxlZFwiLCBcImRpc2FibGVkXCIsIFwicmVhZC1vbmx5XCIsIFwicmVhZC13cml0ZVwiLCBcInBsYWNlaG9sZGVyLXNob3duXCIsIFwiZGVmYXVsdFwiLCBcImNoZWNrZWRcIiwgXCJpbmRldGVybWluYXRlXCIsIFwidmFsaWRcIiwgXCJpbnZhbGlkXCIsIFwiaW4tcmFuZ2VcIiwgXCJvdXQtb2YtcmFuZ2VcIiwgXCJyZXF1aXJlZFwiLCBcIm9wdGlvbmFsXCIsIFwicm9vdFwiLCBcImVtcHR5XCIsIFwiYmxhbmtcIiwgXCJudGgtY2hpbGRcIiwgXCJudGgtbGFzdC1jaGlsZFwiLCBcImZpcnN0LWNoaWxkXCIsIFwibGFzdC1jaGlsZFwiLCBcIm9ubHktY2hpbGRcIiwgXCJudGgtb2YtdHlwZVwiLCBcIm50aC1sYXN0LW9mLXR5cGVcIiwgXCJmaXJzdC1vZi10eXBlXCIsIFwibGFzdC1vZi10eXBlXCIsIFwib25seS1vZi10eXBlXCIsIFwibnRoLW1hdGNoXCIsIFwibnRoLWxhc3QtbWF0Y2hcIiwgJ250aC1jb2x1bW4nLCAnbnRoLWxhc3QtY29sdW1uJywgJ25vdCcsICdtYXRjaGVzJywgJ2JlZm9yZScsICdhZnRlcicsICctbW96LXBsYWNlaG9sZGVyJ10pO1xuLy8gbGV0IGlzQmlmcyA9IHRvQXNzZXJ0MihiaWZzLmNvbmNhdChbJ3JnYicsICdyZ2JhJywgJ3VybCcsICdjb3VudGVyJywgJ2F0dHInLCAnY2FsYycsICdtaW4nLCAnbWF4JywgJ2N5Y2xlJywgJ2xpbmVhci1ncmFkaWVudCcsICdyYWRpYWwtZ3JhZGllbnQnLCAncmVwZWF0aW5nLWxpbmVhci1ncmFkaWVudCcsICdyZXBlYXRpbmctcmFkaWFsLWdyYWRpZW50J10pLCB0cnVlKTtcbmxldCBpc1BzZXVkb0NsYXNzV2l0aFBhcmVuID0gdG9Bc3NlcnQoJ2N1cnJlbnQgbG9jYWwtbGluayBudGgtY2hpbGQgbnRoLWxhc3QtY2hpbGQgbnRoLW9mLXR5cGUgbnRoLWxhc3Qtb2YtdHlwZSBudGgtbWF0Y2ggbnRoLWxhc3QtbWF0Y2ggY29sdW1uIG50aC1jb2x1bW4gbnRoLWxhc3QtY29sdW1uIGxhbmcgbWF0Y2hlcyBub3QnKTtcblxuLy8gW1czQ106IGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy1zeW50YXgvXG5jb25zdCBNQVhfQUxMT1dFRF9DT0RFUE9JTlQgPSBwYXJzZUludCgnMTBGRkZGJywxNik7ICAgIC8vIFtXM0MjbWF4aW11bS1hbGxvd2VkLWNvZGVwb2ludF1cbmNvbnN0IFJFUExBQ0VNRU5UX0NIQVJBQ1RFUiA9IHBhcnNlSW50KCdGRkZEJywgMTYpO1xuXG4vLyBUb2tlbiBUeXBlc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPj4+Pj4+IOS7gOS5iOaEj+aAnVxuLy8gLy8gaW5zcGVjdFRva2VuLCBnZXQgdG9rZW5OYW1lIHdpdGggVG9rZW5UeXBlKHVpZClcbi8vIHRva2VuaXplci5pbnNwZWN0ID0gZnVuY3Rpb24odG9rZW5UeXBlKXtcbi8vICAgICBsZXQgdHlwZVR5cGUgPSB0b2tlblR5cGUudHlwZSB8fCB0b2tlblR5cGU7XG4vLyAgICAgZm9yKGxldCBpIGluIHRva2VuaXplcil7XG4vLyAgICAgICAgIGlmKHR5cGVvZiB0b2tlbml6ZXJbaV0gPT09ICdudW1iZXInICYmIHRva2VuaXplcltpXSA9PT0gdG9rZW5UeXBlKSByZXR1cm4gaTtcbi8vICAgICB9XG4vLyB9XG5cbiQoJ25sJywgL1xcclxcbnxbXFxyXFxmXFxuXS8pOyAgICAvLyBuZXdsaW5lXG4kKCd3JywgL1sgXFx0XFxyXFxuXFxmXS8pOyAgICAvLyB3aGl0ZXNwYWNlXG4kKCdkJywgL1swLTldLyk7ICAgIC8vIGRpZ2l0YWxcbiQoJ2VzY2FwZScsIC9cXFxcWzAtOWEtZl17MSw2fS8pOyAgICAgLy8gZXNjYXBlIGNoYXJcbiQoJ25tY2hhcicsIC9bXy1cXHdcXHUwMEExLVxcdUZGRkZdfHtlc2NhcGV9Lyk7XG4kKCdubXN0YXJ0JywvW19hLXpBLVpcXHUwMEExLVxcdUZGRkZdfHtlc2NhcGV9LyApO1xuJCgnaWRlbnQnLCAvLT97bm1zdGFydH17bm1jaGFyfSovKTtcblxuLy8gcmVnaXN0ZWQgbWFjcm9zXG4vLyA9PT09PT09PT09PT09PT09PT09PT1cbmxldCAkcnVsZXMgPSBbXG4gICAgeyAgICAgICAvLyBtdWx0aWxpbmUgY29tbWVudCB8IHNpbmdsZWxpbmUgY29tbWVudFxuICAgICAgICByZWdleHA6IC9cXC9cXCooW15cXHgwMF0rPylcXCpcXC98XFwvXFwvKFteXFxuXFxyXSopLyxcbiAgICAgICAgYWN0aW9uKHl5dGV4dCwgbWNvbW1lbnQsIHNjb21tZW50KSB7XG4gICAgICAgICAgICBsZXQgaXNTaW5nbGUgPSBtY29tbWVudCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgLy8gPj4+Pj4+ID8g6L+Z5Liq5pa55rOV5piv5oCO5LmI55So55qEXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuY29tbWVudCAmJiB0aGlzLm9wdGlvbnMuY29tbWVudCh7XG4gICAgICAgICAgICAgICAgdHlwZTogaXNTaW5nbGUgPyAnc2luZ2xlbGluZSc6ICdtdWx0aWxpbmUnLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGlzU2luZ2xlID8gc2NvbW1lbnQgOiBtY29tbWVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCB7ICAgIC8vIHVybCBbVzNDXVxuICAgICAgICByZWdleHA6ICQoLyh1cmx8dXJsXFwtcHJlZml4fGRvbWFpbnxyZWdleHApe3d9KlxcKChbJ1wiXSk/e3d9KihbXlxcclxcblxcZl0qPylcXDJ7d30qXFwpLyksXG4gICAgICAgIGFjdGlvbih5eXRleHQsIG5hbWUgLCBxdW90ZSwgdXJsKSB7XG4gICAgICAgICAgICBpZihuYW1lID09PSAndXJsJylcbiAgICAgICAgICAgICAgICByZXR1cm4ge3R5cGU6ICdVUkwnLCB2YWx1ZTogdXJsfTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4ge3R5cGU6ICdGVU5DVElPTicsIHZhbHVlOiBuYW1lLCBhcmdzOiBbeyB0eXBlOiAnU1RSSU5HJywgdmFsdWU6IHVybCB9XX07XG4gICAgICAgIH1cbiAgICB9LCB7ICAgLy8gZnVuY3Rpb24gW1czQ11cbiAgICAgICAgcmVnZXhwOiAkKC8oPzpcXCQ/LT9bX0EtWmEtel1bLV9cXHddKikoPz1cXCgpLyksXG4gICAgICAgIGFjdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiAnRlVOQ1RJT04nLCB2YWx1ZX07XG4gICAgICAgIH1cbiAgICB9LCB7ICAgIC8vICR2YXJpYWJsZVxuICAgICAgICByZWdleHA6IC9cXCQoLT9bX0EtWmEtel1bLV9cXHddKikvLFxuICAgICAgICBhY3Rpb24oeXl0ZXh0LCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiAnVkFSJywgdmFsdWV9O1xuICAgICAgICB9XG4gICAgfSwgeyAgICAvLyBpZGVudCBbVzNDXSwg5Y2zIC1vLXdlYmtpdC14eCDmmK/lhYHorrjnmoRcbiAgICAgICAgcmVnZXhwOiAkKC97aWRlbnR9LyksXG4gICAgICAgIGFjdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaWYodmFsdWUgPT09ICdmYWxzZScgfHwgdmFsdWUgPT09ICd0cnVlJylcbiAgICAgICAgICAgICAgICByZXR1cm4ge3R5cGU6ICdCT09MRUFOJywgdmFsdWU6IHZhbHVlID09PSAndHJ1ZSd9O1xuICAgICAgICAgICAgZWxzZSBpZih2YWx1ZSA9PT0gJ251bGwnKVxuICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogJ05VTEwnLCB2YWx1ZTogbnVsbH07XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiAnVEVYVCcsIHZhbHVlfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy8geyAgICAvLyBAY3NzIGF0LXJ1bGUgbm8gcGFyc2VcbiAgICAvLyAgICAgcmVnOiAvQGNzc3t3fSp7LyxcbiAgICAvLyAgICAgYWN0aW9uKHl5dGV4dCkge1xuICAgIC8vICAgICB9XG4gICAgLy8gfSxcbiAgICB7ICAgICAgIC8vIGRpbWVuc2lvbjogbnVtYmVyICsgdW5pdFxuICAgICAgICByZWdleHA6ICQoLygtPyg/OntkfSpcXC57ZH0rfHtkfSspKShcXHcqfCUpPy8pLFxuICAgICAgICBhY3Rpb24oeXl0ZXh0LCB2YWx1ZSwgdW5pdCkge1xuICAgICAgICAgICAgaWYodW5pdCAmJiAhaXNVbml0KHVuaXQpKVxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoJ1VuZXhjZXB0IHVuaXQ6IFwiJyArIHVuaXQgKyAnXCInKTtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogJ0RJTUVOU0lPTicsIHZhbHVlOiArdmFsdWUsIHVuaXR9O1xuICAgICAgICB9XG4gICAgfSwgeyAgICAvLyBjbGFzc1xuICAgICAgICByZWdleHA6ICQoL1xcLih7bm1jaGFyfSspLyksXG4gICAgICAgIGFjdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiAnQ0xBU1MnLCB2YWx1ZX07XG4gICAgICAgIH1cbiAgICB9LCB7ICAgIC8vIGF0LWtleXdvcmQsIEBcbiAgICAgICAgcmVnZXhwOiAvQCgtP1tfQS1aYS16XVstX1xcd10qKS8sXG4gICAgICAgIGFjdGlvbih5eXRleHQsIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6ICdBVF9LRVlXT1JEJywgdmFsdWV9O1xuICAgICAgICB9XG4gICAgfSwgeyAgICAvLyAhaW1wb3J0YW50XG4gICAgICAgIHJlZ2V4cDogJCgvIXt3fSppbXBvcnRhbnQvKSxcbiAgICAgICAgYWN0aW9uKHl5dGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiAnSU1QT1JUQU5UJ307XG4gICAgICAgIH1cbiAgICB9LCB7ICAgIC8vIHBlc3Vkby1jbGFzc1xuICAgICAgICByZWdleHA6ICQoJzooWy1fYS16QS1aXSspJyArIC8vIOS8quexu+WQjVxuICAgICAgICAgICAgJyg/OlxcXFwoJyArIC8vIOaLrOWPt+W8gOWni1xuICAgICAgICAgICAgJyhbXlxcXFwoXFxcXCldKicgKyAvLyDnrKzkuIDnp43ml6Dmi6zlj7dcbiAgICAgICAgICAgICd8KD86JyArIC8vIOacieaLrOWPtyjljbPkvKrnsbvkuK3ku43mnInkvKrnsbvlubbkuJTmmK/luKbmi6zlj7fnmoQpXG4gICAgICAgICAgICAnXFxcXChbXlxcXFwpXStcXFxcKScgKyAvLyDmi6zlj7fpg6jliIZcbiAgICAgICAgICAgIC8qJ3xbXlxcXFwoXFxcXCldKicgKyovICcpKyknICsgLy8g5YWz6Zet5pyJ5ous5Y+3XG4gICAgICAgICAgICAnXFxcXCkpJyksXG4gICAgICAgIGFjdGlvbih5eXRleHQsIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyA+Pj4+Pj4gP+S7gOS5iOaEj+aAnVxuICAgICAgICAgICAgLy8gZmFsc2Ug5L2/55So5YW25a6D5pa55byP5YaNdG9rZW7kuIDmrKFcbiAgICAgICAgICAgIGlmKCF5eXRleHQuaW5jbHVkZXMoJygnKSAmJiAhaXNQc2V1ZG9DbGFzc1dpdGhQYXJlbih2YWx1ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogJ1BTRVVET19DTEFTUycgLCB2YWx1ZTogeXl0ZXh0fTtcbiAgICAgICAgfVxuICAgIH0sIHsgICAgLy8gcGVzdWRvLWVsZW1lbnRcbiAgICAgICAgcmVnZXhwOiAkKCc6Oih7bm1jaGFyfSspJyksXG4gICAgICAgIGFjdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiAnUFNFVURPX0VMRU1FTlQnLCB2YWx1ZX07XG4gICAgICAgIH1cbiAgICB9LCB7ICAgIC8vIGF0dHJpYnV0ZSwgW3RpdGxlPWhhaGFdXG4gICAgICAgIHJlZ2V4cDogJCgnXFxcXFtcXFxccyooPzp7bm1jaGFyfSspXFxcXHMqKD86KFsqXiR8fiFdPz0pXFxcXHMqW1xcJ1xcXCJdPyg/OlteXFwnXFxcIlxcXFxbXSopW1xcJ1xcXCJdPyk/XFxcXHMqXFxcXF0nKSxcbiAgICAgICAgYWN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6ICdBVFRSSUJVVEUnLCB2YWx1ZX07XG4gICAgICAgIH1cbiAgICB9LCB7ICAgIC8vICNoYXNoXG4gICAgICAgIHJlZ2V4cDogJCgvI3tubWNoYXJ9Ky8pLFxuICAgICAgICBhY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogJ0hBU0gnLCB2YWx1ZX07XG4gICAgICAgIH1cbiAgICB9LCB7ICAgIC8vIHN0cmluZ1xuICAgICAgICByZWdleHA6IC8oWydcIl0pKFteXFxyXFxuXFxmXSo/KVxcMS8sXG4gICAgICAgIGFjdGlvbih5eXRleHQsIHF1b3RlLCB2YWx1ZSA9ICcnKXtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogJ1NUUklORycsIHZhbHVlfTtcbiAgICAgICAgfVxuICAgIH0sIHsgICAgLy8gcHVuY3R1YXRvciBjYW4gaWdub3JlICdXUydcbiAgICAgICAgcmVnZXhwOiAkKC97d30qKCYmfFxcfFxcfHxbXFwqXFwkXFxeflxcfD49PCE/XT89fFxcLlxcLlxcLnxbXFx7Oyw+PF0pe3d9Ki8pLFxuICAgICAgICBhY3Rpb24oeXl0ZXh0LCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiB2YWx1ZX07XG4gICAgICAgICAgICAvLyByZXR1cm4ge3R5cGU6ICdQVU5DVFVBVE9SJywgdmFsdWV9O1xuICAgICAgICB9XG4gICAgfSwgeyAgICAvLyB3aGl0ZXNwYWNlXG4gICAgICAgIHJlZ2V4cDogJCgnV1MnLCAve3d9Ky8pLFxuICAgICAgICBhY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogJ1dTJywgdmFsdWV9O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICAvLyBwdW5jdHVhdG9yIHwgb3BlcmF0b3IgfCBsb2dpYyB8IG90aGVyXG4gICAgICAgIC8vIC4uIDo6XG4gICAgICAgIC8vIFtde30oKSA7ICwgOiAmICNcbiAgICAgICAgLy8gLT5cbiAgICAgICAgLy8gKj0gLy8gJD0gLy8gXj0gfj0gfD1cbiAgICAgICAgLy8gPj0gPD0gPT0gIT0gPVxuICAgICAgICAvLyA8ID4gLyAqICsgLVxuICAgICAgICAvLyAuLiAgb3IgLlxuICAgICAgICByZWdleHA6IC8oJHwjXFx7fDp8Ojp8W34hIygpXFxbXFxdJlxcLl18W1xcfSVcXC0rKlxcL10pLyxcbiAgICAgICAgYWN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IHZhbHVlID8gdmFsdWUgOiAnRU9GJ307XG4gICAgICAgIH1cbiAgICB9LCB7ICAgIC8vIGNvbnZlcnQgZXNjYXBlZCB1bmljb2RlIHRvIFRFWFRcbiAgICAgICAgcmVnZXhwOiAkKC9cXFxcKFswLTlhLWZBLUZdezEsNn0pLyksXG4gICAgICAgIGFjdGlvbih5eXRleHQsIHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgaGV4ID0gcGFyc2VJbnQodmFsdWUsIDE2KTtcbiAgICAgICAgICAgIGlmKGhleCA+IE1BWF9BTExPV0VEX0NPREVQT0lOVClcbiAgICAgICAgICAgICAgICBoZXggPSAnXFx1RkZGRCc7XG4gICAgICAgICAgICBoZXggPSAnXFxcXCcgKyBoZXgudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiAnVEVYVCcsIHZhbHVlOiBoZXh9O1xuICAgICAgICB9XG4gICAgfVxuXTtcblxuJHJ1bGVzLmZvckVhY2goKHJ1bGUpID0+IHtcbiAgICBsZXQgcmVnID0gdHlwZW9mIHJ1bGUucmVnZXhwICE9PSAnc3RyaW5nJyA/IFN0cmluZyhydWxlLnJlZ2V4cCkuc2xpY2UoMSwgLTEpIDogcnVsZS5yZWdleHA7XG4gICAgaWYoIXJlZy5zdGFydHNXaXRoKCdeKD8nKSlcbiAgICAgICAgcnVsZS5yZWdleHAgPSBuZXcgUmVnRXhwKCdeKD86JyArIHJlZyArICcpJyk7XG59KTtcblxuLyoqXG4gKiBUb2tlbml6ZXIgQ2xhc3NcbiAqIEBwYXJhbSB7b2JqZWN0fSAgb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBpZ25vcmVDb21tZW50XG4gKi9cbmNsYXNzIFRva2VuaXplciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMub3B0aW9ucy5pZ25vcmVDb21tZW50ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0b2tlbml6ZShpbnB1dCA9ICcnKSB7XG4gICAgICAgIC8vIHNpbXBsaWZ5IG5ld2xpbmUgdG9rZW4gZGV0ZWN0XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgLy8gcmVtYWluZWQgaW5wdXRcbiAgICAgICAgdGhpcy5yZW1haW5lZCA9IGlucHV0O1xuICAgICAgICB0aGlzLmxpbmVubyA9IDE7XG4gICAgICAgIHRoaXMuc3RhdGVzID0gWydpbml0J107XG4gICAgICAgIHRoaXMuc3RhdGUgPSAnaW5pdCc7XG4gICAgICAgIHJldHVybiB0aGlzLnB1bXAoKTtcbiAgICB9XG5cbiAgICAvLyDkuIDmrKHmgKfovpPlh7rmiYDmnIl0b2tlbnNcbiAgICBwdW1wKCkge1xuICAgICAgICBsZXQgdG9rZW5zID0gW107XG4gICAgICAgIGxldCB0b2tlbjtcbiAgICAgICAgd2hpbGUodG9rZW4gPSB0aGlzLmxleCgpKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICBpZih0b2tlbi50eXBlID09PSAnRU9GJylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cblxuICAgIC8vID4+Pj4+PiDkuIDlrprkvJrmnInot7Pov4fnmoTpl67popjlkJfvvJ9cbiAgICAvLyDkvp3otZZuZXh0XG4gICAgbGV4KCkge1xuICAgICAgICBsZXQgdG9rZW4gPSB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRva2VuID8gdG9rZW4gOiB0aGlzLmxleCgpOyAvLyA+Pj4+Pj4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIG5leHQoKSB7XG4gICAgICAgIGxldCB0bXAsIHRva2VuO1xuXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCAkcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBydWxlID0gJHJ1bGVzW2ldOyAvL1tsaW5rW2ldXTtcbiAgICAgICAgICAgIC8vIOWMuemFjVxuICAgICAgICAgICAgdG1wID0gdGhpcy5yZW1haW5lZC5tYXRjaChydWxlLnJlZ2V4cCk7XG4gICAgICAgICAgICBpZighdG1wKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgLy8g55Sf5oiQdG9rZW5cbiAgICAgICAgICAgIHRva2VuID0gcnVsZS5hY3Rpb24uYXBwbHkodGhpcywgdG1wKTtcbiAgICAgICAgICAgIGlmKHRva2VuKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodG1wICYmIHRva2VuKSB7XG4gICAgICAgICAgICBsZXQgbGluZXMgPSB0bXBbMF0ubWF0Y2goLyg/OlxcclxcbnxbXFxuXFxyXFxmXSkuKi9nKTtcbiAgICAgICAgICAgIGlmKGxpbmVzKVxuICAgICAgICAgICAgICAgIHRoaXMubGluZW5vICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgICAgIHRva2VuLmxpbmVubyA9IHRoaXMubGluZW5vO1xuICAgICAgICAgICAgdGhpcy5yZW1haW5lZCA9IHRoaXMucmVtYWluZWQuc2xpY2UodG1wWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICBpZih0b2tlbi50eXBlID09PSAnV1MnKSB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5fcHJlSXNXUylcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJlSXNXUyA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmVJc1dTID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgdGhpcy5lcnJvcignVW5leHBlY3QgdG9rZW4gc3RhcnQnKTtcbiAgICB9XG5cbiAgICBwdXNoU3RhdGUoY29uZGl0aW9uKSB7XG4gICAgICAgIHRoaXMuc3RhdGVzLnB1c2goY29uZGl0aW9uKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IGNvbmRpdGlvbjtcbiAgICB9XG5cbiAgICBwb3BTdGF0ZSgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZXMucG9wKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlc1t0aGlzLnN0YXRlcy5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICBlcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIGxldCBlcnIgPSBuZXcgZXJyb3IuU3ludGF4RXJyb3IobWVzc2FnZSwgdGhpcy5saW5lbm8sIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIGVyci5jb2x1bW4gPSB0aGlzLl9nZXRDb2x1bW4oKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIF9nZXRDb2x1bW4oKSB7XG4gICAgICAgIGNvbnN0IG5ld2xpbmUgPSAvXltcXG5cXGZcXHJdLztcbiAgICAgICAgbGV0IG4gPSB0aGlzLmlucHV0Lmxlbmd0aCAtIHRoaXMucmVtYWluZWQubGVuZ3RoO1xuICAgICAgICBsZXQgY29sdW1uID0gMDtcbiAgICAgICAgZm9yKDsgbi0tOykge1xuICAgICAgICAgICAgaWYobmV3bGluZS50ZXN0KHRoaXMuaW5wdXQuY2hhckF0KG4pKSAmJiBuID49IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjb2x1bW4rK1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gX3RyYWNlRXJyb3I6IGZ1bmN0aW9uKG1lc3NhZ2Upe1xuICAgIC8vICAgICBsZXQgbWF0Y2hMZW5ndGggPSB0aGlzLmxlbmd0aCAtIHRoaXMucmVtYWluZWQubGVuZ3RoO1xuICAgIC8vICAgICBsZXQgb2Zmc2V0ID0gbWF0Y2hMZW5ndGggLSAxMDtcbiAgICAvLyAgICAgaWYob2Zmc2V0IDwgMCkgb2Zmc2V0ID0gMDtcbiAgICAvLyAgICAgbGV0IHBvaW50ZXIgPSBtYXRjaExlbmd0aCAtIG9mZnNldDtcbiAgICAvLyAgICAgbGV0IHBvc01lc3NhZ2UgPSB0aGlzLmlucHV0LnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgMjApXG4gICAgLy8gICAgIC8vIFRPRE86IOWKoOS4inRyYWNlIGluZm9cbiAgICAvLyAgICAgcmV0dXJuICdFcnJvciBvbiBsaW5lICcgKyAodGhpcy5saW5lbm8gKyAxKSArIFwiIFwiICtcbiAgICAvLyAgICAgICAgIChtZXNzYWdlIHx8ICcuIFVucmVjb2duaXplZCBpbnB1dC4nKSArIFwiXFxuXCIgKyAob2Zmc2V0ID09PSAwPyAnJzonLi4uJykgK1xuICAgIC8vICAgICAgICAgcG9zTWVzc2FnZSArIFwiLi4uXFxuXCIgKyBuZXcgQXJyYXkocG9pbnRlciArIChvZmZzZXQgPT09IDA/IDAgOiAzKSApLmpvaW4oJyAnKSArIG5ldyBBcnJheSgxMCkuam9pbihcIl5cIik7XG4gICAgLy8gfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUb2tlbml6ZXI7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy90b2tlbml6ZXIuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 2 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n// import fs from 'fs';\n// import mkdirp from 'mkdirp';\n// import path from 'path';\n// import tpl from './tpl';\n// import tpl from './tpl';\n\nvar returnTrue = function returnTrue() {\n    return true;\n};\n\nvar _ = {\n    accept: function accept(fn, list) {\n        if (!list || !list.length) return;\n\n        var tlist = list.map(function (item) {\n            if (!item) return returnTrue;\n\n            if (typeof item === 'function') return item;\n\n            return _.makePredicate(item);\n        });\n    }\n};\n\n/**\n * register regexp pattern\n * @return {[type]} [description]\n */\nvar $ = function () {\n    var table = {};\n    return function (name, pattern) {\n        if (!pattern) {\n            if (/^[a-zA-Z]+$/.test(name)) // $('WS');\n                return table[name];else {\n                // $(/.../);\n                pattern = name;\n                name = null;\n            }\n        }\n\n        if (typeof pattern !== 'string') pattern = String(pattern).slice(1, -1);\n\n        pattern = pattern.replace(/\\{([a-zA-Z]+)}/g, function (all, name) {\n            var p = table[name];\n            if (!p) throw Error('no register pattern ' + name + ' before');\n            var pstart = p.charAt(0),\n                pend = p.charAt(p.length - 1);\n            if (!(pstart === '[' && pend === ']') && !(pstart === '(' && pend === ')')) p = '(?:' + p + ')';\n            return p;\n        });\n\n        // register\n        name && (table[name] = pattern);\n        return new RegExp(pattern);\n    };\n}();\n\nvar toAssert = function toAssert(str) {\n    var arr = typeof str === 'string' ? str.split(/\\s+/) : str;\n    return function (word) {\n        return arr.includes(word);\n    };\n};\n\nvar makePredicate = toAssert;\n\nexports.$ = $;\nexports.toAssert = toAssert;\nexports.makePredicate = makePredicate;//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaGVscGVyL3V0aWwuanM/OTY4OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQU1BLElBQU0sYUFBYSxTQUFiLFVBQWE7QUFBQSxXQUFNLElBQU47QUFBQSxDQUFuQjs7QUFFQSxJQUFJLElBQUk7QUFDSixVQURJLGtCQUNHLEVBREgsRUFDTyxJQURQLEVBQ2E7QUFDYixZQUFHLENBQUMsSUFBRCxJQUFTLENBQUMsS0FBSyxNQUFsQixFQUNJOztBQUVKLFlBQUksUUFBUSxLQUFLLEdBQUwsQ0FBUyxVQUFDLElBQUQsRUFBVTtBQUMzQixnQkFBRyxDQUFDLElBQUosRUFDSSxPQUFPLFVBQVA7O0FBRUosZ0JBQUcsT0FBTyxJQUFQLEtBQWdCLFVBQW5CLEVBQ0ksT0FBTyxJQUFQOztBQUVKLG1CQUFPLEVBQUUsYUFBRixDQUFnQixJQUFoQixDQUFQO0FBQ0gsU0FSVyxDQUFaO0FBV0g7QUFoQkcsQ0FBUjs7Ozs7O0FBMEJBLElBQUksSUFBSyxZQUFXO0FBQ2hCLFFBQUksUUFBUSxFQUFaO0FBQ0EsV0FBTyxVQUFDLElBQUQsRUFBTyxPQUFQLEVBQW1CO0FBQ3RCLFlBQUcsQ0FBQyxPQUFKLEVBQWE7QUFDVCxnQkFBRyxjQUFjLElBQWQsQ0FBbUIsSUFBbkIsQ0FBSCxFO0FBQ0ksdUJBQU8sTUFBTSxJQUFOLENBQVAsQ0FESixLQUVLOztBQUNELDBCQUFVLElBQVY7QUFDQSx1QkFBTyxJQUFQO0FBQ0g7QUFDSjs7QUFFRCxZQUFHLE9BQU8sT0FBUCxLQUFtQixRQUF0QixFQUNJLFVBQVUsT0FBTyxPQUFQLEVBQWdCLEtBQWhCLENBQXNCLENBQXRCLEVBQXlCLENBQUMsQ0FBMUIsQ0FBVjs7QUFFSixrQkFBVSxRQUFRLE9BQVIsQ0FBZ0IsaUJBQWhCLEVBQW1DLFVBQUMsR0FBRCxFQUFNLElBQU4sRUFBZTtBQUN4RCxnQkFBSSxJQUFJLE1BQU0sSUFBTixDQUFSO0FBQ0EsZ0JBQUcsQ0FBQyxDQUFKLEVBQ0ksTUFBTSwrQkFBNkIsSUFBN0IsYUFBTjtBQUNKLGdCQUFJLFNBQVMsRUFBRSxNQUFGLENBQVMsQ0FBVCxDQUFiO2dCQUEwQixPQUFPLEVBQUUsTUFBRixDQUFTLEVBQUUsTUFBRixHQUFXLENBQXBCLENBQWpDO0FBQ0EsZ0JBQUcsRUFBRSxXQUFXLEdBQVgsSUFBa0IsU0FBUyxHQUE3QixLQUFxQyxFQUFFLFdBQVcsR0FBWCxJQUFrQixTQUFTLEdBQTdCLENBQXhDLEVBQ0ksSUFBSSxRQUFRLENBQVIsR0FBWSxHQUFoQjtBQUNKLG1CQUFPLENBQVA7QUFDSCxTQVJTLENBQVY7OztBQVdBLGlCQUFTLE1BQU0sSUFBTixJQUFjLE9BQXZCO0FBQ0EsZUFBTyxJQUFJLE1BQUosQ0FBVyxPQUFYLENBQVA7QUFDSCxLQTFCRDtBQTJCSCxDQTdCTyxFQUFSOztBQStCQSxJQUFJLFdBQVcsU0FBWCxRQUFXLENBQVMsR0FBVCxFQUFjO0FBQ3pCLFFBQUksTUFBTSxPQUFPLEdBQVAsS0FBZSxRQUFmLEdBQTBCLElBQUksS0FBSixDQUFVLEtBQVYsQ0FBMUIsR0FBNkMsR0FBdkQ7QUFDQSxXQUFPLFVBQUMsSUFBRDtBQUFBLGVBQVUsSUFBSSxRQUFKLENBQWEsSUFBYixDQUFWO0FBQUEsS0FBUDtBQUNILENBSEQ7O0FBS0EsSUFBSSxnQkFBZ0IsUUFBcEI7O1FBRVEsQyxHQUFBLEM7UUFBRyxRLEdBQUEsUTtRQUFVLGEsR0FBQSxhIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnQgZnMgZnJvbSAnZnMnO1xuLy8gaW1wb3J0IG1rZGlycCBmcm9tICdta2RpcnAnO1xuLy8gaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG4vLyBpbXBvcnQgdHBsIGZyb20gJy4vdHBsJztcbi8vIGltcG9ydCB0cGwgZnJvbSAnLi90cGwnO1xuXG5jb25zdCByZXR1cm5UcnVlID0gKCkgPT4gdHJ1ZTtcblxubGV0IF8gPSB7XG4gICAgYWNjZXB0KGZuLCBsaXN0KSB7XG4gICAgICAgIGlmKCFsaXN0IHx8ICFsaXN0Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBsZXQgdGxpc3QgPSBsaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYoIWl0ZW0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblRydWU7XG5cbiAgICAgICAgICAgIGlmKHR5cGVvZiBpdGVtID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuXG4gICAgICAgICAgICByZXR1cm4gXy5tYWtlUHJlZGljYXRlKGl0ZW0pO1xuICAgICAgICB9KTtcblxuXG4gICAgfSxcblxuXG5cbn07XG5cbi8qKlxuICogcmVnaXN0ZXIgcmVnZXhwIHBhdHRlcm5cbiAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICovXG5sZXQgJCA9IChmdW5jdGlvbigpIHtcbiAgICBsZXQgdGFibGUgPSB7fTtcbiAgICByZXR1cm4gKG5hbWUsIHBhdHRlcm4pID0+IHtcbiAgICAgICAgaWYoIXBhdHRlcm4pIHtcbiAgICAgICAgICAgIGlmKC9eW2EtekEtWl0rJC8udGVzdChuYW1lKSkgICAgLy8gJCgnV1MnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFibGVbbmFtZV07XG4gICAgICAgICAgICBlbHNlIHsgIC8vICQoLy4uLi8pO1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gPSBuYW1lO1xuICAgICAgICAgICAgICAgIG5hbWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYodHlwZW9mIHBhdHRlcm4gIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcGF0dGVybiA9IFN0cmluZyhwYXR0ZXJuKS5zbGljZSgxLCAtMSk7XG5cbiAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZSgvXFx7KFthLXpBLVpdKyl9L2csIChhbGwsIG5hbWUpID0+IHtcbiAgICAgICAgICAgIGxldCBwID0gdGFibGVbbmFtZV07XG4gICAgICAgICAgICBpZighcClcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgbm8gcmVnaXN0ZXIgcGF0dGVybiAke25hbWV9IGJlZm9yZWApO1xuICAgICAgICAgICAgbGV0IHBzdGFydCA9IHAuY2hhckF0KDApLCBwZW5kID0gcC5jaGFyQXQocC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGlmKCEocHN0YXJ0ID09PSAnWycgJiYgcGVuZCA9PT0gJ10nKSAmJiAhKHBzdGFydCA9PT0gJygnICYmIHBlbmQgPT09ICcpJykpXG4gICAgICAgICAgICAgICAgcCA9ICcoPzonICsgcCArICcpJztcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyByZWdpc3RlclxuICAgICAgICBuYW1lICYmICh0YWJsZVtuYW1lXSA9IHBhdHRlcm4pO1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuKTtcbiAgICB9XG59KSgpO1xuXG5sZXQgdG9Bc3NlcnQgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBsZXQgYXJyID0gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgPyBzdHIuc3BsaXQoL1xccysvKSA6IHN0cjtcbiAgICByZXR1cm4gKHdvcmQpID0+IGFyci5pbmNsdWRlcyh3b3JkKTtcbn1cblxubGV0IG1ha2VQcmVkaWNhdGUgPSB0b0Fzc2VydDtcblxuZXhwb3J0IHskLCB0b0Fzc2VydCwgbWFrZVByZWRpY2F0ZX1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2hlbHBlci91dGlsLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _util = __webpack_require__(2);\n\nvar _ = _interopRequireWildcard(_util);\n\nvar _tree = __webpack_require__(4);\n\nvar tree = _interopRequireWildcard(_tree);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar STATES = {\n    // 进入filter\n    FILTER_DECLARATION: Symbol(),\n    // 失败则进入Ruleset\n    TRY_DECLARATION: Symbol(),\n    TRY_INTERPOLATION: Symbol(),\n    // 当遇到特殊属性时\n    FUNCTION_CALL: Symbol()\n};\nvar ASSIGNS = { '=': 1, '?=': 2, '^=': 3 };\nvar COMBOS = 'WS > ~ +';\n\nvar isSkipStart = _.makePredicate('WS NEWLINE COMMENT ;');\nvar isWSOrNewLine = _.makePredicate('WS NEWLINE');\nvar isCombo = _.makePredicate(COMBOS);\n\n// probably selector segment\nvar isSelectorSep = _.makePredicate('WS > ~ +' + 'PSEUDO_CLASS PSEUDO_ELEMENT ATTRIBUTE CLASS HASH & TEXT * # #{ : . % - compoundident DIMENSION');\n\nvar isOperator = _.makePredicate('+ - * /');\nvar isRelationOp = _.makePredicate('== >= <= < > !=');\nvar isCommaOrParen = _.makePredicate(', )');\nvar isDirectOperate = _.makePredicate('DIMENSION STRING BOOLEAN TEXT NULL');\n\nvar isColor = _.makePredicate(\"aliceblue antiquewhite aqua aquamarine azure beige bisque black blanchedalmond blue blueviolet brown burlywood cadetblue chartreuse chocolate coral cornflowerblue cornsilk crimson cyan darkblue darkcyan darkgoldenrod darkgray darkgrey darkgreen darkkhaki darkmagenta darkolivegreen darkorange darkorchid darkred darksalmon darkseagreen darkslateblue darkslategray darkslategrey darkturquoise darkviolet deeppink deepskyblue dimgray dimgrey dodgerblue firebrick floralwhite forestgreen fuchsia gainsboro ghostwhite gold goldenrod gray grey green greenyellow honeydew hotpink indianred indigo ivory khaki lavender lavenderblush lawngreen lemonchiffon lightblue lightcoral lightcyan lightgoldenrodyellow lightgray lightgrey lightgreen lightpink lightsalmon lightseagreen lightskyblue lightslategray lightslategrey lightsteelblue lightyellow lime limegreen linen magenta maroon mediumaquamarine mediumblue mediumorchid mediumpurple mediumseagreen mediumslateblue mediumspringgreen mediumturquoise mediumvioletred midnightblue mintcream mistyrose moccasin navajowhite navy oldlace olive olivedrab orange orangered orchid palegoldenrod palegreen paleturquoise palevioletred papayawhip peachpuff peru pink plum powderblue purple red rosybrown royalblue saddlebrown salmon sandybrown seagreen seashell sienna silver skyblue slateblue slategray slategrey snow springgreen steelblue tan teal thistle tomato turquoise violet wheat white whitesmoke yellow yellowgreen\");\nvar isShorthandProp = _.makePredicate('background font margin border border-top border-right border-bottom border-left border-width border-color border-style transition padding list-style border-radius.');\n\nvar isMcssAtKeyword = _.makePredicate('mixin extend var');\nvar isMcssFutureAtKeyword = _.makePredicate('if else css for');\nvar isCssAtKeyword = _.makePredicate('import page keyframe media font-face charset');\n\nvar Parser = function () {\n    function Parser() {\n        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n        _classCallCheck(this, Parser);\n\n        this.options = options;\n    }\n\n    _createClass(Parser, [{\n        key: 'parse',\n        value: function parse(tokens) {\n            // return new Promise((resolve, reject) => {\n            //     // >>>>>> @TODO: 这些要与import 合并 2013/5/12 0:29:42\n\n            // });\n            this._states = {};\n            this.lookahead = tokens;\n            this.p = 0;\n            this.length = this.lookahead.length;\n            this.marked = null;\n            var ast = this.stylesheet();\n            return ast;\n        }\n\n        // store intermedia state\n\n    }, {\n        key: 'state',\n        value: function state(_state) {\n            return this._states[_state] === true;\n        }\n\n        // enter some state\n\n    }, {\n        key: 'enter',\n        value: function enter(state) {\n            this._states[state] = true;\n        }\n\n        // enter some state\n\n    }, {\n        key: 'leave',\n        value: function leave(state) {\n            this._states[state] = false;\n        }\n    }, {\n        key: 'lookUpBefore',\n        value: function lookUpBefore(lookup, before) {\n            var i = 1,\n                la = void 0;\n            while (i++) {\n                if ((la = this.la(i)) === lookup) return true;\n                if (la === before || la === 'EOF' || la === '}') return false;\n            }\n            return false;\n        }\n\n        // Temporarily set to ll(3) parser,\n\n    }, {\n        key: 'll',\n        value: function ll() {\n            var k = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];\n\n            if (k < 0) k++;\n            var pos = this.p + k - 1;\n            if (pos > this.length - 1) pos = this.length - 1;\n            // return this.lookahead[(this.p + k - 1) % 3];\n            return this.lookahead[pos];\n        }\n\n        // read the next token\n        // @TODO return to token stream!\n\n    }, {\n        key: 'next',\n        value: function next() {\n            var k = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];\n\n            this.p += k;\n        }\n\n        // expect\n        // some times we need to ignored some lookahead , etc. NEWLINE\n        //\n        // while to eat ';'\n        // 1. eat ;\n        // 2. eat newLine;\n\n    }, {\n        key: 'eat',\n        value: function eat() {\n            var token = this.ll();\n\n            for (var _len = arguments.length, types = Array(_len), _key = 0; _key < _len; _key++) {\n                types[_key] = arguments[_key];\n            }\n\n            for (var i = 0; i < types.length; i++) {\n                if (token.type === types[i]) {\n                    this.next();\n                    return token;\n                }\n            }\n        }\n    }, {\n        key: 'match',\n        value: function match() {\n            var token = this.eat.apply(this, arguments);\n            if (!token) {\n                // >>>>>> ?为什么\n                token = this.ll();\n                this.error('expect: \"' + (arguments.length <= 0 ? undefined : arguments[0]) + '\" -> got: \"' + token.type + '\"', token.lineno);\n            } else return token;\n        }\n\n        //\n\n    }, {\n        key: 'skip',\n        value: function skip(type) {\n            var skiped = false;\n            while (true) {\n                var token = this.ll();\n                if (typeof type === 'string' ? type === token.type : type(token.type)) {\n                    this.next();\n                    skiped = true;\n                } else break;\n            }\n            return skiped;\n        }\n    }, {\n        key: 'skipStart',\n        value: function skipStart() {\n            return this.skip(isSkipStart);\n        }\n    }, {\n        key: 'skipWSOrNewline',\n        value: function skipWSOrNewline() {\n            return this.skip(isWSOrNewLine);\n        }\n\n        // type at pos is some type\n\n    }, {\n        key: 'is',\n        value: function is(pos, type) {\n            return this.ll(pos).type === type;\n        }\n\n        // 简单版本 只允许mark一次\n\n    }, {\n        key: 'mark',\n        value: function mark() {\n            this.marked = this.p;\n            return this;\n        }\n    }, {\n        key: 'restore',\n        value: function restore() {\n            // if(this.marked != undefined) this.p = this.marked;\n            // this.marked = null;\n            if (this.marked != null) {\n                this.p = this.marked;\n                this.marked = null;\n            }\n            return this;\n        }\n\n        // parse Function\n        // ===================\n\n        // stylesheet(topLevel)\n        //  : WS      {skipWhiteSpace}\n        //  | stmt EOF\n        //  ;\n        //\n\n    }, {\n        key: 'stylesheet',\n        value: function stylesheet() {\n            return this.block(true);\n        }\n\n        // statement\n        // stmt\n        //  : ruleset\n        //  | atrule\n        //  ;\n\n    }, {\n        key: 'stmt',\n        value: function stmt() {\n            var node = null;\n            var token = this.ll();\n            if (token.type === 'AT_KEYWORD') node = this.atrule();else if (token.type === 'VAR') {\n                switch (this.ll(2).type) {\n                    case '(':\n                        node = this.fnCall();\n                        this.matchSemiColonIfNoBlock();\n                        break;\n                    case ':':\n                        node = this.transparentCall();\n                        this.matchSemiColonIfNoBlock();\n                        break;\n                    case '=':\n                    case '?=':\n                    case '^=':\n                        node = this.assign();\n                        if (node.value.type !== 'func') this.matchSemiColonIfNoBlock();\n                        break;\n                    default:\n                        this.error('UNEXPECT token after VARIABLE', this.ll(2));\n                }\n            } else if (token.type === 'FUNCTION') {\n                node = this.fnCall();\n                this.matchSemiColonIfNoBlock();\n            } else if (isSelectorSep(token.type)) node = this.ruleset(true);\n\n            if (node) return node;else this.error('INVALID statementstart ' + token.type, token);\n        }\n\n        // atrule\n        //  : css-atrule(@import, @charset...)\n        //  : bi-atrule(@if, @else, @mixin...)\n        //  : directive\n        //  ;\n\n    }, {\n        key: 'atrule',\n        value: function atrule() {\n            var node = null;\n            var fullname = this.ll().value.toLowerCase();\n            var name = this._removePrefix(fullname);\n            if (typeof this[name] === 'function') node = this[name]();else node = this.directive();\n            node.fullname = fullname;\n            return node;\n        }\n\n        // >>>>>> 待补充\n        // 天然支持document、charset等等\n\n    }, {\n        key: 'directive',\n        value: function (_directive) {\n            function directive() {\n                return _directive.apply(this, arguments);\n            }\n\n            directive.toString = function () {\n                return _directive.toString();\n            };\n\n            return directive;\n        }(function () {\n            var token = this.ll();\n            var name = token.value.toLowerCase();\n            var dhook = directive.getDirective(name);\n            if (dhook) {\n                // this.error('undefined atrule: \"' + this.ll().value + '\"')\n                //@TODO add customer syntax\n                console.log('has hook');\n            } else {\n                this.match('AT_KEYWORD');\n                this.eat('WS');\n                var value = this.valuesList();\n                this.eat('WS');\n                if (this.eat(';')) {\n                    return tree.directive(name, value);\n                } else {\n                    var block = this.block();\n                    return tree.directive(name, value, block);\n                }\n                this.error('invalid customer directive define', ll);\n            }\n        })\n\n        /**\n         * @param  {Boolean} has '{}'\n         * @return {[type]}           [description]\n         */\n\n    }, {\n        key: 'block',\n        value: function block(noBlock) {\n            var node = new tree.Block();\n            this.eat('WS');\n            if (!noBlock) this.match('{');\n            var end = noBlock ? 'EOF' : '}';\n            this.skip('WS');\n            while (!this.eat(end)) {\n                var child = void 0;\n                if (noBlock) child = this.stmt();else child = this.mark().declaration() || this.restore().stmt();\n                node.list.push(child);\n                this.skipStart();\n            }\n            return node;\n        }\n\n        // ruleset\n        //  : selectorlist '{' rule ((NewLine|;) rule)* '}'\n\n    }, {\n        key: 'ruleset',\n        value: function ruleset() {\n            var node = new tree.RuleSet();\n            // 1. 是Selector Sep 2\n            // 2. 在是IDENT(Selector Sep之一)时后续不接: 代表不是declaration //  &&(la !== 'IDENT'|| this.la(2) !== ':'\n            // @changelog: 2 remove 这不需要\n            node.selector = this.selectorList();\n            this.eat('WS');\n            node.block = this.block();\n            return node;\n        }\n\n        // selectorList\n        //  : complexSelector (, complexSelector)*\n        //  ;\n\n    }, {\n        key: 'selectorList',\n        value: function selectorList() {\n            var node = new tree.SelectorList();\n            do {\n                node.list.push(this.selector());\n            } while (this.eat(','));\n            node.lineno = node.list[0].lineno;\n            return node;\n        }\n\n        // 简化处理，允许id、class、type插值\n\n    }, {\n        key: 'selector',\n        value: function selector() {\n            var node = new tree.Selector();\n            var selectorString = '';\n            var token = void 0;\n            var i = 0;\n            while (true) {\n                token = this.ll();\n                if (token.type === '#{' && this.ll(2).type !== '}') {\n                    var interpolation = this.interpolation();\n                    if (interpolation) {\n                        selectorString += '#{' + i++ + '}';\n                        node.interpolations.push(interpolation);\n                    } else break;\n                } else if (isSelectorSep(token.type)) {\n                    // >>>>>> 可以优化\n                    var value = token.type === 'DIMENSION' ? tree.toStr(token) : token.value || (token.type === 'WS' ? ' ' : token.type);\n                    selectorString += value;\n                    this.next();\n                } else break;\n            }\n            node.string = selectorString;\n            node.lineno = token.lineno;\n            return node;\n        }\n    }, {\n        key: 'declaration',\n        value: function declaration(noEnd) {\n            var node = new tree.Declaration();\n            var token1 = this.ll(1),\n                token2 = this.ll(2);\n            if (token1.type === '*' && token2.type === 'TEXT') {\n                this.next(1);\n                token2.value = '*' + token2.value;\n            }\n            // >>>>>>\n            node.property = this.compoundIdent();\n            // don't start with tag or don't ll(2) !== ':'\n            if (!node.property) return;\n            this.eat('WS');\n            if (!this.eat(':')) return;\n\n            // filter_declaration在IE下是支持一些不规则的语法\n            if (node.property.value && /filter$/.test(node.property.value.toLowerCase())) this.enter(STATES.FILTER_DECLARATION);\n            this.enter(STATES.TRY_DECLARATION);\n\n            try {\n                node.value = this.valuesList();\n                this.leave(STATES.TRY_DECLARATION);\n            } catch (error) {\n                this.leave(STATES.TRY_DECLARATION);\n                if (error.code === errors.DECLARION_FAIL) return;else throw error;\n            }\n\n            if (this.eat('IMPORTANT')) node.important = true;\n            if (!noEnd) this.matchSemiColonIfNoBlock();\n            this.leave(STATES.FILTER_DECLARATION);\n            return node;\n        }\n    }, {\n        key: 'assign',\n        value: function assign() {\n            var token = this.ll();\n            this.match('VAR');\n            var op = this.match('=', '?=', '^=').type;\n            var value = this.assignExpr(true);\n            //@FIXIT conflict with parenExpr\n            return new tree.Assign(token.value, value, ASSIGNS[op] || 1);\n        }\n\n        /**function();\n         * can be assign expression\n         * function | valueslist | values\n         * @param  {Boolean} hasComma whether has comma in the expression\n         * @return {mixin}\n         */\n\n    }, {\n        key: 'assignExpr',\n        value: function assignExpr(hasComma) {\n            var node = null;\n            var token = this.ll();\n            var fn = hasComma ? 'valuesList' : 'values';\n            if (token.type === '{') // 可能是parenExpr 也可能是function\n                return this.func();else if (token.type === '(') {\n                this.mark();\n                try {\n                    return this.func();\n                } catch (e) {\n                    if (e.expect && e.expect == '{' || e.expect == 'VAR' || e.expect == ')') {\n                        this.restore();\n                        return this[fn]();\n                    } else {\n                        throw e;\n                    }\n                }\n            } else {\n                return this[fn]();\n            }\n        }\n\n        // 1px 1px #fff, 1px 1px #fff ...\n        // comma separated values\n        // valuesList\n\n    }, {\n        key: 'valuesList',\n        value: function valuesList() {\n            var list = [];\n            do {\n                var values = this.values();\n                if (values) list.push(values);else break;\n            } while (this.eat(','));\n\n            if (list.length === 1) return list[0];else return new tree.ValuesList(list);\n        }\n        // component Values\n\n    }, {\n        key: 'values',\n        value: function values() {\n            var list = [];\n            while (true) {\n                var value = this.expression();\n                if (value) list.push(value);else break;\n            }\n\n            if (list.length === 0) return null;else if (list.length === 1) return list[0];else return new tree.Values(list);\n        }\n    }, {\n        key: 'expression',\n        value: function expression() {\n            this.eat('WS');\n            return this.logicOrExpr();\n        }\n\n        // ||\n\n    }, {\n        key: 'logicOrExpr',\n        value: function logicOrExpr() {\n            var left = this.logicAndExpr(),\n                right = void 0;\n            var token = void 0;\n            while ((token = this.ll()).type === '||') {\n                this.next();\n                right = this.logicAndExpr();\n                if (!right) this.error(token.type + ' require right operand', left);\n\n                var bValue = tree.toBoolean(left);\n                if (bValue !== null) {\n                    if (bValue === false) left = right;\n                } else left = new tree.Operator(token.type, left, right);\n                this.eat('WS');\n            }\n            return left;\n        }\n\n        // &&\n\n    }, {\n        key: 'logicAndExpr',\n        value: function logicAndExpr() {\n            var node = this.relationExpr(),\n                right = void 0;\n            var token = void 0;\n            while ((token = this.ll()).type === '&&') {\n                this.next();\n                right = this.relationExpr();\n                if (!right) this.error(token.type + ' require right operand', node);\n\n                var bValue = tree.toBoolean(node);\n                if (bValue != null) {\n                    if (bValue === true) node = right;\n                } else node = new tree.Operator(token.type, node, right);\n                this.eat('WS');\n            }\n            return node;\n        }\n\n        // ==\n        // !=\n        // >=\n        // <=\n        // >\n        // <\n\n    }, {\n        key: 'relationExpr',\n        value: function relationExpr() {\n            var left = this.binop1(),\n                right = void 0;\n            var token = void 0;\n            while (isRelationOp(token = this.ll().type)) {\n                this.next();\n                this.eat('WS');\n                right = this.binop1();\n                if (!right) this.error(token.type + ' require right operand', left);\n\n                if (tree.isPrimary(left.type) && tree.isPrimary(right.type)) left = binop.relation.call(this, left, right, token.type);else left = new tree.Operator(token.type, left, right);\n                this.eat('WS');\n            }\n            return left;\n        }\n\n        // + -\n\n    }, {\n        key: 'binop1',\n        value: function binop1() {\n            var left = this.binop2(),\n                right = void 0;\n            var token = void 0;\n            this.eat('WS');\n            while ((token = this.ll()).type === '+' || token.type === '-') {\n                this.next();\n                this.eat('WS');\n                right = this.binop2();\n                if (!right) this.error(la + ' require right operand', left);\n\n                if (right.type === 'DIMENSION' && left.type === 'DIMENSION') left = binop[token.type].call(this, left, right);else left = new tree.Operator(token.type, left, right);\n                this.eat('WS');\n            }\n            return left;\n        }\n\n        // * / % ... (@TODO 将range与binop2结合, 即同一优先级)\n\n    }, {\n        key: 'binop2',\n        value: function binop2() {\n            var left = this.unary(),\n                right = void 0;\n            var ws = !!this.eat('WS');\n\n            var token = this.ll();\n            // >>>>>>\n            if (token.type === '...') {\n                this.next();\n                this.eat('WS');\n                right = this.unary();\n                return tree.range(left, right, left.lineno);\n            }\n            while (token.type === '*' || token.type === '/' || token.type === '%') {\n                // 即一个空格也没有\n                if (token.type == '/' && !ws && this.ll(2).type !== 'WS') return left;\n                this.next();\n                this.eat('WS');\n                right = this.unary();\n                if (!right) this.error(token.type + ' require right operand', left);\n\n                if (right.type === 'DIMENSION' && left.type === 'DIMENSION') left = binop[token.type].call(this, left, right);else left = new tree.Operator(token.type, left, right);\n                this.eat('WS');\n                token = this.ll();\n            }\n            return left;\n        }\n\n        // range: function(){\n        //     var left = this.ll(),\n        //         node = new tree.ValuesList(),\n        //         right, lc, rc, reverse;\n        //     this.match('DIMENSION')\n        //     this.eat('...');\n        //     right = this.ll();\n        //     this.match(left.type);\n        //     lc = left.value;\n        //     rc = right.value;\n        //     reverse = lc > rc;\n\n        //     for(; lc != rc ;){\n        //         node.list.push({\n        //             type: left.type,\n        //             value: lc\n        //         })\n        //         if(reverse)  lc -= 1\n        //         else lc += 1\n        //     }\n        //     node.list.push({\n        //         type: left.type,\n        //         value: lc\n        //     })\n        //     return node;\n        // },\n\n        // 一元数\n        // @TODO : 加入 ！一元数\n\n    }, {\n        key: 'unary',\n        value: function unary() {\n            var token = this.ll();\n            if (token.type === '-' || token.type === '+' || token.type === '!') {\n                this.next();\n                this.eat('WS');\n                var value = this.unary();\n                var node = new tree.Unary(value, token.type);\n                node.lineno = token.lineno;\n                return node;\n            } else return this.primary();\n        }\n\n        // primary\n        //  : Ident\n        //  : Dimension\n        //  : function\n        //  : Var\n\n    }, {\n        key: 'primary',\n        value: function primary() {\n            var node = null;\n            var token = this.ll();\n            switch (token.type) {\n                case '(':\n                    return this.parenExpr();\n                case '=':\n                    // filter: alpha(xx=80, xx=xx, ddd=xx)\n                    if (this.state(STATES.FILTER_DECLARATION) && this.state(STATES.FUNCTION_CALL)) {\n                        this.next();\n                        return token;\n                    }\n                    break;\n                case '/':\n                    this.next();\n                    return token;\n                case '-':\n                    var token2 = this.ll(2);\n                    if (token2.type === 'TEXT' || token2.type === '#{') return this.compoundIdent();\n                case '#{':\n                case 'TEXT':\n                    return this.compoundIdent();\n                case 'FUNCTION':\n                    return this.fnCall();\n                case 'HASH':\n                    this.next();\n                    var value = token.value;\n                    if (/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(value)) {\n                        node = new tree.Color(value);\n                        node.lineno = token.lineno;\n                    } else node = new tree.Unknown(token.value);\n                    return node;\n                // TODO 插值\n                case 'STRING':\n                case 'DIMENSION':\n                case 'BOOLEAN':\n                case 'VAR':\n                case 'NULL':\n                case 'URL':\n                    this.next();\n                    return token;\n                case '>':\n                case '~':\n                case '+':\n                case '.':\n                case '#':\n                case '&':\n                case '{':\n                case ':':\n                case '*':\n                case 'PSEUDO_CLASS':\n                case 'CLASS':\n                case 'ATTRIBUTE':\n                    if (this.state(STATES.TRY_DECLARATION)) {\n                        this.error(errors.DECLARION_FAIL);\n                        break;\n                    }\n                default:\n                    return null;\n            }\n        }\n\n        //  : '#{' values '}'\n\n    }, {\n        key: 'interpolation',\n        value: function interpolation() {\n            this.match('#{');\n            var node = this.valuesList();\n            this.match('}');\n            return node;\n        }\n\n        // parenExpr\n        //  : '(' expresion ')'\n\n    }, {\n        key: 'parenExpr',\n        value: function parenExpr() {\n            this.match('(');\n            this.eat('WS');\n            var node = this.valuesList();\n            node.lineno = this.ll().lineno;\n            this.eat('WS');\n            this.match(')');\n            return node;\n        }\n\n        // compoundIdent 组合Ident\n        //  : (interpolation | TEXT) +\n\n    }, {\n        key: 'compoundIdent',\n        value: function compoundIdent() {\n            var node = void 0;\n            var list = [];\n            var token = void 0;\n            var sep = void 0;\n            while (true) {\n                token = this.ll();\n                if (token.type === '#{') {\n                    sep = this.interpolation();\n                    list.push(sep);\n                } else if (token.type === 'TEXT' || token.type === '-') {\n                    this.next();\n                    list.push(token.value || token.type);\n                } else break;\n            }\n            if (!sep) {\n                if (!list.length) return null;else return { type: 'TEXT', value: list[0], lineno: token.lineno };\n            } else {\n                node = new tree.CompoundIdent(list);\n                node.lineno = token.lineno;\n                return node;\n            }\n        }\n\n        // fnCall\n        //  : CALL FUNCTION '('  expresion * ')'\n\n    }, {\n        key: 'fnCall',\n        value: function fnCall() {\n            var token = this.ll();\n            this.match('FUNCTION', 'VAR');\n            if (token.args) return new tree.Call(token.value, token.args, null, token.lineno);\n            this.eat('WS');\n            this.match('(');\n            this.enter(STATES.FUNCTION_CALL);\n            this.eat('WS');\n            var pargs = this.ll().type !== ')' ? this.args() : { args: [] };\n            this.leave(states.FUNCTION_CALL);\n            this.match(')');\n            return new tree.Call(token.value, pargs.args, pargs.named, token.lineno);\n        }\n\n        //@TODO start named arguments\n\n    }, {\n        key: 'args',\n        value: function args(end) {\n            var token = void 0;\n            var named = null;\n            var args = [];\n            var i = 0;\n            do {\n                token = this.ll();\n                if (token.type === 'VAR' && this.ll(2).type === '=') {\n                    this.next(2);\n                    if (!named) named = {};\n                    named[token.value] = i;\n                }\n                args.push(this.assignExpr());\n                this.skip('WS');\n                i++;\n            } while (this.eat(','));\n\n            return { args: args, named: named };\n        }\n\n        // stylus inspired feature;\n\n    }, {\n        key: 'transparentCall',\n        value: function transparentCall() {\n            var token = this.ll();\n            this.match('VAR');\n            this.match(':');\n            this.eat('WS');\n            var pargs = this.args();\n            // if(args.type === 'values'){\n            //     args = new tree.ValuesList(args.list);\n            // }\n\n            // if(args.type !== 'valueslist') args = [args];\n            // else args = args.list;\n            return tree.Call(token.value, pargs.args, pargs.named, token.lineno);\n        }\n\n        /**\n         * remove at-rule prefix\n         */\n\n    }, {\n        key: '_removePrefix',\n        value: function _removePrefix(str) {\n            return str.replace(/^-\\w+-/, '');\n        }\n    }, {\n        key: 'matchSemiColonIfNoBlock',\n        value: function matchSemiColonIfNoBlock() {\n            this.eat('WS');\n            if (this.ll().type !== '}') this.match(';');\n        }\n    }]);\n\n    return Parser;\n}();\n\nexports.default = Parser;//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFyc2VyLmpzPzI2MTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7SUFBWSxDOztBQUNaOztJQUFZLEk7Ozs7OztBQUVaLElBQU0sU0FBUzs7QUFFWCx3QkFBb0IsUUFGVDs7QUFJWCxxQkFBaUIsUUFKTjtBQUtYLHVCQUFtQixRQUxSOztBQU9YLG1CQUFlO0FBUEosQ0FBZjtBQVNBLElBQU0sVUFBVSxFQUFDLEtBQUssQ0FBTixFQUFTLE1BQU0sQ0FBZixFQUFrQixNQUFNLENBQXhCLEVBQWhCO0FBQ0EsSUFBTSxTQUFTLFVBQWY7O0FBRUEsSUFBSSxjQUFjLEVBQUUsYUFBRixDQUFnQixzQkFBaEIsQ0FBbEI7QUFDQSxJQUFJLGdCQUFnQixFQUFFLGFBQUYsQ0FBZ0IsWUFBaEIsQ0FBcEI7QUFDQSxJQUFJLFVBQVUsRUFBRSxhQUFGLENBQWdCLE1BQWhCLENBQWQ7OztBQUdBLElBQUksZ0JBQWdCLEVBQUUsYUFBRixDQUFnQixhQUFhLGdHQUE3QixDQUFwQjs7QUFFQSxJQUFJLGFBQWEsRUFBRSxhQUFGLENBQWdCLFNBQWhCLENBQWpCO0FBQ0EsSUFBSSxlQUFlLEVBQUUsYUFBRixDQUFnQixpQkFBaEIsQ0FBbkI7QUFDQSxJQUFJLGlCQUFpQixFQUFFLGFBQUYsQ0FBZ0IsS0FBaEIsQ0FBckI7QUFDQSxJQUFJLGtCQUFrQixFQUFFLGFBQUYsQ0FBZ0Isb0NBQWhCLENBQXRCOztBQUVBLElBQUksVUFBVSxFQUFFLGFBQUYsQ0FBZ0IsaTdDQUFoQixDQUFkO0FBQ0EsSUFBSSxrQkFBa0IsRUFBRSxhQUFGLENBQWdCLHFLQUFoQixDQUF0Qjs7QUFFQSxJQUFJLGtCQUFrQixFQUFFLGFBQUYsQ0FBZ0Isa0JBQWhCLENBQXRCO0FBQ0EsSUFBSSx3QkFBd0IsRUFBRSxhQUFGLENBQWdCLGlCQUFoQixDQUE1QjtBQUNBLElBQUksaUJBQWlCLEVBQUUsYUFBRixDQUFnQiw4Q0FBaEIsQ0FBckI7O0lBS00s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QUFVLElBQVY7QUFDQTtBQUNILGFBVkQsUUFVUSxLQUFLLEdBQUwsQ0FBUyxHQUFULENBVlI7O0FBWUEsbUJBQU8sRUFBQyxVQUFELEVBQU8sWUFBUCxFQUFQO0FBQ0g7Ozs7OzswQ0FHaUI7QUFDZCxnQkFBSSxRQUFRLEtBQUssRUFBTCxFQUFaO0FBQ0EsaUJBQUssS0FBTCxDQUFXLEtBQVg7QUFDQSxpQkFBSyxLQUFMLENBQVcsR0FBWDtBQUNBLGlCQUFLLEdBQUwsQ0FBUyxJQUFUO0FBQ0EsZ0JBQUksUUFBUSxLQUFLLElBQUwsRUFBWjs7Ozs7OztBQU9BLG1CQUFPLEtBQUssSUFBTCxDQUFVLE1BQU0sS0FBaEIsRUFBdUIsTUFBTSxJQUE3QixFQUFtQyxNQUFNLEtBQXpDLEVBQWdELE1BQU0sTUFBdEQsQ0FBUDtBQUNIOzs7Ozs7OztzQ0FLYSxHLEVBQUs7QUFDZixtQkFBTyxJQUFJLE9BQUosQ0FBWSxRQUFaLEVBQXNCLEVBQXRCLENBQVA7QUFDSDs7O2tEQUV5QjtBQUN0QixpQkFBSyxHQUFMLENBQVMsSUFBVDtBQUNBLGdCQUFHLEtBQUssRUFBTCxHQUFVLElBQVYsS0FBbUIsR0FBdEIsRUFDSSxLQUFLLEtBQUwsQ0FBVyxHQUFYO0FBQ1A7Ozs7OztrQkFHVSxNIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBfIGZyb20gJy4vaGVscGVyL3V0aWwuanMnO1xuaW1wb3J0ICogYXMgdHJlZSBmcm9tICcuL3RyZWUnO1xuXG5jb25zdCBTVEFURVMgPSB7XG4gICAgLy8g6L+b5YWlZmlsdGVyXG4gICAgRklMVEVSX0RFQ0xBUkFUSU9OOiBTeW1ib2woKSxcbiAgICAvLyDlpLHotKXliJnov5vlhaVSdWxlc2V0XG4gICAgVFJZX0RFQ0xBUkFUSU9OOiBTeW1ib2woKSxcbiAgICBUUllfSU5URVJQT0xBVElPTjogU3ltYm9sKCksXG4gICAgLy8g5b2T6YGH5Yiw54m55q6K5bGe5oCn5pe2XG4gICAgRlVOQ1RJT05fQ0FMTDogU3ltYm9sKClcbn07XG5jb25zdCBBU1NJR05TID0geyc9JzogMSwgJz89JzogMiwgJ149JzogM307XG5jb25zdCBDT01CT1MgPSAnV1MgPiB+ICsnO1xuXG5sZXQgaXNTa2lwU3RhcnQgPSBfLm1ha2VQcmVkaWNhdGUoJ1dTIE5FV0xJTkUgQ09NTUVOVCA7Jyk7XG5sZXQgaXNXU09yTmV3TGluZSA9IF8ubWFrZVByZWRpY2F0ZSgnV1MgTkVXTElORScpO1xubGV0IGlzQ29tYm8gPSBfLm1ha2VQcmVkaWNhdGUoQ09NQk9TKTtcblxuLy8gcHJvYmFibHkgc2VsZWN0b3Igc2VnbWVudFxubGV0IGlzU2VsZWN0b3JTZXAgPSBfLm1ha2VQcmVkaWNhdGUoJ1dTID4gfiArJyArICdQU0VVRE9fQ0xBU1MgUFNFVURPX0VMRU1FTlQgQVRUUklCVVRFIENMQVNTIEhBU0ggJiBURVhUICogIyAjeyA6IC4gJSAtIGNvbXBvdW5kaWRlbnQgRElNRU5TSU9OJyk7XG5cbmxldCBpc09wZXJhdG9yID0gXy5tYWtlUHJlZGljYXRlKCcrIC0gKiAvJyk7XG5sZXQgaXNSZWxhdGlvbk9wID0gXy5tYWtlUHJlZGljYXRlKCc9PSA+PSA8PSA8ID4gIT0nKTtcbmxldCBpc0NvbW1hT3JQYXJlbiA9IF8ubWFrZVByZWRpY2F0ZSgnLCApJyk7XG5sZXQgaXNEaXJlY3RPcGVyYXRlID0gXy5tYWtlUHJlZGljYXRlKCdESU1FTlNJT04gU1RSSU5HIEJPT0xFQU4gVEVYVCBOVUxMJyk7XG5cbmxldCBpc0NvbG9yID0gXy5tYWtlUHJlZGljYXRlKFwiYWxpY2VibHVlIGFudGlxdWV3aGl0ZSBhcXVhIGFxdWFtYXJpbmUgYXp1cmUgYmVpZ2UgYmlzcXVlIGJsYWNrIGJsYW5jaGVkYWxtb25kIGJsdWUgYmx1ZXZpb2xldCBicm93biBidXJseXdvb2QgY2FkZXRibHVlIGNoYXJ0cmV1c2UgY2hvY29sYXRlIGNvcmFsIGNvcm5mbG93ZXJibHVlIGNvcm5zaWxrIGNyaW1zb24gY3lhbiBkYXJrYmx1ZSBkYXJrY3lhbiBkYXJrZ29sZGVucm9kIGRhcmtncmF5IGRhcmtncmV5IGRhcmtncmVlbiBkYXJra2hha2kgZGFya21hZ2VudGEgZGFya29saXZlZ3JlZW4gZGFya29yYW5nZSBkYXJrb3JjaGlkIGRhcmtyZWQgZGFya3NhbG1vbiBkYXJrc2VhZ3JlZW4gZGFya3NsYXRlYmx1ZSBkYXJrc2xhdGVncmF5IGRhcmtzbGF0ZWdyZXkgZGFya3R1cnF1b2lzZSBkYXJrdmlvbGV0IGRlZXBwaW5rIGRlZXBza3libHVlIGRpbWdyYXkgZGltZ3JleSBkb2RnZXJibHVlIGZpcmVicmljayBmbG9yYWx3aGl0ZSBmb3Jlc3RncmVlbiBmdWNoc2lhIGdhaW5zYm9ybyBnaG9zdHdoaXRlIGdvbGQgZ29sZGVucm9kIGdyYXkgZ3JleSBncmVlbiBncmVlbnllbGxvdyBob25leWRldyBob3RwaW5rIGluZGlhbnJlZCBpbmRpZ28gaXZvcnkga2hha2kgbGF2ZW5kZXIgbGF2ZW5kZXJibHVzaCBsYXduZ3JlZW4gbGVtb25jaGlmZm9uIGxpZ2h0Ymx1ZSBsaWdodGNvcmFsIGxpZ2h0Y3lhbiBsaWdodGdvbGRlbnJvZHllbGxvdyBsaWdodGdyYXkgbGlnaHRncmV5IGxpZ2h0Z3JlZW4gbGlnaHRwaW5rIGxpZ2h0c2FsbW9uIGxpZ2h0c2VhZ3JlZW4gbGlnaHRza3libHVlIGxpZ2h0c2xhdGVncmF5IGxpZ2h0c2xhdGVncmV5IGxpZ2h0c3RlZWxibHVlIGxpZ2h0eWVsbG93IGxpbWUgbGltZWdyZWVuIGxpbmVuIG1hZ2VudGEgbWFyb29uIG1lZGl1bWFxdWFtYXJpbmUgbWVkaXVtYmx1ZSBtZWRpdW1vcmNoaWQgbWVkaXVtcHVycGxlIG1lZGl1bXNlYWdyZWVuIG1lZGl1bXNsYXRlYmx1ZSBtZWRpdW1zcHJpbmdncmVlbiBtZWRpdW10dXJxdW9pc2UgbWVkaXVtdmlvbGV0cmVkIG1pZG5pZ2h0Ymx1ZSBtaW50Y3JlYW0gbWlzdHlyb3NlIG1vY2Nhc2luIG5hdmFqb3doaXRlIG5hdnkgb2xkbGFjZSBvbGl2ZSBvbGl2ZWRyYWIgb3JhbmdlIG9yYW5nZXJlZCBvcmNoaWQgcGFsZWdvbGRlbnJvZCBwYWxlZ3JlZW4gcGFsZXR1cnF1b2lzZSBwYWxldmlvbGV0cmVkIHBhcGF5YXdoaXAgcGVhY2hwdWZmIHBlcnUgcGluayBwbHVtIHBvd2RlcmJsdWUgcHVycGxlIHJlZCByb3N5YnJvd24gcm95YWxibHVlIHNhZGRsZWJyb3duIHNhbG1vbiBzYW5keWJyb3duIHNlYWdyZWVuIHNlYXNoZWxsIHNpZW5uYSBzaWx2ZXIgc2t5Ymx1ZSBzbGF0ZWJsdWUgc2xhdGVncmF5IHNsYXRlZ3JleSBzbm93IHNwcmluZ2dyZWVuIHN0ZWVsYmx1ZSB0YW4gdGVhbCB0aGlzdGxlIHRvbWF0byB0dXJxdW9pc2UgdmlvbGV0IHdoZWF0IHdoaXRlIHdoaXRlc21va2UgeWVsbG93IHllbGxvd2dyZWVuXCIpXG5sZXQgaXNTaG9ydGhhbmRQcm9wID0gXy5tYWtlUHJlZGljYXRlKCdiYWNrZ3JvdW5kIGZvbnQgbWFyZ2luIGJvcmRlciBib3JkZXItdG9wIGJvcmRlci1yaWdodCBib3JkZXItYm90dG9tIGJvcmRlci1sZWZ0IGJvcmRlci13aWR0aCBib3JkZXItY29sb3IgYm9yZGVyLXN0eWxlIHRyYW5zaXRpb24gcGFkZGluZyBsaXN0LXN0eWxlIGJvcmRlci1yYWRpdXMuJylcblxubGV0IGlzTWNzc0F0S2V5d29yZCA9IF8ubWFrZVByZWRpY2F0ZSgnbWl4aW4gZXh0ZW5kIHZhcicpO1xubGV0IGlzTWNzc0Z1dHVyZUF0S2V5d29yZCA9IF8ubWFrZVByZWRpY2F0ZSgnaWYgZWxzZSBjc3MgZm9yJyk7XG5sZXQgaXNDc3NBdEtleXdvcmQgPSBfLm1ha2VQcmVkaWNhdGUoJ2ltcG9ydCBwYWdlIGtleWZyYW1lIG1lZGlhIGZvbnQtZmFjZSBjaGFyc2V0Jyk7XG5cblxuXG5cbmNsYXNzIFBhcnNlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuXG4gICAgcGFyc2UodG9rZW5zKSB7XG4gICAgICAgIC8vIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIC8vICAgICAvLyA+Pj4+Pj4gQFRPRE86IOi/meS6m+imgeS4jmltcG9ydCDlkIjlubYgMjAxMy81LzEyIDA6Mjk6NDJcblxuICAgICAgICAvLyB9KTtcbiAgICAgICAgdGhpcy5fc3RhdGVzID0ge307XG4gICAgICAgIHRoaXMubG9va2FoZWFkID0gdG9rZW5zO1xuICAgICAgICB0aGlzLnAgPSAwO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMubG9va2FoZWFkLmxlbmd0aDtcbiAgICAgICAgdGhpcy5tYXJrZWQgPSBudWxsO1xuICAgICAgICBsZXQgYXN0ID0gdGhpcy5zdHlsZXNoZWV0KCk7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgfVxuXG4gICAgLy8gc3RvcmUgaW50ZXJtZWRpYSBzdGF0ZVxuICAgIHN0YXRlKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZXNbc3RhdGVdID09PSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGVudGVyIHNvbWUgc3RhdGVcbiAgICBlbnRlcihzdGF0ZSkge1xuICAgICAgICB0aGlzLl9zdGF0ZXNbc3RhdGVdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBlbnRlciBzb21lIHN0YXRlXG4gICAgbGVhdmUoc3RhdGUpIHtcbiAgICAgICAgdGhpcy5fc3RhdGVzW3N0YXRlXSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGxvb2tVcEJlZm9yZShsb29rdXAsIGJlZm9yZSkge1xuICAgICAgICBsZXQgaSA9IDEsIGxhO1xuICAgICAgICB3aGlsZShpKyspIHtcbiAgICAgICAgICAgIGlmKChsYSA9IHRoaXMubGEoaSkpID09PSBsb29rdXApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZihsYSA9PT0gYmVmb3JlIHx8IGxhID09PSAnRU9GJyB8fCBsYSA9PT0gJ30nKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVGVtcG9yYXJpbHkgc2V0IHRvIGxsKDMpIHBhcnNlcixcbiAgICBsbChrID0gMSkge1xuICAgICAgICBpZihrIDwgMClcbiAgICAgICAgICAgIGsrKztcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMucCArIGsgLSAxO1xuICAgICAgICBpZihwb3MgPiB0aGlzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICBwb3MgPSB0aGlzLmxlbmd0aCAtIDE7XG4gICAgICAgIC8vIHJldHVybiB0aGlzLmxvb2thaGVhZFsodGhpcy5wICsgayAtIDEpICUgM107XG4gICAgICAgIHJldHVybiB0aGlzLmxvb2thaGVhZFtwb3NdO1xuICAgIH1cblxuICAgIC8vIHJlYWQgdGhlIG5leHQgdG9rZW5cbiAgICAvLyBAVE9ETyByZXR1cm4gdG8gdG9rZW4gc3RyZWFtIVxuICAgIG5leHQoayA9IDEpIHtcbiAgICAgICAgdGhpcy5wICs9IGs7XG4gICAgfVxuXG4gICAgLy8gZXhwZWN0XG4gICAgLy8gc29tZSB0aW1lcyB3ZSBuZWVkIHRvIGlnbm9yZWQgc29tZSBsb29rYWhlYWQgLCBldGMuIE5FV0xJTkVcbiAgICAvL1xuICAgIC8vIHdoaWxlIHRvIGVhdCAnOydcbiAgICAvLyAxLiBlYXQgO1xuICAgIC8vIDIuIGVhdCBuZXdMaW5lO1xuICAgIGVhdCguLi50eXBlcykge1xuICAgICAgICBsZXQgdG9rZW4gPSB0aGlzLmxsKCk7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYodG9rZW4udHlwZSA9PT0gdHlwZXNbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBtYXRjaCguLi50eXBlcykge1xuICAgICAgICBsZXQgdG9rZW4gPSB0aGlzLmVhdCguLi50eXBlcyk7XG4gICAgICAgIGlmKCF0b2tlbikge1xuICAgICAgICAgICAgLy8gPj4+Pj4+ID/kuLrku4DkuYhcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy5sbCgpO1xuICAgICAgICAgICAgdGhpcy5lcnJvcignZXhwZWN0OiBcIicgKyB0eXBlc1swXSArICdcIiAtPiBnb3Q6IFwiJyArIHRva2VuLnR5cGUgKyAnXCInLCB0b2tlbi5saW5lbm8pO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG5cbiAgICAvL1xuICAgIHNraXAodHlwZSkge1xuICAgICAgICBsZXQgc2tpcGVkID0gZmFsc2U7XG4gICAgICAgIHdoaWxlKHRydWUpIHtcbiAgICAgICAgICAgIGxldCB0b2tlbiA9IHRoaXMubGwoKTtcbiAgICAgICAgICAgIGlmKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHR5cGUgPT09IHRva2VuLnR5cGUgOiB0eXBlKHRva2VuLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgc2tpcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBza2lwZWQ7XG4gICAgfVxuXG4gICAgc2tpcFN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5za2lwKGlzU2tpcFN0YXJ0KTtcbiAgICB9XG5cbiAgICBza2lwV1NPck5ld2xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNraXAoaXNXU09yTmV3TGluZSk7XG4gICAgfVxuXG5cblxuICAgIC8vIHR5cGUgYXQgcG9zIGlzIHNvbWUgdHlwZVxuICAgIGlzKHBvcywgdHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sbChwb3MpLnR5cGUgPT09IHR5cGU7XG4gICAgfVxuXG4gICAgLy8g566A5Y2V54mI5pysIOWPquWFgeiuuG1hcmvkuIDmrKFcbiAgICBtYXJrKCkge1xuICAgICAgICB0aGlzLm1hcmtlZCA9IHRoaXMucDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmVzdG9yZSgpIHtcbiAgICAgICAgLy8gaWYodGhpcy5tYXJrZWQgIT0gdW5kZWZpbmVkKSB0aGlzLnAgPSB0aGlzLm1hcmtlZDtcbiAgICAgICAgLy8gdGhpcy5tYXJrZWQgPSBudWxsO1xuICAgICAgICBpZih0aGlzLm1hcmtlZCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnAgPSB0aGlzLm1hcmtlZDtcbiAgICAgICAgICAgIHRoaXMubWFya2VkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBwYXJzZSBGdW5jdGlvblxuICAgIC8vID09PT09PT09PT09PT09PT09PT1cblxuICAgIC8vIHN0eWxlc2hlZXQodG9wTGV2ZWwpXG4gICAgLy8gIDogV1MgICAgICB7c2tpcFdoaXRlU3BhY2V9XG4gICAgLy8gIHwgc3RtdCBFT0ZcbiAgICAvLyAgO1xuICAgIC8vXG4gICAgc3R5bGVzaGVldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxvY2sodHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gc3RhdGVtZW50XG4gICAgLy8gc3RtdFxuICAgIC8vICA6IHJ1bGVzZXRcbiAgICAvLyAgfCBhdHJ1bGVcbiAgICAvLyAgO1xuICAgIHN0bXQoKSB7XG4gICAgICAgIGxldCBub2RlID0gbnVsbDtcbiAgICAgICAgbGV0IHRva2VuID0gdGhpcy5sbCgpO1xuICAgICAgICBpZih0b2tlbi50eXBlID09PSAnQVRfS0VZV09SRCcpXG4gICAgICAgICAgICBub2RlID0gdGhpcy5hdHJ1bGUoKTtcbiAgICAgICAgZWxzZSBpZih0b2tlbi50eXBlID09PSAnVkFSJykge1xuICAgICAgICAgICAgc3dpdGNoKHRoaXMubGwoMikudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJygnOlxuICAgICAgICAgICAgICAgICAgICBub2RlID0gdGhpcy5mbkNhbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaFNlbWlDb2xvbklmTm9CbG9jaygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICc6JzpcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHRoaXMudHJhbnNwYXJlbnRDYWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hTZW1pQ29sb25JZk5vQmxvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnPz0nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ149JzpcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHRoaXMuYXNzaWduKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmKG5vZGUudmFsdWUudHlwZSAhPT0gJ2Z1bmMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaFNlbWlDb2xvbklmTm9CbG9jaygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKCdVTkVYUEVDVCB0b2tlbiBhZnRlciBWQVJJQUJMRScsIHRoaXMubGwoMikpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZih0b2tlbi50eXBlID09PSAnRlVOQ1RJT04nKSB7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5mbkNhbGwoKTtcbiAgICAgICAgICAgIHRoaXMubWF0Y2hTZW1pQ29sb25JZk5vQmxvY2soKTtcbiAgICAgICAgfSBlbHNlIGlmKGlzU2VsZWN0b3JTZXAodG9rZW4udHlwZSkpXG4gICAgICAgICAgICBub2RlID0gdGhpcy5ydWxlc2V0KHRydWUpO1xuXG4gICAgICAgIGlmKG5vZGUpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5lcnJvcignSU5WQUxJRCBzdGF0ZW1lbnRzdGFydCAnICsgdG9rZW4udHlwZSwgdG9rZW4pO1xuICAgIH1cblxuICAgIC8vIGF0cnVsZVxuICAgIC8vICA6IGNzcy1hdHJ1bGUoQGltcG9ydCwgQGNoYXJzZXQuLi4pXG4gICAgLy8gIDogYmktYXRydWxlKEBpZiwgQGVsc2UsIEBtaXhpbi4uLilcbiAgICAvLyAgOiBkaXJlY3RpdmVcbiAgICAvLyAgO1xuICAgIGF0cnVsZSgpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBudWxsO1xuICAgICAgICBsZXQgZnVsbG5hbWUgPSB0aGlzLmxsKCkudmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbGV0IG5hbWUgPSB0aGlzLl9yZW1vdmVQcmVmaXgoZnVsbG5hbWUpO1xuICAgICAgICBpZih0eXBlb2YgdGhpc1tuYW1lXSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzW25hbWVdKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLmRpcmVjdGl2ZSgpO1xuICAgICAgICBub2RlLmZ1bGxuYW1lID0gZnVsbG5hbWU7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIC8vID4+Pj4+PiDlvoXooaXlhYVcbiAgICAvLyDlpKnnhLbmlK/mjIFkb2N1bWVudOOAgWNoYXJzZXTnrYnnrYlcbiAgICBkaXJlY3RpdmUoKSB7XG4gICAgICAgIGxldCB0b2tlbiA9IHRoaXMubGwoKTtcbiAgICAgICAgbGV0IG5hbWUgPSB0b2tlbi52YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBsZXQgZGhvb2sgPSBkaXJlY3RpdmUuZ2V0RGlyZWN0aXZlKG5hbWUpO1xuICAgICAgICBpZihkaG9vaykge1xuICAgICAgICAgICAgLy8gdGhpcy5lcnJvcigndW5kZWZpbmVkIGF0cnVsZTogXCInICsgdGhpcy5sbCgpLnZhbHVlICsgJ1wiJylcbiAgICAgICAgICAgIC8vQFRPRE8gYWRkIGN1c3RvbWVyIHN5bnRheFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ2hhcyBob29rJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1hdGNoKCdBVF9LRVlXT1JEJyk7XG4gICAgICAgICAgICB0aGlzLmVhdCgnV1MnKVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZXNMaXN0KCk7XG4gICAgICAgICAgICB0aGlzLmVhdCgnV1MnKTtcbiAgICAgICAgICAgIGlmKHRoaXMuZWF0KCc7JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJlZS5kaXJlY3RpdmUobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSB0aGlzLmJsb2NrKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyZWUuZGlyZWN0aXZlKG5hbWUsIHZhbHVlLCBibG9jayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVycm9yKCdpbnZhbGlkIGN1c3RvbWVyIGRpcmVjdGl2ZSBkZWZpbmUnLCBsbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBoYXMgJ3t9J1xuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICBibG9jayhub0Jsb2NrKSB7XG4gICAgICAgIGxldCBub2RlID0gbmV3IHRyZWUuQmxvY2soKTtcbiAgICAgICAgdGhpcy5lYXQoJ1dTJyk7XG4gICAgICAgIGlmKCFub0Jsb2NrKSB0aGlzLm1hdGNoKCd7Jyk7XG4gICAgICAgIGxldCBlbmQgPSBub0Jsb2NrID8gJ0VPRicgOiAnfSc7XG4gICAgICAgIHRoaXMuc2tpcCgnV1MnKTtcbiAgICAgICAgd2hpbGUoIXRoaXMuZWF0KGVuZCkpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZDtcbiAgICAgICAgICAgIGlmKG5vQmxvY2spXG4gICAgICAgICAgICAgICAgY2hpbGQgPSB0aGlzLnN0bXQoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjaGlsZCA9IHRoaXMubWFyaygpLmRlY2xhcmF0aW9uKCkgfHwgdGhpcy5yZXN0b3JlKCkuc3RtdCgpO1xuICAgICAgICAgICAgbm9kZS5saXN0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgdGhpcy5za2lwU3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICAvLyBydWxlc2V0XG4gICAgLy8gIDogc2VsZWN0b3JsaXN0ICd7JyBydWxlICgoTmV3TGluZXw7KSBydWxlKSogJ30nXG5cbiAgICBydWxlc2V0KCkge1xuICAgICAgICBsZXQgbm9kZSA9IG5ldyB0cmVlLlJ1bGVTZXQoKTtcbiAgICAgICAgLy8gMS4g5pivU2VsZWN0b3IgU2VwIDJcbiAgICAgICAgLy8gMi4g5Zyo5pivSURFTlQoU2VsZWN0b3IgU2Vw5LmL5LiAKeaXtuWQjue7reS4jeaOpTog5Luj6KGo5LiN5pivZGVjbGFyYXRpb24gLy8gICYmKGxhICE9PSAnSURFTlQnfHwgdGhpcy5sYSgyKSAhPT0gJzonXG4gICAgICAgIC8vIEBjaGFuZ2Vsb2c6IDIgcmVtb3ZlIOi/meS4jemcgOimgVxuICAgICAgICBub2RlLnNlbGVjdG9yID0gdGhpcy5zZWxlY3Rvckxpc3QoKTtcbiAgICAgICAgdGhpcy5lYXQoJ1dTJyk7XG4gICAgICAgIG5vZGUuYmxvY2sgPSB0aGlzLmJsb2NrKCk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIC8vIHNlbGVjdG9yTGlzdFxuICAgIC8vICA6IGNvbXBsZXhTZWxlY3RvciAoLCBjb21wbGV4U2VsZWN0b3IpKlxuICAgIC8vICA7XG4gICAgc2VsZWN0b3JMaXN0KCkge1xuICAgICAgICBsZXQgbm9kZSA9IG5ldyB0cmVlLlNlbGVjdG9yTGlzdCgpO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBub2RlLmxpc3QucHVzaCh0aGlzLnNlbGVjdG9yKCkpO1xuICAgICAgICB9IHdoaWxlKHRoaXMuZWF0KCcsJykpO1xuICAgICAgICBub2RlLmxpbmVubyA9IG5vZGUubGlzdFswXS5saW5lbm87XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIC8vIOeugOWMluWkhOeQhu+8jOWFgeiuuGlk44CBY2xhc3PjgIF0eXBl5o+S5YC8XG4gICAgc2VsZWN0b3IoKSB7XG4gICAgICAgIGxldCBub2RlID0gbmV3IHRyZWUuU2VsZWN0b3IoKTtcbiAgICAgICAgbGV0IHNlbGVjdG9yU3RyaW5nID0gJyc7XG4gICAgICAgIGxldCB0b2tlbjtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB3aGlsZSh0cnVlKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMubGwoKTtcbiAgICAgICAgICAgIGlmKHRva2VuLnR5cGUgPT09ICcjeycgJiYgdGhpcy5sbCgyKS50eXBlICE9PSAnfScpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW50ZXJwb2xhdGlvbiA9IHRoaXMuaW50ZXJwb2xhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmKGludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JTdHJpbmcgKz0gJyN7JyArIChpKyspICsgJ30nO1xuICAgICAgICAgICAgICAgICAgICBub2RlLmludGVycG9sYXRpb25zLnB1c2goaW50ZXJwb2xhdGlvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmKGlzU2VsZWN0b3JTZXAodG9rZW4udHlwZSkpIHtcbiAgICAgICAgICAgICAgICAvLyA+Pj4+Pj4g5Y+v5Lul5LyY5YyWXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gdG9rZW4udHlwZSA9PT0gJ0RJTUVOU0lPTicgPyB0cmVlLnRvU3RyKHRva2VuKSA6ICh0b2tlbi52YWx1ZSB8fCAodG9rZW4udHlwZSA9PT0gJ1dTJyA/ICcgJyA6IHRva2VuLnR5cGUpKTtcbiAgICAgICAgICAgICAgICBzZWxlY3RvclN0cmluZyArPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuc3RyaW5nID0gc2VsZWN0b3JTdHJpbmc7XG4gICAgICAgIG5vZGUubGluZW5vID0gdG9rZW4ubGluZW5vO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICBkZWNsYXJhdGlvbihub0VuZCkge1xuICAgICAgICBsZXQgbm9kZSA9IG5ldyB0cmVlLkRlY2xhcmF0aW9uKCk7XG4gICAgICAgIGxldCB0b2tlbjEgPSB0aGlzLmxsKDEpLCB0b2tlbjIgPSB0aGlzLmxsKDIpO1xuICAgICAgICBpZih0b2tlbjEudHlwZSA9PT0gJyonICYmIHRva2VuMi50eXBlID09PSAnVEVYVCcpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgxKTtcbiAgICAgICAgICAgIHRva2VuMi52YWx1ZSA9ICcqJyArIHRva2VuMi52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyA+Pj4+Pj5cbiAgICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMuY29tcG91bmRJZGVudCgpO1xuICAgICAgICAvLyBkb24ndCBzdGFydCB3aXRoIHRhZyBvciBkb24ndCBsbCgyKSAhPT0gJzonXG4gICAgICAgIGlmKCFub2RlLnByb3BlcnR5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmVhdCgnV1MnKTtcbiAgICAgICAgaWYoIXRoaXMuZWF0KCc6JykpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgLy8gZmlsdGVyX2RlY2xhcmF0aW9u5ZyoSUXkuIvmmK/mlK/mjIHkuIDkupvkuI3op4TliJnnmoTor63ms5VcbiAgICAgICAgaWYobm9kZS5wcm9wZXJ0eS52YWx1ZSAmJiAvZmlsdGVyJC8udGVzdChub2RlLnByb3BlcnR5LnZhbHVlLnRvTG93ZXJDYXNlKCkpKVxuICAgICAgICAgICAgdGhpcy5lbnRlcihTVEFURVMuRklMVEVSX0RFQ0xBUkFUSU9OKTtcbiAgICAgICAgdGhpcy5lbnRlcihTVEFURVMuVFJZX0RFQ0xBUkFUSU9OKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IHRoaXMudmFsdWVzTGlzdCgpO1xuICAgICAgICAgICAgdGhpcy5sZWF2ZShTVEFURVMuVFJZX0RFQ0xBUkFUSU9OKTtcbiAgICAgICAgfWNhdGNoKGVycm9yKXtcbiAgICAgICAgICAgIHRoaXMubGVhdmUoU1RBVEVTLlRSWV9ERUNMQVJBVElPTik7XG4gICAgICAgICAgICBpZihlcnJvci5jb2RlID09PSBlcnJvcnMuREVDTEFSSU9OX0ZBSUwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5lYXQoJ0lNUE9SVEFOVCcpKVxuICAgICAgICAgICAgbm9kZS5pbXBvcnRhbnQgPSB0cnVlO1xuICAgICAgICBpZighbm9FbmQpXG4gICAgICAgICAgICB0aGlzLm1hdGNoU2VtaUNvbG9uSWZOb0Jsb2NrKCk7XG4gICAgICAgIHRoaXMubGVhdmUoU1RBVEVTLkZJTFRFUl9ERUNMQVJBVElPTik7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIGFzc2lnbigpIHtcbiAgICAgICAgbGV0IHRva2VuID0gdGhpcy5sbCgpO1xuICAgICAgICB0aGlzLm1hdGNoKCdWQVInKTtcbiAgICAgICAgbGV0IG9wID0gdGhpcy5tYXRjaCgnPScsICc/PScsICdePScpLnR5cGU7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuYXNzaWduRXhwcih0cnVlKTtcbiAgICAgICAgLy9ARklYSVQgY29uZmxpY3Qgd2l0aCBwYXJlbkV4cHJcbiAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkFzc2lnbih0b2tlbi52YWx1ZSwgdmFsdWUsIEFTU0lHTlNbb3BdIHx8IDEpO1xuICAgIH1cblxuICAgIC8qKmZ1bmN0aW9uKCk7XG4gICAgICogY2FuIGJlIGFzc2lnbiBleHByZXNzaW9uXG4gICAgICogZnVuY3Rpb24gfCB2YWx1ZXNsaXN0IHwgdmFsdWVzXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gaGFzQ29tbWEgd2hldGhlciBoYXMgY29tbWEgaW4gdGhlIGV4cHJlc3Npb25cbiAgICAgKiBAcmV0dXJuIHttaXhpbn1cbiAgICAgKi9cbiAgICBhc3NpZ25FeHByKGhhc0NvbW1hKSB7XG4gICAgICAgIGxldCBub2RlID0gbnVsbDtcbiAgICAgICAgbGV0IHRva2VuID0gdGhpcy5sbCgpO1xuICAgICAgICBsZXQgZm4gPSBoYXNDb21tYSA/ICd2YWx1ZXNMaXN0JyA6ICd2YWx1ZXMnO1xuICAgICAgICBpZih0b2tlbi50eXBlID09PSAneycpICAgIC8vIOWPr+iDveaYr3BhcmVuRXhwciDkuZ/lj6/og73mmK9mdW5jdGlvblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnVuYygpO1xuICAgICAgICBlbHNlIGlmKHRva2VuLnR5cGUgPT09ICcoJykge1xuICAgICAgICAgICAgdGhpcy5tYXJrKCk7XG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnVuYygpO1xuICAgICAgICAgICAgfWNhdGNoKGUpe1xuICAgICAgICAgICAgICAgIGlmKGUuZXhwZWN0ICYmIGUuZXhwZWN0ID09ICd7JyB8fCBlLmV4cGVjdCA9PSdWQVInIHx8IGUuZXhwZWN0ID09ICcpJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbZm5dKCk7XG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW2ZuXSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gMXB4IDFweCAjZmZmLCAxcHggMXB4ICNmZmYgLi4uXG4gICAgLy8gY29tbWEgc2VwYXJhdGVkIHZhbHVlc1xuICAgIC8vIHZhbHVlc0xpc3RcbiAgICB2YWx1ZXNMaXN0KCkge1xuICAgICAgICBsZXQgbGlzdCA9IFtdO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBsZXQgdmFsdWVzID0gdGhpcy52YWx1ZXMoKTtcbiAgICAgICAgICAgIGlmKHZhbHVlcylcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2godmFsdWVzKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfSB3aGlsZSh0aGlzLmVhdCgnLCcpKTtcblxuICAgICAgICBpZihsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiBsaXN0WzBdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuVmFsdWVzTGlzdChsaXN0KTtcbiAgICB9XG4gICAgLy8gY29tcG9uZW50IFZhbHVlc1xuICAgIHZhbHVlcygpIHtcbiAgICAgICAgbGV0IGxpc3QgPSBbXTtcbiAgICAgICAgd2hpbGUodHJ1ZSkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5leHByZXNzaW9uKCk7XG4gICAgICAgICAgICBpZih2YWx1ZSlcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYobGlzdC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZWxzZSBpZihsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiBsaXN0WzBdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuVmFsdWVzKGxpc3QpO1xuICAgIH1cblxuICAgIGV4cHJlc3Npb24oKSB7XG4gICAgICAgIHRoaXMuZWF0KCdXUycpO1xuICAgICAgICByZXR1cm4gdGhpcy5sb2dpY09yRXhwcigpO1xuICAgIH1cblxuICAgIC8vIHx8XG4gICAgbG9naWNPckV4cHIoKSB7XG4gICAgICAgIGxldCBsZWZ0ID0gdGhpcy5sb2dpY0FuZEV4cHIoKSwgcmlnaHQ7XG4gICAgICAgIGxldCB0b2tlbjtcbiAgICAgICAgd2hpbGUoKHRva2VuID0gdGhpcy5sbCgpKS50eXBlID09PSAnfHwnKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5sb2dpY0FuZEV4cHIoKTtcbiAgICAgICAgICAgIGlmKCFyaWdodClcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKHRva2VuLnR5cGUgKyAnIHJlcXVpcmUgcmlnaHQgb3BlcmFuZCcsIGxlZnQpO1xuXG4gICAgICAgICAgICBsZXQgYlZhbHVlID0gdHJlZS50b0Jvb2xlYW4obGVmdCk7XG4gICAgICAgICAgICBpZihiVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZihiVmFsdWUgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gcmlnaHQ7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbmV3IHRyZWUuT3BlcmF0b3IodG9rZW4udHlwZSwgbGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgdGhpcy5lYXQoJ1dTJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgfVxuXG4gICAgLy8gJiZcbiAgICBsb2dpY0FuZEV4cHIoKSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5yZWxhdGlvbkV4cHIoKSwgcmlnaHQ7XG4gICAgICAgIGxldCB0b2tlbjtcbiAgICAgICAgd2hpbGUoKHRva2VuID0gdGhpcy5sbCgpKS50eXBlID09PSAnJiYnKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5yZWxhdGlvbkV4cHIoKTtcbiAgICAgICAgICAgIGlmKCFyaWdodClcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKHRva2VuLnR5cGUgKyAnIHJlcXVpcmUgcmlnaHQgb3BlcmFuZCcsIG5vZGUpO1xuXG4gICAgICAgICAgICBsZXQgYlZhbHVlID0gdHJlZS50b0Jvb2xlYW4obm9kZSk7XG4gICAgICAgICAgICBpZihiVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmKGJWYWx1ZSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHJpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5ldyB0cmVlLk9wZXJhdG9yKHRva2VuLnR5cGUsIG5vZGUsIHJpZ2h0KVxuICAgICAgICAgICAgdGhpcy5lYXQoJ1dTJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgLy8gPT1cbiAgICAvLyAhPVxuICAgIC8vID49XG4gICAgLy8gPD1cbiAgICAvLyA+XG4gICAgLy8gPFxuICAgIHJlbGF0aW9uRXhwcigpIHtcbiAgICAgICAgbGV0IGxlZnQgPSB0aGlzLmJpbm9wMSgpLCByaWdodDtcbiAgICAgICAgbGV0IHRva2VuO1xuICAgICAgICB3aGlsZShpc1JlbGF0aW9uT3AodG9rZW4gPSB0aGlzLmxsKCkudHlwZSkpe1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICB0aGlzLmVhdCgnV1MnKTtcbiAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5iaW5vcDEoKTtcbiAgICAgICAgICAgIGlmKCFyaWdodClcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKHRva2VuLnR5cGUgKyAnIHJlcXVpcmUgcmlnaHQgb3BlcmFuZCcsIGxlZnQpO1xuXG4gICAgICAgICAgICBpZih0cmVlLmlzUHJpbWFyeShsZWZ0LnR5cGUpICYmIHRyZWUuaXNQcmltYXJ5KHJpZ2h0LnR5cGUpKVxuICAgICAgICAgICAgICAgIGxlZnQgPSBiaW5vcC5yZWxhdGlvbi5jYWxsKHRoaXMsbGVmdCwgcmlnaHQsIHRva2VuLnR5cGUpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGxlZnQgPSBuZXcgdHJlZS5PcGVyYXRvcih0b2tlbi50eXBlLCBsZWZ0LCByaWdodClcbiAgICAgICAgICAgIHRoaXMuZWF0KCdXUycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWZ0O1xuICAgIH1cblxuICAgIC8vICsgLVxuICAgIGJpbm9wMSgpIHtcbiAgICAgICAgbGV0IGxlZnQgPSB0aGlzLmJpbm9wMigpLCByaWdodDtcbiAgICAgICAgbGV0IHRva2VuO1xuICAgICAgICB0aGlzLmVhdCgnV1MnKTtcbiAgICAgICAgd2hpbGUoKHRva2VuID0gdGhpcy5sbCgpKS50eXBlID09PSAnKycgfHwgdG9rZW4udHlwZSA9PT0gJy0nKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIHRoaXMuZWF0KCdXUycpO1xuICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmJpbm9wMigpO1xuICAgICAgICAgICAgaWYoIXJpZ2h0KVxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IobGEgKyAnIHJlcXVpcmUgcmlnaHQgb3BlcmFuZCcsIGxlZnQpXG5cbiAgICAgICAgICAgIGlmKHJpZ2h0LnR5cGUgPT09ICdESU1FTlNJT04nICYmIGxlZnQudHlwZSA9PT0gJ0RJTUVOU0lPTicpXG4gICAgICAgICAgICAgICAgbGVmdCA9IGJpbm9wW3Rva2VuLnR5cGVdLmNhbGwodGhpcywgbGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGxlZnQgPSBuZXcgdHJlZS5PcGVyYXRvcih0b2tlbi50eXBlLCBsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICB0aGlzLmVhdCgnV1MnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVmdDtcbiAgICB9XG5cbiAgICAvLyAqIC8gJSAuLi4gKEBUT0RPIOWwhnJhbmdl5LiOYmlub3Ay57uT5ZCILCDljbPlkIzkuIDkvJjlhYjnuqcpXG4gICAgYmlub3AyKCkge1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMudW5hcnkoKSwgcmlnaHQ7XG4gICAgICAgIGxldCB3cyA9ICEhdGhpcy5lYXQoJ1dTJyk7XG5cbiAgICAgICAgbGV0IHRva2VuID0gdGhpcy5sbCgpO1xuICAgICAgICAvLyA+Pj4+Pj5cbiAgICAgICAgaWYodG9rZW4udHlwZSA9PT0gJy4uLicpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgdGhpcy5lYXQoJ1dTJyk7XG4gICAgICAgICAgICByaWdodCA9IHRoaXMudW5hcnkoKTtcbiAgICAgICAgICAgIHJldHVybiB0cmVlLnJhbmdlKGxlZnQsIHJpZ2h0LCBsZWZ0LmxpbmVubyk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUodG9rZW4udHlwZSA9PT0gJyonIHx8IHRva2VuLnR5cGUgPT09ICcvJyB8fCB0b2tlbi50eXBlID09PSAnJScpIHtcbiAgICAgICAgICAgIC8vIOWNs+S4gOS4quepuuagvOS5n+ayoeaciVxuICAgICAgICAgICAgaWYodG9rZW4udHlwZSA9PSAnLycgJiYgIXdzICYmIHRoaXMubGwoMikudHlwZSAhPT0gJ1dTJylcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgdGhpcy5lYXQoJ1dTJyk7XG4gICAgICAgICAgICByaWdodCA9IHRoaXMudW5hcnkoKTtcbiAgICAgICAgICAgIGlmKCFyaWdodClcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKHRva2VuLnR5cGUgKyAnIHJlcXVpcmUgcmlnaHQgb3BlcmFuZCcsIGxlZnQpO1xuXG4gICAgICAgICAgICBpZihyaWdodC50eXBlID09PSAnRElNRU5TSU9OJyAmJiBsZWZ0LnR5cGUgPT09ICdESU1FTlNJT04nKVxuICAgICAgICAgICAgICAgIGxlZnQgPSBiaW5vcFt0b2tlbi50eXBlXS5jYWxsKHRoaXMsIGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbmV3IHRyZWUuT3BlcmF0b3IodG9rZW4udHlwZSwgbGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgdGhpcy5lYXQoJ1dTJyk7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMubGwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVmdDtcbiAgICB9XG5cbiAgICAvLyByYW5nZTogZnVuY3Rpb24oKXtcbiAgICAvLyAgICAgdmFyIGxlZnQgPSB0aGlzLmxsKCksXG4gICAgLy8gICAgICAgICBub2RlID0gbmV3IHRyZWUuVmFsdWVzTGlzdCgpLFxuICAgIC8vICAgICAgICAgcmlnaHQsIGxjLCByYywgcmV2ZXJzZTtcbiAgICAvLyAgICAgdGhpcy5tYXRjaCgnRElNRU5TSU9OJylcbiAgICAvLyAgICAgdGhpcy5lYXQoJy4uLicpO1xuICAgIC8vICAgICByaWdodCA9IHRoaXMubGwoKTtcbiAgICAvLyAgICAgdGhpcy5tYXRjaChsZWZ0LnR5cGUpO1xuICAgIC8vICAgICBsYyA9IGxlZnQudmFsdWU7XG4gICAgLy8gICAgIHJjID0gcmlnaHQudmFsdWU7XG4gICAgLy8gICAgIHJldmVyc2UgPSBsYyA+IHJjO1xuXG4gICAgLy8gICAgIGZvcig7IGxjICE9IHJjIDspe1xuICAgIC8vICAgICAgICAgbm9kZS5saXN0LnB1c2goe1xuICAgIC8vICAgICAgICAgICAgIHR5cGU6IGxlZnQudHlwZSxcbiAgICAvLyAgICAgICAgICAgICB2YWx1ZTogbGNcbiAgICAvLyAgICAgICAgIH0pXG4gICAgLy8gICAgICAgICBpZihyZXZlcnNlKSAgbGMgLT0gMVxuICAgIC8vICAgICAgICAgZWxzZSBsYyArPSAxXG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgbm9kZS5saXN0LnB1c2goe1xuICAgIC8vICAgICAgICAgdHlwZTogbGVmdC50eXBlLFxuICAgIC8vICAgICAgICAgdmFsdWU6IGxjXG4gICAgLy8gICAgIH0pXG4gICAgLy8gICAgIHJldHVybiBub2RlO1xuICAgIC8vIH0sXG5cbiAgICAvLyDkuIDlhYPmlbBcbiAgICAvLyBAVE9ETyA6IOWKoOWFpSDvvIHkuIDlhYPmlbBcbiAgICB1bmFyeSgpIHtcbiAgICAgICAgbGV0IHRva2VuID0gdGhpcy5sbCgpO1xuICAgICAgICBpZih0b2tlbi50eXBlID09PSAnLScgfHwgdG9rZW4udHlwZSA9PT0gJysnIHx8IHRva2VuLnR5cGUgPT09ICchJyApIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgdGhpcy5lYXQoJ1dTJyk7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLnVuYXJ5KCk7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5ldyB0cmVlLlVuYXJ5KHZhbHVlLCB0b2tlbi50eXBlKTtcbiAgICAgICAgICAgIG5vZGUubGluZW5vID0gdG9rZW4ubGluZW5vO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJpbWFyeSgpO1xuICAgIH1cblxuICAgIC8vIHByaW1hcnlcbiAgICAvLyAgOiBJZGVudFxuICAgIC8vICA6IERpbWVuc2lvblxuICAgIC8vICA6IGZ1bmN0aW9uXG4gICAgLy8gIDogVmFyXG4gICAgcHJpbWFyeSgpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBudWxsO1xuICAgICAgICBsZXQgdG9rZW4gPSB0aGlzLmxsKCk7XG4gICAgICAgIHN3aXRjaCh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbkV4cHIoKTtcbiAgICAgICAgICAgIGNhc2UgJz0nOlxuICAgICAgICAgICAgICAgIC8vIGZpbHRlcjogYWxwaGEoeHg9ODAsIHh4PXh4LCBkZGQ9eHgpXG4gICAgICAgICAgICAgICAgaWYodGhpcy5zdGF0ZShTVEFURVMuRklMVEVSX0RFQ0xBUkFUSU9OKVxuICAgICAgICAgICAgICAgICAgICAmJiB0aGlzLnN0YXRlKFNUQVRFUy5GVU5DVElPTl9DQUxMKSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgbGV0IHRva2VuMiA9IHRoaXMubGwoMik7XG4gICAgICAgICAgICAgICAgaWYodG9rZW4yLnR5cGUgPT09ICdURVhUJyB8fCB0b2tlbjIudHlwZSA9PT0gJyN7JylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcG91bmRJZGVudCgpO1xuICAgICAgICAgICAgY2FzZSAnI3snOlxuICAgICAgICAgICAgY2FzZSAnVEVYVCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcG91bmRJZGVudCgpO1xuICAgICAgICAgICAgY2FzZSAnRlVOQ1RJT04nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZuQ2FsbCgpO1xuICAgICAgICAgICAgY2FzZSAnSEFTSCc6XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gdG9rZW4udmFsdWU7XG4gICAgICAgICAgICAgICAgaWYoL14jKFswLTlhLWZBLUZdezN9fFswLTlhLWZBLUZdezZ9KSQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBuZXcgdHJlZS5Db2xvcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubGluZW5vID0gdG9rZW4ubGluZW5vO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbmV3IHRyZWUuVW5rbm93bih0b2tlbi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICAvLyBUT0RPIOaPkuWAvFxuICAgICAgICAgICAgY2FzZSAnU1RSSU5HJzpcbiAgICAgICAgICAgIGNhc2UgJ0RJTUVOU0lPTic6XG4gICAgICAgICAgICBjYXNlICdCT09MRUFOJzpcbiAgICAgICAgICAgIGNhc2UgJ1ZBUic6XG4gICAgICAgICAgICBjYXNlICdOVUxMJzpcbiAgICAgICAgICAgIGNhc2UgJ1VSTCc6XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICBjYXNlICd+JzpcbiAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICBjYXNlICc6JzpcbiAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgY2FzZSAnUFNFVURPX0NMQVNTJzpcbiAgICAgICAgICAgIGNhc2UgJ0NMQVNTJzpcbiAgICAgICAgICAgIGNhc2UgJ0FUVFJJQlVURSc6XG4gICAgICAgICAgICAgICAgaWYodGhpcy5zdGF0ZShTVEFURVMuVFJZX0RFQ0xBUkFUSU9OKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGVycm9ycy5ERUNMQVJJT05fRkFJTCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgIH1cblxuXG4gICAgLy8gIDogJyN7JyB2YWx1ZXMgJ30nXG4gICAgaW50ZXJwb2xhdGlvbigpIHtcbiAgICAgICAgdGhpcy5tYXRjaCgnI3snKTtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnZhbHVlc0xpc3QoKTtcbiAgICAgICAgdGhpcy5tYXRjaCgnfScpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICAvLyBwYXJlbkV4cHJcbiAgICAvLyAgOiAnKCcgZXhwcmVzaW9uICcpJ1xuICAgIHBhcmVuRXhwcigpIHtcbiAgICAgICAgdGhpcy5tYXRjaCgnKCcpO1xuICAgICAgICB0aGlzLmVhdCgnV1MnKTtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnZhbHVlc0xpc3QoKTtcbiAgICAgICAgbm9kZS5saW5lbm8gPSB0aGlzLmxsKCkubGluZW5vO1xuICAgICAgICB0aGlzLmVhdCgnV1MnKTtcbiAgICAgICAgdGhpcy5tYXRjaCgnKScpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICAvLyBjb21wb3VuZElkZW50IOe7hOWQiElkZW50XG4gICAgLy8gIDogKGludGVycG9sYXRpb24gfCBURVhUKSArXG4gICAgY29tcG91bmRJZGVudCgpIHtcbiAgICAgICAgbGV0IG5vZGU7XG4gICAgICAgIGxldCBsaXN0ID0gW107XG4gICAgICAgIGxldCB0b2tlbjtcbiAgICAgICAgbGV0IHNlcDtcbiAgICAgICAgd2hpbGUodHJ1ZSkge1xuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmxsKCk7XG4gICAgICAgICAgICBpZih0b2tlbi50eXBlID09PSAnI3snKSB7XG4gICAgICAgICAgICAgICAgc2VwID0gdGhpcy5pbnRlcnBvbGF0aW9uKCk7XG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKHNlcCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYodG9rZW4udHlwZSA9PT0gJ1RFWFQnIHx8IHRva2VuLnR5cGUgPT09ICctJykge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgICAgIGxpc3QucHVzaCh0b2tlbi52YWx1ZSB8fCB0b2tlbi50eXBlKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmKCFzZXApIHtcbiAgICAgICAgICAgIGlmKCFsaXN0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4ge3R5cGU6ICdURVhUJywgdmFsdWU6IGxpc3RbMF0sIGxpbmVubzogdG9rZW4ubGluZW5vfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUgPSBuZXcgdHJlZS5Db21wb3VuZElkZW50KGxpc3QpO1xuICAgICAgICAgICAgbm9kZS5saW5lbm8gPSB0b2tlbi5saW5lbm87XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZuQ2FsbFxuICAgIC8vICA6IENBTEwgRlVOQ1RJT04gJygnICBleHByZXNpb24gKiAnKSdcbiAgICBmbkNhbGwoKSB7XG4gICAgICAgIGxldCB0b2tlbiA9IHRoaXMubGwoKTtcbiAgICAgICAgdGhpcy5tYXRjaCgnRlVOQ1RJT04nLCAnVkFSJyk7XG4gICAgICAgIGlmKHRva2VuLmFyZ3MpXG4gICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuQ2FsbCh0b2tlbi52YWx1ZSwgdG9rZW4uYXJncywgbnVsbCwgdG9rZW4ubGluZW5vKTtcbiAgICAgICAgdGhpcy5lYXQoJ1dTJyk7XG4gICAgICAgIHRoaXMubWF0Y2goJygnKTtcbiAgICAgICAgdGhpcy5lbnRlcihTVEFURVMuRlVOQ1RJT05fQ0FMTCk7XG4gICAgICAgIHRoaXMuZWF0KCdXUycpO1xuICAgICAgICBsZXQgcGFyZ3MgPSB0aGlzLmxsKCkudHlwZSAhPT0gJyknID8gdGhpcy5hcmdzKCkgOiB7YXJnczpbXX07XG4gICAgICAgIHRoaXMubGVhdmUoc3RhdGVzLkZVTkNUSU9OX0NBTEwpO1xuICAgICAgICB0aGlzLm1hdGNoKCcpJyk7XG4gICAgICAgIHJldHVybiBuZXcgdHJlZS5DYWxsKHRva2VuLnZhbHVlLCBwYXJncy5hcmdzLCBwYXJncy5uYW1lZCwgdG9rZW4ubGluZW5vKTtcbiAgICB9XG5cbiAgICAvL0BUT0RPIHN0YXJ0IG5hbWVkIGFyZ3VtZW50c1xuICAgIGFyZ3MoZW5kKSB7XG4gICAgICAgIGxldCB0b2tlbjtcbiAgICAgICAgbGV0IG5hbWVkID0gbnVsbDtcbiAgICAgICAgbGV0IGFyZ3MgPSBbXTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMubGwoKTtcbiAgICAgICAgICAgIGlmKHRva2VuLnR5cGUgPT09ICdWQVInICYmIHRoaXMubGwoMikudHlwZSA9PT0gJz0nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0KDIpO1xuICAgICAgICAgICAgICAgIGlmKCFuYW1lZCkgbmFtZWQgPSB7fTtcbiAgICAgICAgICAgICAgICBuYW1lZFt0b2tlbi52YWx1ZV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJncy5wdXNoKHRoaXMuYXNzaWduRXhwcigpKTtcbiAgICAgICAgICAgIHRoaXMuc2tpcCgnV1MnKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfSB3aGlsZSh0aGlzLmVhdCgnLCcpKTtcblxuICAgICAgICByZXR1cm4ge2FyZ3MsIG5hbWVkfTtcbiAgICB9XG5cbiAgICAvLyBzdHlsdXMgaW5zcGlyZWQgZmVhdHVyZTtcbiAgICB0cmFuc3BhcmVudENhbGwoKSB7XG4gICAgICAgIGxldCB0b2tlbiA9IHRoaXMubGwoKTtcbiAgICAgICAgdGhpcy5tYXRjaCgnVkFSJyk7XG4gICAgICAgIHRoaXMubWF0Y2goJzonKTtcbiAgICAgICAgdGhpcy5lYXQoJ1dTJylcbiAgICAgICAgdmFyIHBhcmdzID0gdGhpcy5hcmdzKCk7XG4gICAgICAgIC8vIGlmKGFyZ3MudHlwZSA9PT0gJ3ZhbHVlcycpe1xuICAgICAgICAvLyAgICAgYXJncyA9IG5ldyB0cmVlLlZhbHVlc0xpc3QoYXJncy5saXN0KTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGlmKGFyZ3MudHlwZSAhPT0gJ3ZhbHVlc2xpc3QnKSBhcmdzID0gW2FyZ3NdO1xuICAgICAgICAvLyBlbHNlIGFyZ3MgPSBhcmdzLmxpc3Q7XG4gICAgICAgIHJldHVybiB0cmVlLkNhbGwodG9rZW4udmFsdWUsIHBhcmdzLmFyZ3MsIHBhcmdzLm5hbWVkLCB0b2tlbi5saW5lbm8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBhdC1ydWxlIHByZWZpeFxuICAgICAqL1xuICAgIF9yZW1vdmVQcmVmaXgoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXi1cXHcrLS8sICcnKTtcbiAgICB9XG5cbiAgICBtYXRjaFNlbWlDb2xvbklmTm9CbG9jaygpIHtcbiAgICAgICAgdGhpcy5lYXQoJ1dTJyk7XG4gICAgICAgIGlmKHRoaXMubGwoKS50eXBlICE9PSAnfScpXG4gICAgICAgICAgICB0aGlzLm1hdGNoKCc7Jyk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQYXJzZXI7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9wYXJzZXIuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 4 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Node = function () {\n    function Node() {\n        _classCallCheck(this, Node);\n    }\n\n    _createClass(Node, [{\n        key: 'clone',\n        value: function clone() {}\n    }]);\n\n    return Node;\n}();\n\nvar StyleSheet = function () {\n    function StyleSheet() {\n        var list = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\n        _classCallCheck(this, StyleSheet);\n\n        this.list = list;\n    }\n\n    _createClass(StyleSheet, [{\n        key: 'clone',\n        value: function clone() {\n            // >>>>>> cloneNode没有实现\n            return new StyleSheet(cloneNode(this.list));\n        }\n\n        // >>>>>> 不知道作用\n\n    }, {\n        key: 'exclude',\n        value: function exclude() {\n            var ret = [];\n            for (var i = this.list.length; i--;) {\n                var _item = this.list[i];\n                if (_item.type === 'media') ret.unshift(list.splice(i, 1)[0]);\n            }\n            return ret;\n        }\n    }, {\n        key: 'abstract',\n        value: function abstract() {\n            this.list.forEach(function (ruleset) {\n                return ruleset && (ruleset.abstract = true);\n            });\n            return this;\n        }\n    }]);\n\n    return StyleSheet;\n}();\n\nvar SelectorList = function () {\n    function SelectorList() {\n        var list = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n        var lineno = arguments[1];\n\n        _classCallCheck(this, SelectorList);\n\n        this.list = list;\n        this.lineno = lineno;\n    }\n\n    _createClass(SelectorList, [{\n        key: 'clone',\n        value: function clone() {\n            return new SelectorList(cloneNode(this.list));\n        }\n    }, {\n        key: 'length',\n        value: function length() {\n            return this.list.length;\n        }\n    }]);\n\n    return SelectorList;\n}();\n\n// 复选择器\n\n\nvar Selector = function () {\n    function Selector(string) {\n        var interpolations = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n        _classCallCheck(this, Selector);\n\n        this.string = string;\n        this.interpolations = interpolations;\n    }\n\n    _createClass(Selector, [{\n        key: 'clone',\n        value: function clone() {\n            return new ComplexSelector(this.string, cloneNode(this.interpolations));\n        }\n    }]);\n\n    return Selector;\n}();\n\nvar RuleSet = function () {\n    function RuleSet(selector, block) {\n        var abstract = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n        _classCallCheck(this, RuleSet);\n\n        this.selector = selector;\n        this.block = block;\n        // >>>>>> @TODO for mixin\n        this.ref = [];\n        this.abstract = abstract;\n    }\n\n    _createClass(RuleSet, [{\n        key: 'addRef',\n        value: function addRef(ruleset) {\n            if (!this.ref.includes(item)) this.ref.push(ruleset);\n        }\n    }, {\n        key: 'getSelectors',\n        value: function getSelectors() {\n            if (this.selector._compute === true) return this.selector.list;\n\n            var selectors = this.selector.list;\n            var plist = void 0;\n            if (this.parent && (plist = this.parent.getSelectors()) && plist.length) selectors = this._concatSelector(selectors, plist);\n\n            if (!this.parent) this.selector.list.forEach(function (selector) {\n                return selector.string = selector.string.replace(/&/g, '');\n            });\n\n            if (this.ref.length) {\n                this.ref.forEach(function (ruleset) {\n                    return selectors = [].concat(_toConsumableArray(selectors), _toConsumableArray(ruleset.getSelectors()));\n                });\n                this.ref = [];\n            }\n\n            this.selector.list = selectors;\n            this.selector._compute = true;\n            return selectors;\n        }\n    }]);\n\n    return RuleSet;\n}();\n\nvar Block = function () {\n    function Block() {\n        var list = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\n        _classCallCheck(this, Block);\n\n        this.list = list;\n    }\n\n    _createClass(Block, [{\n        key: 'exclude',\n        value: function exclude(isMedia) {\n            var ret = [];\n        }\n    }]);\n\n    return Block;\n}();\n\nvar Declaration = function Declaration(property, value) {\n    var important = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n    _classCallCheck(this, Declaration);\n\n    Object.assign(this, { property: property, value: value, important: important });\n};\n\nvar ValuesList = function () {\n    function ValuesList() {\n        var list = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n        var lineno = arguments[1];\n\n        _classCallCheck(this, ValuesList);\n\n        this.list = list;\n        this.lineno = lineno;\n    }\n\n    _createClass(ValuesList, [{\n        key: 'flatten',\n        value: function flatten() {\n            var list = this.list,\n                i = list.length,\n                values;\n            for (; i--;) {\n                values = list[i];\n                if (values.type == 'valueslist') {\n                    splice.apply(list, [i, 1].concat(values.list));\n                }\n            }\n            return this;\n        }\n    }, {\n        key: 'first',\n        value: function first() {\n            return this.list[0].list[0];\n        }\n    }]);\n\n    return ValuesList;\n}();\n\nvar Values = function () {\n    function Values() {\n        var list = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\n        _classCallCheck(this, Values);\n\n        this.list = list;\n    }\n\n    _createClass(Values, [{\n        key: 'flatten',\n        value: function flatten() {\n            var list = this.list,\n                i = list.length,\n                value;\n            for (; i--;) {\n                value = list[i];\n                if (value.type == 'values') {\n                    splice.apply(this, [i, 1].concat(value.list));\n                }\n            }\n            return this;\n        }\n    }]);\n\n    return Values;\n}();\n\n// 所有侦测不出的类似统一放置在这里\n\n\nvar Unknown = function Unknown(name) {\n    _classCallCheck(this, Unknown);\n\n    this.name = name;\n};\n\nvar Assign = function Assign(name, value) {\n    var mode = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];\n\n    _classCallCheck(this, Assign);\n\n    Object.assign(this, { name: name, value: value, mode: mode });\n};\n\nvar Operator = function Operator(op, left, right) {\n    _classCallCheck(this, Operator);\n\n    Object.assign(this, { op: op, left: left, right: right });\n};\n\nvar Range = function Range(left, right) {\n    _classCallCheck(this, Range);\n\n    this.left = left;\n    this.right = right;\n};\n\nvar Unary = function Unary(value, op) {\n    _classCallCheck(this, Unary);\n\n    this.value = value;\n    this.op = op;\n};\n\nvar Dimension = function () {\n    function Dimension(value, unit) {\n        _classCallCheck(this, Dimension);\n\n        this.value = value;\n        this.unit = unit;\n    }\n\n    _createClass(Dimension, [{\n        key: 'toString',\n        value: function toString() {\n            return this.value + (this.unit || '');\n        }\n    }]);\n\n    return Dimension;\n}();\n\nvar CompoundIdent = function () {\n    function CompoundIdent() {\n        var list = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\n        _classCallCheck(this, CompoundIdent);\n\n        this.list = list;\n    }\n\n    _createClass(CompoundIdent, [{\n        key: 'toString',\n        value: function toString() {\n            return this.list.join('');\n        }\n    }]);\n\n    return CompoundIdent;\n}();\n\nexports.Node = Node;\nexports.StyleSheet = StyleSheet;\nexports.RuleSet = RuleSet;\nexports.SelectorList = SelectorList;\nexports.Selector = Selector;\nexports.Block = Block;\nexports.Declaration = Declaration;\nexports.ValuesList = ValuesList;\nexports.Values = Values;\nexports.Unknown = Unknown;\nexports.Assign = Assign;\nexports.Operator = Operator;\nexports.Range = Range;\nexports.Unary = Unary;\nexports.Dimension = Dimension;//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdHJlZS9pbmRleC5qcz83MTYzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQUFNLEk7QUFDRixvQkFBYztBQUFBO0FBRWI7Ozs7Z0NBRU8sQ0FFUDs7Ozs7O0lBR0MsVTtBQUNGLDBCQUF1QjtBQUFBLFlBQVgsSUFBVyx5REFBSixFQUFJOztBQUFBOztBQUNuQixhQUFLLElBQUwsR0FBWSxJQUFaO0FBQ0g7Ozs7Z0NBRU87O0FBRUosbUJBQU8sSUFBSSxVQUFKLENBQWUsVUFBVSxLQUFLLElBQWYsQ0FBZixDQUFQO0FBQ0g7Ozs7OztrQ0FHUztBQUNOLGdCQUFJLE1BQU0sRUFBVjtBQUNBLGlCQUFJLElBQUksSUFBSSxLQUFLLElBQUwsQ0FBVSxNQUF0QixFQUE4QixHQUE5QixHQUFvQztBQUNoQyxvQkFBSSxRQUFPLEtBQUssSUFBTCxDQUFVLENBQVYsQ0FBWDtBQUNBLG9CQUFHLE1BQUssSUFBTCxLQUFjLE9BQWpCLEVBQ0ksSUFBSSxPQUFKLENBQVksS0FBSyxNQUFMLENBQVksQ0FBWixFQUFlLENBQWYsRUFBa0IsQ0FBbEIsQ0FBWjtBQUNQO0FBQ0QsbUJBQU8sR0FBUDtBQUNIOzs7bUNBRVU7QUFDUCxpQkFBSyxJQUFMLENBQVUsT0FBVixDQUFrQixVQUFDLE9BQUQ7QUFBQSx1QkFBYSxZQUFZLFFBQVEsUUFBUixHQUFtQixJQUEvQixDQUFiO0FBQUEsYUFBbEI7QUFDQSxtQkFBTyxJQUFQO0FBQ0g7Ozs7OztJQUdDLFk7QUFDRiw0QkFBK0I7QUFBQSxZQUFuQixJQUFtQix5REFBWixFQUFZO0FBQUEsWUFBUixNQUFROztBQUFBOztBQUMzQixhQUFLLElBQUwsR0FBWSxJQUFaO0FBQ0EsYUFBSyxNQUFMLEdBQWMsTUFBZDtBQUNIOzs7O2dDQUVPO0FBQ0osbUJBQU8sSUFBSSxZQUFKLENBQWlCLFVBQVUsS0FBSyxJQUFmLENBQWpCLENBQVA7QUFDSDs7O2lDQUVRO0FBQ0wsbUJBQU8sS0FBSyxJ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QUFwQjtBQUNILEM7O0lBR0MsSyxHQUNGLGVBQVksSUFBWixFQUFrQixLQUFsQixFQUF5QjtBQUFBOztBQUNyQixTQUFLLElBQUwsR0FBWSxJQUFaO0FBQ0EsU0FBSyxLQUFMLEdBQWEsS0FBYjtBQUNILEM7O0lBR0MsSyxHQUNGLGVBQVksS0FBWixFQUFtQixFQUFuQixFQUF1QjtBQUFBOztBQUNuQixTQUFLLEtBQUwsR0FBYSxLQUFiO0FBQ0EsU0FBSyxFQUFMLEdBQVUsRUFBVjtBQUNILEM7O0lBR0MsUztBQUNGLHVCQUFZLEtBQVosRUFBbUIsSUFBbkIsRUFBeUI7QUFBQTs7QUFDckIsYUFBSyxLQUFMLEdBQWEsS0FBYjtBQUNBLGFBQUssSUFBTCxHQUFZLElBQVo7QUFDSDs7OzttQ0FFVTtBQUNQLG1CQUFPLEtBQUssS0FBTCxJQUFjLEtBQUssSUFBTCxJQUFhLEVBQTNCLENBQVA7QUFDSDs7Ozs7O0lBR0MsYTtBQUNGLDZCQUF1QjtBQUFBLFlBQVgsSUFBVyx5REFBSixFQUFJOztBQUFBOztBQUNuQixhQUFLLElBQUwsR0FBWSxJQUFaO0FBQ0g7Ozs7bUNBRVU7QUFDUCxtQkFBTyxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsRUFBZixDQUFQO0FBQ0g7Ozs7OztRQUtELEksR0FBQSxJO1FBQ0EsVSxHQUFBLFU7UUFDQSxPLEdBQUEsTztRQUNBLFksR0FBQSxZO1FBQ0EsUSxHQUFBLFE7UUFDQSxLLEdBQUEsSztRQUNBLFcsR0FBQSxXO1FBQ0EsVSxHQUFBLFU7UUFDQSxNLEdBQUEsTTtRQUNBLE8sR0FBQSxPO1FBQ0EsTSxHQUFBLE07UUFDQSxRLEdBQUEsUTtRQUNBLEssR0FBQSxLO1FBQ0EsSyxHQUFBLEs7UUFDQSxTLEdBQUEsUyIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgTm9kZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG5cbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcblxuICAgIH1cbn1cblxuY2xhc3MgU3R5bGVTaGVldCB7XG4gICAgY29uc3RydWN0b3IobGlzdCA9IFtdKSB7XG4gICAgICAgIHRoaXMubGlzdCA9IGxpc3Q7XG4gICAgfVxuXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIC8vID4+Pj4+PiBjbG9uZU5vZGXmsqHmnInlrp7njrBcbiAgICAgICAgcmV0dXJuIG5ldyBTdHlsZVNoZWV0KGNsb25lTm9kZSh0aGlzLmxpc3QpKTtcbiAgICB9XG5cbiAgICAvLyA+Pj4+Pj4g5LiN55+l6YGT5L2c55SoXG4gICAgZXhjbHVkZSgpIHtcbiAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICBmb3IobGV0IGkgPSB0aGlzLmxpc3QubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMubGlzdFtpXTtcbiAgICAgICAgICAgIGlmKGl0ZW0udHlwZSA9PT0gJ21lZGlhJylcbiAgICAgICAgICAgICAgICByZXQudW5zaGlmdChsaXN0LnNwbGljZShpLCAxKVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBhYnN0cmFjdCgpIHtcbiAgICAgICAgdGhpcy5saXN0LmZvckVhY2goKHJ1bGVzZXQpID0+IHJ1bGVzZXQgJiYgKHJ1bGVzZXQuYWJzdHJhY3QgPSB0cnVlKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuY2xhc3MgU2VsZWN0b3JMaXN0IHtcbiAgICBjb25zdHJ1Y3RvcihsaXN0ID0gW10sIGxpbmVubykge1xuICAgICAgICB0aGlzLmxpc3QgPSBsaXN0O1xuICAgICAgICB0aGlzLmxpbmVubyA9IGxpbmVubztcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rvckxpc3QoY2xvbmVOb2RlKHRoaXMubGlzdCkpO1xuICAgIH1cblxuICAgIGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdC5sZW5ndGg7XG4gICAgfVxufVxuXG4vLyDlpI3pgInmi6nlmahcbmNsYXNzIFNlbGVjdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihzdHJpbmcsIGludGVycG9sYXRpb25zID0gW10pIHtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgICAgIHRoaXMuaW50ZXJwb2xhdGlvbnMgPSBpbnRlcnBvbGF0aW9ucztcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4U2VsZWN0b3IodGhpcy5zdHJpbmcsIGNsb25lTm9kZSh0aGlzLmludGVycG9sYXRpb25zKSk7XG4gICAgfVxufVxuXG5jbGFzcyBSdWxlU2V0IHtcbiAgICBjb25zdHJ1Y3RvcihzZWxlY3RvciwgYmxvY2ssIGFic3RyYWN0ID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLmJsb2NrID0gYmxvY2s7XG4gICAgICAgIC8vID4+Pj4+PiBAVE9ETyBmb3IgbWl4aW5cbiAgICAgICAgdGhpcy5yZWYgPSBbXTtcbiAgICAgICAgdGhpcy5hYnN0cmFjdCA9IGFic3RyYWN0O1xuICAgIH1cblxuICAgIGFkZFJlZihydWxlc2V0KSB7XG4gICAgICAgIGlmKCF0aGlzLnJlZi5pbmNsdWRlcyhpdGVtKSlcbiAgICAgICAgICAgIHRoaXMucmVmLnB1c2gocnVsZXNldCk7XG4gICAgfVxuXG4gICAgZ2V0U2VsZWN0b3JzKCkge1xuICAgICAgICBpZih0aGlzLnNlbGVjdG9yLl9jb21wdXRlID09PSB0cnVlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0b3IubGlzdDtcblxuICAgICAgICBsZXQgc2VsZWN0b3JzID0gdGhpcy5zZWxlY3Rvci5saXN0O1xuICAgICAgICBsZXQgcGxpc3Q7XG4gICAgICAgIGlmKHRoaXMucGFyZW50ICYmIChwbGlzdCA9IHRoaXMucGFyZW50LmdldFNlbGVjdG9ycygpKSAmJiBwbGlzdC5sZW5ndGgpXG4gICAgICAgICAgICBzZWxlY3RvcnMgPSB0aGlzLl9jb25jYXRTZWxlY3RvcihzZWxlY3RvcnMsIHBsaXN0KTtcblxuICAgICAgICBpZighdGhpcy5wYXJlbnQpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yLmxpc3QuZm9yRWFjaCgoc2VsZWN0b3IpID0+XG4gICAgICAgICAgICAgICAgc2VsZWN0b3Iuc3RyaW5nID0gc2VsZWN0b3Iuc3RyaW5nLnJlcGxhY2UoLyYvZywgJycpKTtcblxuICAgICAgICBpZih0aGlzLnJlZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucmVmLmZvckVhY2goKHJ1bGVzZXQpID0+XG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzID0gWy4uLnNlbGVjdG9ycywgLi4ucnVsZXNldC5nZXRTZWxlY3RvcnMoKV0pO1xuICAgICAgICAgICAgdGhpcy5yZWYgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2VsZWN0b3IubGlzdCA9IHNlbGVjdG9ycztcbiAgICAgICAgdGhpcy5zZWxlY3Rvci5fY29tcHV0ZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBzZWxlY3RvcnM7XG4gICAgfVxuXG59XG5cbmNsYXNzIEJsb2NrIHtcbiAgICBjb25zdHJ1Y3RvcihsaXN0ID0gW10pIHtcbiAgICAgICAgdGhpcy5saXN0ID0gbGlzdDtcbiAgICB9XG5cbiAgICBleGNsdWRlKGlzTWVkaWEpIHtcbiAgICAgICAgbGV0IHJldCA9IFtdO1xuICAgIH1cbn1cblxuY2xhc3MgRGVjbGFyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5LCB2YWx1ZSwgaW1wb3J0YW50ID0gZmFsc2UpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7cHJvcGVydHksIHZhbHVlLCBpbXBvcnRhbnR9KTtcbiAgICB9XG59XG5cbmNsYXNzIFZhbHVlc0xpc3Qge1xuICAgIGNvbnN0cnVjdG9yKGxpc3QgPSBbXSwgbGluZW5vKSB7XG4gICAgICAgIHRoaXMubGlzdCA9IGxpc3Q7XG4gICAgICAgIHRoaXMubGluZW5vID0gbGluZW5vO1xuICAgIH1cblxuICAgIGZsYXR0ZW4oKSB7XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5saXN0LFxuICAgICAgICAgICAgaSA9IGxpc3QubGVuZ3RoLFxuICAgICAgICAgICAgdmFsdWVzO1xuICAgICAgICBmb3IoO2ktLTspe1xuICAgICAgICAgICAgdmFsdWVzID0gbGlzdFtpXTtcbiAgICAgICAgICAgIGlmKHZhbHVlcy50eXBlID09ICd2YWx1ZXNsaXN0Jyl7XG4gICAgICAgICAgICAgICAgc3BsaWNlLmFwcGx5KGxpc3QsIFtpLCAxXS5jb25jYXQodmFsdWVzLmxpc3QpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmaXJzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdFswXS5saXN0WzBdO1xuICAgIH1cbn1cblxuY2xhc3MgVmFsdWVzIHtcbiAgICBjb25zdHJ1Y3RvcihsaXN0ID0gW10pIHtcbiAgICAgICAgdGhpcy5saXN0ID0gbGlzdDtcbiAgICB9XG5cbiAgICBmbGF0dGVuKCkge1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMubGlzdCxcbiAgICAgICAgICAgIGkgPSBsaXN0Lmxlbmd0aCxcbiAgICAgICAgICAgIHZhbHVlO1xuICAgICAgICBmb3IoO2ktLTspe1xuICAgICAgICAgICAgdmFsdWUgPSBsaXN0W2ldO1xuICAgICAgICAgICAgaWYodmFsdWUudHlwZSA9PSAndmFsdWVzJyl7XG4gICAgICAgICAgICAgICAgc3BsaWNlLmFwcGx5KHRoaXMsIFtpLCAxXS5jb25jYXQodmFsdWUubGlzdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuLy8g5omA5pyJ5L6m5rWL5LiN5Ye655qE57G75Ly857uf5LiA5pS+572u5Zyo6L+Z6YeMXG5jbGFzcyBVbmtub3duIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxufVxuXG5jbGFzcyBBc3NpZ24ge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHZhbHVlLCBtb2RlID0gMSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtuYW1lLCB2YWx1ZSwgbW9kZX0pO1xuICAgIH1cbn1cblxuY2xhc3MgT3BlcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKG9wLCBsZWZ0LCByaWdodCkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtvcCwgbGVmdCwgcmlnaHR9KTtcbiAgICB9XG59XG5cbmNsYXNzIFJhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihsZWZ0LCByaWdodCkge1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgfVxufVxuXG5jbGFzcyBVbmFyeSB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIG9wKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5vcCA9IG9wO1xuICAgIH1cbn1cblxuY2xhc3MgRGltZW5zaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgdW5pdCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudW5pdCA9IHVuaXQ7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlICsgKHRoaXMudW5pdCB8fCAnJyk7XG4gICAgfVxufVxuXG5jbGFzcyBDb21wb3VuZElkZW50IHtcbiAgICBjb25zdHJ1Y3RvcihsaXN0ID0gW10pIHtcbiAgICAgICAgdGhpcy5saXN0ID0gbGlzdDtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdC5qb2luKCcnKTtcbiAgICB9XG59XG5cblxuZXhwb3J0IHtcbiAgICBOb2RlLFxuICAgIFN0eWxlU2hlZXQsXG4gICAgUnVsZVNldCxcbiAgICBTZWxlY3Rvckxpc3QsXG4gICAgU2VsZWN0b3IsXG4gICAgQmxvY2ssXG4gICAgRGVjbGFyYXRpb24sXG4gICAgVmFsdWVzTGlzdCxcbiAgICBWYWx1ZXMsXG4gICAgVW5rbm93bixcbiAgICBBc3NpZ24sXG4gICAgT3BlcmF0b3IsXG4gICAgUmFuZ2UsXG4gICAgVW5hcnksXG4gICAgRGltZW5zaW9uXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy90cmVlL2luZGV4LmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }
/******/ ])
});
;