(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _tokenizer = __webpack_require__(1);\n\nvar _tokenizer2 = _interopRequireDefault(_tokenizer);\n\nvar _parser = __webpack_require__(3);\n\nvar _parser2 = _interopRequireDefault(_parser);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar content = '\\n.u-btn {\\n    background: red;\\n}\\n';\nvar content2 = '$test = $abc; $test = 4px;';\nvar content3 = '\\n.u-btn, .test {}\\n';\n\nvar tokenizer = new _tokenizer2.default();\nvar parser = new _parser2.default();\n\nvar tokens = tokenizer.tokenize(content);\nvar ast = parser.parse(tokens);\n\nconsole.log(ast);//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi90ZXN0L3NwZWNzL3BhcnNlci5qcz8xZTIzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7QUFDQTs7Ozs7O0FBRUEsSUFBSSxpREFBSjtBQUtBLElBQUksV0FBVyw0QkFBZjtBQUNBLElBQUksaUNBQUo7O0FBSUEsSUFBSSxZQUFZLHlCQUFoQjtBQUNBLElBQUksU0FBUyxzQkFBYjs7QUFFQSxJQUFJLFNBQVMsVUFBVSxRQUFWLENBQW1CLE9BQW5CLENBQWI7QUFDQSxJQUFJLE1BQU0sT0FBTyxLQUFQLENBQWEsTUFBYixDQUFWOztBQUVBLFFBQVEsR0FBUixDQUFZLEdBQVoiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBUb2tlbml6ZXIgZnJvbSAnLi4vLi4vc3JjL3Rva2VuaXplci5qcyc7XG5pbXBvcnQgUGFyc2VyIGZyb20gJy4uLy4uL3NyYy9wYXJzZXIuanMnO1xuXG5sZXQgY29udGVudCA9IGBcbi51LWJ0biB7XG4gICAgYmFja2dyb3VuZDogcmVkO1xufVxuYDtcbmxldCBjb250ZW50MiA9ICckdGVzdCA9ICRhYmM7ICR0ZXN0ID0gNHB4Oyc7XG5sZXQgY29udGVudDMgPSBgXG4udS1idG4sIC50ZXN0IHt9XG5gO1xuXG5sZXQgdG9rZW5pemVyID0gbmV3IFRva2VuaXplcigpO1xubGV0IHBhcnNlciA9IG5ldyBQYXJzZXIoKTtcblxubGV0IHRva2VucyA9IHRva2VuaXplci50b2tlbml6ZShjb250ZW50KTtcbmxldCBhc3QgPSBwYXJzZXIucGFyc2UodG9rZW5zKTtcblxuY29uc29sZS5sb2coYXN0KTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vdGVzdC9zcGVjcy9wYXJzZXIuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _util = __webpack_require__(2);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// >>>>>> 待优化\n// the more fast version\n// let toAssert2 = util.makePredicate;\n\nvar isUnit = (0, _util.toAssert)('% em ex ch rem vw vh vmin vmax cm mm in pt pc px deg grad rad turn s ms Hz kHz dpi dpcm dppx');\n// let isPseudoClass = toAssert2([\"dir\",\"lang\",\"any-link\", \"link\", \"visited\", \"local-link\",\"target\", \"scope\", \"current\", \"past\", \"future\", \"active\", \"hover\", \"focus\", \"active-drop\", \"valid-drop\", \"invalid-drop\", \"enabled\", \"disabled\", \"enabled\", \"disabled\", \"read-only\", \"read-write\", \"placeholder-shown\", \"default\", \"checked\", \"indeterminate\", \"valid\", \"invalid\", \"in-range\", \"out-of-range\", \"required\", \"optional\", \"root\", \"empty\", \"blank\", \"nth-child\", \"nth-last-child\", \"first-child\", \"last-child\", \"only-child\", \"nth-of-type\", \"nth-last-of-type\", \"first-of-type\", \"last-of-type\", \"only-of-type\", \"nth-match\", \"nth-last-match\", 'nth-column', 'nth-last-column', 'not', 'matches', 'before', 'after', '-moz-placeholder']);\n// let isBifs = toAssert2(bifs.concat(['rgb', 'rgba', 'url', 'counter', 'attr', 'calc', 'min', 'max', 'cycle', 'linear-gradient', 'radial-gradient', 'repeating-linear-gradient', 'repeating-radial-gradient']), true);\nvar isPseudoClassWithParen = (0, _util.toAssert)('current local-link nth-child nth-last-child nth-of-type nth-last-of-type nth-match nth-last-match column nth-column nth-last-column lang matches not');\n\n// [W3C]: http://dev.w3.org/csswg/css-syntax/\nvar MAX_ALLOWED_CODEPOINT = parseInt('10FFFF', 16); // [W3C#maximum-allowed-codepoint]\nvar REPLACEMENT_CHARACTER = parseInt('FFFD', 16);\n\n// Token Types\n// ===========================================\n// >>>>>> 什么意思\n// // inspectToken, get tokenName with TokenType(uid)\n// tokenizer.inspect = function(tokenType){\n//     let typeType = tokenType.type || tokenType;\n//     for(let i in tokenizer){\n//         if(typeof tokenizer[i] === 'number' && tokenizer[i] === tokenType) return i;\n//     }\n// }\n\n(0, _util.$)('nl', /\\r\\n|[\\r\\f\\n]/); // newline\n(0, _util.$)('w', /[ \\t\\r\\n\\f]/); // whitespace\n(0, _util.$)('d', /[0-9]/); // digital\n(0, _util.$)('escape', /\\\\[0-9a-f]{1,6}/); // escape char\n(0, _util.$)('nmchar', /[_-\\w\\u00A1-\\uFFFF]|{escape}/);\n(0, _util.$)('nmstart', /[_a-zA-Z\\u00A1-\\uFFFF]|{escape}/);\n(0, _util.$)('ident', /-?{nmstart}{nmchar}*/);\n\n// registed macros\n// =====================\nvar $rules = [{ // multiline comment | singleline comment\n    regexp: /\\/\\*([^\\x00]+?)\\*\\/|\\/\\/([^\\n\\r]*)/,\n    action: function action(yytext, mcomment, scomment) {\n        var isSingle = mcomment === undefined;\n        // >>>>>> ? 这个方法是怎么用的\n        this.options.comment && this.options.comment({\n            type: isSingle ? 'singleline' : 'multiline',\n            content: isSingle ? scomment : mcomment\n        });\n    }\n}, { // url [W3C]\n    regexp: (0, _util.$)(/(url|url\\-prefix|domain|regexp){w}*\\((['\"])?{w}*([^\\r\\n\\f]*?)\\2{w}*\\)/),\n    action: function action(yytext, name, quote, url) {\n        if (name === 'url') return { type: 'URL', value: url };else return { type: 'FUNCTION', value: name, args: [{ type: 'STRING', value: url }] };\n    }\n}, { // function [W3C]\n    regexp: (0, _util.$)(/(?:\\$?-?[_A-Za-z][-_\\w]*)(?=\\()/),\n    action: function action(value) {\n        return { type: 'FUNCTION', value: value };\n    }\n}, { // $variable\n    regexp: /\\$(-?[_A-Za-z][-_\\w]*)/,\n    action: function action(yytext, value) {\n        return { type: 'VAR', value: value };\n    }\n}, { // ident [W3C], 即 -o-webkit-xx 是允许的\n    regexp: (0, _util.$)(/{ident}/),\n    action: function action(value) {\n        if (value === 'false' || value === 'true') return { type: 'BOOLEAN', value: value === 'true' };else if (value === 'null') return { type: 'NULL', value: null };else return { type: 'TEXT', value: value };\n    }\n},\n// {    // @css at-rule no parse\n//     reg: /@css{w}*{/,\n//     action(yytext) {\n//     }\n// },\n{ // dimension: number + unit\n    regexp: (0, _util.$)(/(-?(?:{d}*\\.{d}+|{d}+))(\\w*|%)?/),\n    action: function action(yytext, value, unit) {\n        if (unit && !isUnit(unit)) this.error('Unexcept unit: \"' + unit + '\"');\n        return { type: 'DIMENSION', value: +value, unit: unit };\n    }\n}, { // class\n    regexp: (0, _util.$)(/\\.({nmchar}+)/),\n    action: function action(value) {\n        return { type: 'CLASS', value: value };\n    }\n}, { // at-keyword, @\n    regexp: /@(-?[_A-Za-z][-_\\w]*)/,\n    action: function action(yytext, value) {\n        return { type: 'AT_KEYWORD', value: value };\n    }\n}, { // !important\n    regexp: (0, _util.$)(/!{w}*important/),\n    action: function action(yytext) {\n        return { type: 'IMPORTANT' };\n    }\n}, { // pesudo-class\n    regexp: (0, _util.$)(':([-_a-zA-Z]+)' + // 伪类名\n    '(?:\\\\(' + // 括号开始\n    '([^\\\\(\\\\)]*' + // 第一种无括号\n    '|(?:' + // 有括号(即伪类中仍有伪类并且是带括号的)\n    '\\\\([^\\\\)]+\\\\)' + // 括号部分\n    /*'|[^\\\\(\\\\)]*' +*/')+)' + // 关闭有括号\n    '\\\\))'),\n    action: function action(yytext, value) {\n        // >>>>>> ?什么意思\n        // false 使用其它方式再token一次\n        if (!yytext.includes('(') && !isPseudoClassWithParen(value)) return null;\n\n        return { type: 'PSEUDO_CLASS', value: yytext };\n    }\n}, { // pesudo-element\n    regexp: (0, _util.$)('::({nmchar}+)'),\n    action: function action(value) {\n        return { type: 'PSEUDO_ELEMENT', value: value };\n    }\n}, { // attribute, [title=haha]\n    regexp: (0, _util.$)('\\\\[\\\\s*(?:{nmchar}+)\\\\s*(?:([*^$|~!]?=)\\\\s*[\\'\\\"]?(?:[^\\'\\\"\\\\[]*)[\\'\\\"]?)?\\\\s*\\\\]'),\n    action: function action(value) {\n        return { type: 'ATTRIBUTE', value: value };\n    }\n}, { // #hash\n    regexp: (0, _util.$)(/#{nmchar}+/),\n    action: function action(value) {\n        return { type: 'HASH', value: value };\n    }\n}, { // string\n    regexp: /(['\"])([^\\r\\n\\f]*?)\\1/,\n    action: function action(yytext, quote) {\n        var value = arguments.length <= 2 || arguments[2] === undefined ? '' : arguments[2];\n\n        return { type: 'STRING', value: value };\n    }\n}, { // punctuator can ignore 'WS'\n    regexp: (0, _util.$)(/{w}*(&&|\\|\\||[\\*\\$\\^~\\|>=<!?]?=|\\.\\.\\.|[\\{;,><]){w}*/),\n    action: function action(yytext, value) {\n        return { type: value };\n        // return {type: 'PUNCTUATOR', value};\n    }\n}, { // whitespace\n    regexp: (0, _util.$)('WS', /{w}+/),\n    action: function action(value) {\n        return { type: 'WS', value: value };\n    }\n}, {\n    // punctuator | operator | logic | other\n    // .. ::\n    // []{}() ; , : & #\n    // ->\n    // *= // $= // ^= ~= |=\n    // >= <= == != =\n    // < > / * + -\n    // ..  or .\n    regexp: /($|#\\{|:|::|[~!#()\\[\\]&\\.]|[\\}%\\-+*\\/])/,\n    action: function action(value) {\n        return { type: value ? value : 'EOF' };\n    }\n}, { // convert escaped unicode to TEXT\n    regexp: (0, _util.$)(/\\\\([0-9a-fA-F]{1,6})/),\n    action: function action(yytext, value) {\n        var hex = parseInt(value, 16);\n        if (hex > MAX_ALLOWED_CODEPOINT) hex = '�';\n        hex = '\\\\' + hex.toString(16);\n        return { type: 'TEXT', value: hex };\n    }\n}];\n\n$rules.forEach(function (rule) {\n    var reg = typeof rule.regexp !== 'string' ? String(rule.regexp).slice(1, -1) : rule.regexp;\n    if (!reg.startsWith('^(?')) rule.regexp = new RegExp('^(?:' + reg + ')');\n});\n\n/**\n * Tokenizer Class\n * @param {object}  options\n * @param {boolean} ignoreComment\n */\n\nvar Tokenizer = function () {\n    function Tokenizer() {\n        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n        _classCallCheck(this, Tokenizer);\n\n        this.options = options;\n        this.options.ignoreComment = true;\n    }\n\n    _createClass(Tokenizer, [{\n        key: 'tokenize',\n        value: function tokenize() {\n            var input = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];\n\n            // simplify newline token detect\n            this.input = input;\n            // remained input\n            this.remained = input;\n            this.lineno = 1;\n            this.states = ['init'];\n            this.state = 'init';\n            return this.pump();\n        }\n\n        // 一次性输出所有tokens\n\n    }, {\n        key: 'pump',\n        value: function pump() {\n            var tokens = [];\n            var token = void 0;\n            while (token = this.lex()) {\n                tokens.push(token);\n                if (token.type === 'EOF') break;\n            }\n            return tokens;\n        }\n\n        // >>>>>> 一定会有跳过的问题吗？\n        // 依赖next\n\n    }, {\n        key: 'lex',\n        value: function lex() {\n            var token = this.next();\n            return token ? token : this.lex(); // >>>>>> undefined;\n        }\n    }, {\n        key: 'next',\n        value: function next() {\n            var tmp = void 0,\n                token = void 0;\n\n            for (var i = 0; i < $rules.length; i++) {\n                var rule = $rules[i]; //[link[i]];\n                // 匹配\n                tmp = this.remained.match(rule.regexp);\n                if (!tmp) continue;\n                // 生成token\n                token = rule.action.apply(this, tmp);\n                if (token) break;\n            }\n\n            if (tmp && token) {\n                var lines = tmp[0].match(/(?:\\r\\n|[\\n\\r\\f]).*/g);\n                if (lines) this.lineno += lines.length;\n                token.lineno = this.lineno;\n                this.remained = this.remained.slice(tmp[0].length);\n                if (token.type === 'WS') {\n                    if (this._preIsWS) token = undefined;\n                    this._preIsWS = true;\n                } else this._preIsWS = false;\n                return token;\n            } else this.error('Unexpect token start');\n        }\n    }, {\n        key: 'pushState',\n        value: function pushState(condition) {\n            this.states.push(condition);\n            this.state = condition;\n        }\n    }, {\n        key: 'popState',\n        value: function popState() {\n            this.states.pop();\n            this.state = this.states[this.states.length - 1];\n        }\n    }, {\n        key: 'error',\n        value: function (_error) {\n            function error(_x2) {\n                return _error.apply(this, arguments);\n            }\n\n            error.toString = function () {\n                return _error.toString();\n            };\n\n            return error;\n        }(function (message) {\n            var err = new error.SyntaxError(message, this.lineno, this.options);\n            err.column = this._getColumn();\n            throw err;\n        })\n    }, {\n        key: '_getColumn',\n        value: function _getColumn() {\n            var newline = /^[\\n\\f\\r]/;\n            var n = this.input.length - this.remained.length;\n            var column = 0;\n            for (; n--;) {\n                if (newline.test(this.input.charAt(n)) && n >= 0) break;\n                column++;\n            }\n        }\n\n        // _traceError: function(message){\n        //     let matchLength = this.length - this.remained.length;\n        //     let offset = matchLength - 10;\n        //     if(offset < 0) offset = 0;\n        //     let pointer = matchLength - offset;\n        //     let posMessage = this.input.slice(offset, offset + 20)\n        //     // TODO: 加上trace info\n        //     return 'Error on line ' + (this.lineno + 1) + \" \" +\n        //         (message || '. Unrecognized input.') + \"\\n\" + (offset === 0? '':'...') +\n        //         posMessage + \"...\\n\" + new Array(pointer + (offset === 0? 0 : 3) ).join(' ') + new Array(10).join(\"^\");\n        // }\n\n    }]);\n\n    return Tokenizer;\n}();\n\nexports.default = Tokenizer;//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdG9rZW5pemVyLmpzPzg2NTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7QUFNQSxJQUFJLFNBQVMsb0JBQVMsOEZBQVQsQ0FBYjs7O0FBR0EsSUFBSSx5QkFBeUIsb0JBQVMsc0pBQVQsQ0FBN0I7OztBQUdBLElBQU0sd0JBQXdCLFNBQVMsUUFBVCxFQUFrQixFQUFsQixDQUE5QixDO0FBQ0EsSUFBTSx3QkFBd0IsU0FBUyxNQUFULEVBQWlCLEVBQWpCLENBQTlCOzs7Ozs7Ozs7Ozs7O0FBYUEsYUFBRSxJQUFGLEVBQVEsZUFBUixFO0FBQ0EsYUFBRSxHQUFGLEVBQU8sYUFBUCxFO0FBQ0EsYUFBRSxHQUFGLEVBQU8sT0FBUCxFO0FBQ0EsYUFBRSxRQUFGLEVBQVksaUJBQVosRTtBQUNBLGFBQUUsUUFBRixFQUFZLDhCQUFaO0FBQ0EsYUFBRSxTQUFGLEVBQVksaUNBQVo7QUFDQSxhQUFFLE9BQUYsRUFBVyxzQkFBWDs7OztBQUlBLElBQUksU0FBUyxDQUNULEU7QUFDSSxZQUFRLG9DQURaO0FBRUksVUFGSixrQkFFVyxNQUZYLEVBRW1CLFFBRm5CLEVBRTZCLFFBRjdCLEVBRXVDO0FBQy9CLFlBQUksV0FBVyxhQUFhLFNBQTVCOztBQUVBLGFBQUssT0FBTCxDQUFhLE9BQWIsSUFBd0IsS0FBSyxPQUFMLENBQWEsT0FBYixDQUFxQjtBQUN6QyxrQkFBTSxXQUFXLFlBQVgsR0FBeUIsV0FEVTtBQUV6QyxxQkFBUyxXQUFXLFFBQVgsR0FBc0I7QUFGVSxTQUFyQixDQUF4QjtBQUlIO0FBVEwsQ0FEUyxFQVdOLEU7QUFDQyxZQUFRLGFBQUUsdUVBQUYsQ0FEVDtBQUVDLFVBRkQsa0JBRVEsTUFGUixFQUVnQixJQUZoQixFQUV1QixLQUZ2QixFQUU4QixHQUY5QixFQUVtQztBQUM5QixZQUFHLFNBQVMsS0FBWixFQUNJLE9BQU8sRUFBQyxNQUFNLEtBQVAsRUFBYyxPQUFPLEdBQXJCLEVBQVAs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QVM7QUFDWCxnQkFBSSxNQUFNLElBQUksTUFBTSxXQUFWLENBQXNCLE9BQXRCLEVBQStCLEtBQUssTUFBcEMsRUFBNEMsS0FBSyxPQUFqRCxDQUFWO0FBQ0EsZ0JBQUksTUFBSixHQUFhLEtBQUssVUFBTCxFQUFiO0FBQ0Esa0JBQU0sR0FBTjtBQUNILFM7OztxQ0FFWTtBQUNULGdCQUFNLFVBQVUsV0FBaEI7QUFDQSxnQkFBSSxJQUFJLEtBQUssS0FBTCxDQUFXLE1BQVgsR0FBb0IsS0FBSyxRQUFMLENBQWMsTUFBMUM7QUFDQSxnQkFBSSxTQUFTLENBQWI7QUFDQSxtQkFBTSxHQUFOLEdBQVk7QUFDUixvQkFBRyxRQUFRLElBQVIsQ0FBYSxLQUFLLEtBQUwsQ0FBVyxNQUFYLENBQWtCLENBQWxCLENBQWIsS0FBc0MsS0FBSyxDQUE5QyxFQUNJO0FBQ0o7QUFDSDtBQUNKOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tCQWVVLFMiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7JCwgdG9Bc3NlcnR9IGZyb20gJy4vaGVscGVyL3V0aWwuanMnO1xuXG4vLyA+Pj4+Pj4g5b6F5LyY5YyWXG4vLyB0aGUgbW9yZSBmYXN0IHZlcnNpb25cbi8vIGxldCB0b0Fzc2VydDIgPSB1dGlsLm1ha2VQcmVkaWNhdGU7XG5cbmxldCBpc1VuaXQgPSB0b0Fzc2VydCgnJSBlbSBleCBjaCByZW0gdncgdmggdm1pbiB2bWF4IGNtIG1tIGluIHB0IHBjIHB4IGRlZyBncmFkIHJhZCB0dXJuIHMgbXMgSHoga0h6IGRwaSBkcGNtIGRwcHgnKTtcbi8vIGxldCBpc1BzZXVkb0NsYXNzID0gdG9Bc3NlcnQyKFtcImRpclwiLFwibGFuZ1wiLFwiYW55LWxpbmtcIiwgXCJsaW5rXCIsIFwidmlzaXRlZFwiLCBcImxvY2FsLWxpbmtcIixcInRhcmdldFwiLCBcInNjb3BlXCIsIFwiY3VycmVudFwiLCBcInBhc3RcIiwgXCJmdXR1cmVcIiwgXCJhY3RpdmVcIiwgXCJob3ZlclwiLCBcImZvY3VzXCIsIFwiYWN0aXZlLWRyb3BcIiwgXCJ2YWxpZC1kcm9wXCIsIFwiaW52YWxpZC1kcm9wXCIsIFwiZW5hYmxlZFwiLCBcImRpc2FibGVkXCIsIFwiZW5hYmxlZFwiLCBcImRpc2FibGVkXCIsIFwicmVhZC1vbmx5XCIsIFwicmVhZC13cml0ZVwiLCBcInBsYWNlaG9sZGVyLXNob3duXCIsIFwiZGVmYXVsdFwiLCBcImNoZWNrZWRcIiwgXCJpbmRldGVybWluYXRlXCIsIFwidmFsaWRcIiwgXCJpbnZhbGlkXCIsIFwiaW4tcmFuZ2VcIiwgXCJvdXQtb2YtcmFuZ2VcIiwgXCJyZXF1aXJlZFwiLCBcIm9wdGlvbmFsXCIsIFwicm9vdFwiLCBcImVtcHR5XCIsIFwiYmxhbmtcIiwgXCJudGgtY2hpbGRcIiwgXCJudGgtbGFzdC1jaGlsZFwiLCBcImZpcnN0LWNoaWxkXCIsIFwibGFzdC1jaGlsZFwiLCBcIm9ubHktY2hpbGRcIiwgXCJudGgtb2YtdHlwZVwiLCBcIm50aC1sYXN0LW9mLXR5cGVcIiwgXCJmaXJzdC1vZi10eXBlXCIsIFwibGFzdC1vZi10eXBlXCIsIFwib25seS1vZi10eXBlXCIsIFwibnRoLW1hdGNoXCIsIFwibnRoLWxhc3QtbWF0Y2hcIiwgJ250aC1jb2x1bW4nLCAnbnRoLWxhc3QtY29sdW1uJywgJ25vdCcsICdtYXRjaGVzJywgJ2JlZm9yZScsICdhZnRlcicsICctbW96LXBsYWNlaG9sZGVyJ10pO1xuLy8gbGV0IGlzQmlmcyA9IHRvQXNzZXJ0MihiaWZzLmNvbmNhdChbJ3JnYicsICdyZ2JhJywgJ3VybCcsICdjb3VudGVyJywgJ2F0dHInLCAnY2FsYycsICdtaW4nLCAnbWF4JywgJ2N5Y2xlJywgJ2xpbmVhci1ncmFkaWVudCcsICdyYWRpYWwtZ3JhZGllbnQnLCAncmVwZWF0aW5nLWxpbmVhci1ncmFkaWVudCcsICdyZXBlYXRpbmctcmFkaWFsLWdyYWRpZW50J10pLCB0cnVlKTtcbmxldCBpc1BzZXVkb0NsYXNzV2l0aFBhcmVuID0gdG9Bc3NlcnQoJ2N1cnJlbnQgbG9jYWwtbGluayBudGgtY2hpbGQgbnRoLWxhc3QtY2hpbGQgbnRoLW9mLXR5cGUgbnRoLWxhc3Qtb2YtdHlwZSBudGgtbWF0Y2ggbnRoLWxhc3QtbWF0Y2ggY29sdW1uIG50aC1jb2x1bW4gbnRoLWxhc3QtY29sdW1uIGxhbmcgbWF0Y2hlcyBub3QnKTtcblxuLy8gW1czQ106IGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy1zeW50YXgvXG5jb25zdCBNQVhfQUxMT1dFRF9DT0RFUE9JTlQgPSBwYXJzZUludCgnMTBGRkZGJywxNik7ICAgIC8vIFtXM0MjbWF4aW11bS1hbGxvd2VkLWNvZGVwb2ludF1cbmNvbnN0IFJFUExBQ0VNRU5UX0NIQVJBQ1RFUiA9IHBhcnNlSW50KCdGRkZEJywgMTYpO1xuXG4vLyBUb2tlbiBUeXBlc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPj4+Pj4+IOS7gOS5iOaEj+aAnVxuLy8gLy8gaW5zcGVjdFRva2VuLCBnZXQgdG9rZW5OYW1lIHdpdGggVG9rZW5UeXBlKHVpZClcbi8vIHRva2VuaXplci5pbnNwZWN0ID0gZnVuY3Rpb24odG9rZW5UeXBlKXtcbi8vICAgICBsZXQgdHlwZVR5cGUgPSB0b2tlblR5cGUudHlwZSB8fCB0b2tlblR5cGU7XG4vLyAgICAgZm9yKGxldCBpIGluIHRva2VuaXplcil7XG4vLyAgICAgICAgIGlmKHR5cGVvZiB0b2tlbml6ZXJbaV0gPT09ICdudW1iZXInICYmIHRva2VuaXplcltpXSA9PT0gdG9rZW5UeXBlKSByZXR1cm4gaTtcbi8vICAgICB9XG4vLyB9XG5cbiQoJ25sJywgL1xcclxcbnxbXFxyXFxmXFxuXS8pOyAgICAvLyBuZXdsaW5lXG4kKCd3JywgL1sgXFx0XFxyXFxuXFxmXS8pOyAgICAvLyB3aGl0ZXNwYWNlXG4kKCdkJywgL1swLTldLyk7ICAgIC8vIGRpZ2l0YWxcbiQoJ2VzY2FwZScsIC9cXFxcWzAtOWEtZl17MSw2fS8pOyAgICAgLy8gZXNjYXBlIGNoYXJcbiQoJ25tY2hhcicsIC9bXy1cXHdcXHUwMEExLVxcdUZGRkZdfHtlc2NhcGV9Lyk7XG4kKCdubXN0YXJ0JywvW19hLXpBLVpcXHUwMEExLVxcdUZGRkZdfHtlc2NhcGV9LyApO1xuJCgnaWRlbnQnLCAvLT97bm1zdGFydH17bm1jaGFyfSovKTtcblxuLy8gcmVnaXN0ZWQgbWFjcm9zXG4vLyA9PT09PT09PT09PT09PT09PT09PT1cbmxldCAkcnVsZXMgPSBbXG4gICAgeyAgICAgICAvLyBtdWx0aWxpbmUgY29tbWVudCB8IHNpbmdsZWxpbmUgY29tbWVudFxuICAgICAgICByZWdleHA6IC9cXC9cXCooW15cXHgwMF0rPylcXCpcXC98XFwvXFwvKFteXFxuXFxyXSopLyxcbiAgICAgICAgYWN0aW9uKHl5dGV4dCwgbWNvbW1lbnQsIHNjb21tZW50KSB7XG4gICAgICAgICAgICBsZXQgaXNTaW5nbGUgPSBtY29tbWVudCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgLy8gPj4+Pj4+ID8g6L+Z5Liq5pa55rOV5piv5oCO5LmI55So55qEXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuY29tbWVudCAmJiB0aGlzLm9wdGlvbnMuY29tbWVudCh7XG4gICAgICAgICAgICAgICAgdHlwZTogaXNTaW5nbGUgPyAnc2luZ2xlbGluZSc6ICdtdWx0aWxpbmUnLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGlzU2luZ2xlID8gc2NvbW1lbnQgOiBtY29tbWVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCB7ICAgIC8vIHVybCBbVzNDXVxuICAgICAgICByZWdleHA6ICQoLyh1cmx8dXJsXFwtcHJlZml4fGRvbWFpbnxyZWdleHApe3d9KlxcKChbJ1wiXSk/e3d9KihbXlxcclxcblxcZl0qPylcXDJ7d30qXFwpLyksXG4gICAgICAgIGFjdGlvbih5eXRleHQsIG5hbWUgLCBxdW90ZSwgdXJsKSB7XG4gICAgICAgICAgICBpZihuYW1lID09PSAndXJsJylcbiAgICAgICAgICAgICAgICByZXR1cm4ge3R5cGU6ICdVUkwnLCB2YWx1ZTogdXJsfTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4ge3R5cGU6ICdGVU5DVElPTicsIHZhbHVlOiBuYW1lLCBhcmdzOiBbeyB0eXBlOiAnU1RSSU5HJywgdmFsdWU6IHVybCB9XX07XG4gICAgICAgIH1cbiAgICB9LCB7ICAgLy8gZnVuY3Rpb24gW1czQ11cbiAgICAgICAgcmVnZXhwOiAkKC8oPzpcXCQ/LT9bX0EtWmEtel1bLV9cXHddKikoPz1cXCgpLyksXG4gICAgICAgIGFjdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiAnRlVOQ1RJT04nLCB2YWx1ZX07XG4gICAgICAgIH1cbiAgICB9LCB7ICAgIC8vICR2YXJpYWJsZVxuICAgICAgICByZWdleHA6IC9cXCQoLT9bX0EtWmEtel1bLV9cXHddKikvLFxuICAgICAgICBhY3Rpb24oeXl0ZXh0LCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiAnVkFSJywgdmFsdWV9O1xuICAgICAgICB9XG4gICAgfSwgeyAgICAvLyBpZGVudCBbVzNDXSwg5Y2zIC1vLXdlYmtpdC14eCDmmK/lhYHorrjnmoRcbiAgICAgICAgcmVnZXhwOiAkKC97aWRlbnR9LyksXG4gICAgICAgIGFjdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaWYodmFsdWUgPT09ICdmYWxzZScgfHwgdmFsdWUgPT09ICd0cnVlJylcbiAgICAgICAgICAgICAgICByZXR1cm4ge3R5cGU6ICdCT09MRUFOJywgdmFsdWU6IHZhbHVlID09PSAndHJ1ZSd9O1xuICAgICAgICAgICAgZWxzZSBpZih2YWx1ZSA9PT0gJ251bGwnKVxuICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogJ05VTEwnLCB2YWx1ZTogbnVsbH07XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiAnVEVYVCcsIHZhbHVlfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy8geyAgICAvLyBAY3NzIGF0LXJ1bGUgbm8gcGFyc2VcbiAgICAvLyAgICAgcmVnOiAvQGNzc3t3fSp7LyxcbiAgICAvLyAgICAgYWN0aW9uKHl5dGV4dCkge1xuICAgIC8vICAgICB9XG4gICAgLy8gfSxcbiAgICB7ICAgICAgIC8vIGRpbWVuc2lvbjogbnVtYmVyICsgdW5pdFxuICAgICAgICByZWdleHA6ICQoLygtPyg/OntkfSpcXC57ZH0rfHtkfSspKShcXHcqfCUpPy8pLFxuICAgICAgICBhY3Rpb24oeXl0ZXh0LCB2YWx1ZSwgdW5pdCkge1xuICAgICAgICAgICAgaWYodW5pdCAmJiAhaXNVbml0KHVuaXQpKVxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoJ1VuZXhjZXB0IHVuaXQ6IFwiJyArIHVuaXQgKyAnXCInKTtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogJ0RJTUVOU0lPTicsIHZhbHVlOiArdmFsdWUsIHVuaXR9O1xuICAgICAgICB9XG4gICAgfSwgeyAgICAvLyBjbGFzc1xuICAgICAgICByZWdleHA6ICQoL1xcLih7bm1jaGFyfSspLyksXG4gICAgICAgIGFjdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiAnQ0xBU1MnLCB2YWx1ZX07XG4gICAgICAgIH1cbiAgICB9LCB7ICAgIC8vIGF0LWtleXdvcmQsIEBcbiAgICAgICAgcmVnZXhwOiAvQCgtP1tfQS1aYS16XVstX1xcd10qKS8sXG4gICAgICAgIGFjdGlvbih5eXRleHQsIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6ICdBVF9LRVlXT1JEJywgdmFsdWV9O1xuICAgICAgICB9XG4gICAgfSwgeyAgICAvLyAhaW1wb3J0YW50XG4gICAgICAgIHJlZ2V4cDogJCgvIXt3fSppbXBvcnRhbnQvKSxcbiAgICAgICAgYWN0aW9uKHl5dGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiAnSU1QT1JUQU5UJ307XG4gICAgICAgIH1cbiAgICB9LCB7ICAgIC8vIHBlc3Vkby1jbGFzc1xuICAgICAgICByZWdleHA6ICQoJzooWy1fYS16QS1aXSspJyArIC8vIOS8quexu+WQjVxuICAgICAgICAgICAgJyg/OlxcXFwoJyArIC8vIOaLrOWPt+W8gOWni1xuICAgICAgICAgICAgJyhbXlxcXFwoXFxcXCldKicgKyAvLyDnrKzkuIDnp43ml6Dmi6zlj7dcbiAgICAgICAgICAgICd8KD86JyArIC8vIOacieaLrOWPtyjljbPkvKrnsbvkuK3ku43mnInkvKrnsbvlubbkuJTmmK/luKbmi6zlj7fnmoQpXG4gICAgICAgICAgICAnXFxcXChbXlxcXFwpXStcXFxcKScgKyAvLyDmi6zlj7fpg6jliIZcbiAgICAgICAgICAgIC8qJ3xbXlxcXFwoXFxcXCldKicgKyovICcpKyknICsgLy8g5YWz6Zet5pyJ5ous5Y+3XG4gICAgICAgICAgICAnXFxcXCkpJyksXG4gICAgICAgIGFjdGlvbih5eXRleHQsIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyA+Pj4+Pj4gP+S7gOS5iOaEj+aAnVxuICAgICAgICAgICAgLy8gZmFsc2Ug5L2/55So5YW25a6D5pa55byP5YaNdG9rZW7kuIDmrKFcbiAgICAgICAgICAgIGlmKCF5eXRleHQuaW5jbHVkZXMoJygnKSAmJiAhaXNQc2V1ZG9DbGFzc1dpdGhQYXJlbih2YWx1ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogJ1BTRVVET19DTEFTUycgLCB2YWx1ZTogeXl0ZXh0fTtcbiAgICAgICAgfVxuICAgIH0sIHsgICAgLy8gcGVzdWRvLWVsZW1lbnRcbiAgICAgICAgcmVnZXhwOiAkKCc6Oih7bm1jaGFyfSspJyksXG4gICAgICAgIGFjdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiAnUFNFVURPX0VMRU1FTlQnLCB2YWx1ZX07XG4gICAgICAgIH1cbiAgICB9LCB7ICAgIC8vIGF0dHJpYnV0ZSwgW3RpdGxlPWhhaGFdXG4gICAgICAgIHJlZ2V4cDogJCgnXFxcXFtcXFxccyooPzp7bm1jaGFyfSspXFxcXHMqKD86KFsqXiR8fiFdPz0pXFxcXHMqW1xcJ1xcXCJdPyg/OlteXFwnXFxcIlxcXFxbXSopW1xcJ1xcXCJdPyk/XFxcXHMqXFxcXF0nKSxcbiAgICAgICAgYWN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6ICdBVFRSSUJVVEUnLCB2YWx1ZX07XG4gICAgICAgIH1cbiAgICB9LCB7ICAgIC8vICNoYXNoXG4gICAgICAgIHJlZ2V4cDogJCgvI3tubWNoYXJ9Ky8pLFxuICAgICAgICBhY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogJ0hBU0gnLCB2YWx1ZX07XG4gICAgICAgIH1cbiAgICB9LCB7ICAgIC8vIHN0cmluZ1xuICAgICAgICByZWdleHA6IC8oWydcIl0pKFteXFxyXFxuXFxmXSo/KVxcMS8sXG4gICAgICAgIGFjdGlvbih5eXRleHQsIHF1b3RlLCB2YWx1ZSA9ICcnKXtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogJ1NUUklORycsIHZhbHVlfTtcbiAgICAgICAgfVxuICAgIH0sIHsgICAgLy8gcHVuY3R1YXRvciBjYW4gaWdub3JlICdXUydcbiAgICAgICAgcmVnZXhwOiAkKC97d30qKCYmfFxcfFxcfHxbXFwqXFwkXFxeflxcfD49PCE/XT89fFxcLlxcLlxcLnxbXFx7Oyw+PF0pe3d9Ki8pLFxuICAgICAgICBhY3Rpb24oeXl0ZXh0LCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiB2YWx1ZX07XG4gICAgICAgICAgICAvLyByZXR1cm4ge3R5cGU6ICdQVU5DVFVBVE9SJywgdmFsdWV9O1xuICAgICAgICB9XG4gICAgfSwgeyAgICAvLyB3aGl0ZXNwYWNlXG4gICAgICAgIHJlZ2V4cDogJCgnV1MnLCAve3d9Ky8pLFxuICAgICAgICBhY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogJ1dTJywgdmFsdWV9O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICAvLyBwdW5jdHVhdG9yIHwgb3BlcmF0b3IgfCBsb2dpYyB8IG90aGVyXG4gICAgICAgIC8vIC4uIDo6XG4gICAgICAgIC8vIFtde30oKSA7ICwgOiAmICNcbiAgICAgICAgLy8gLT5cbiAgICAgICAgLy8gKj0gLy8gJD0gLy8gXj0gfj0gfD1cbiAgICAgICAgLy8gPj0gPD0gPT0gIT0gPVxuICAgICAgICAvLyA8ID4gLyAqICsgLVxuICAgICAgICAvLyAuLiAgb3IgLlxuICAgICAgICByZWdleHA6IC8oJHwjXFx7fDp8Ojp8W34hIygpXFxbXFxdJlxcLl18W1xcfSVcXC0rKlxcL10pLyxcbiAgICAgICAgYWN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4ge3R5cGU6IHZhbHVlID8gdmFsdWUgOiAnRU9GJ307XG4gICAgICAgIH1cbiAgICB9LCB7ICAgIC8vIGNvbnZlcnQgZXNjYXBlZCB1bmljb2RlIHRvIFRFWFRcbiAgICAgICAgcmVnZXhwOiAkKC9cXFxcKFswLTlhLWZBLUZdezEsNn0pLyksXG4gICAgICAgIGFjdGlvbih5eXRleHQsIHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgaGV4ID0gcGFyc2VJbnQodmFsdWUsIDE2KTtcbiAgICAgICAgICAgIGlmKGhleCA+IE1BWF9BTExPV0VEX0NPREVQT0lOVClcbiAgICAgICAgICAgICAgICBoZXggPSAnXFx1RkZGRCc7XG4gICAgICAgICAgICBoZXggPSAnXFxcXCcgKyBoZXgudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiAnVEVYVCcsIHZhbHVlOiBoZXh9O1xuICAgICAgICB9XG4gICAgfVxuXTtcblxuJHJ1bGVzLmZvckVhY2goKHJ1bGUpID0+IHtcbiAgICBsZXQgcmVnID0gdHlwZW9mIHJ1bGUucmVnZXhwICE9PSAnc3RyaW5nJyA/IFN0cmluZyhydWxlLnJlZ2V4cCkuc2xpY2UoMSwgLTEpIDogcnVsZS5yZWdleHA7XG4gICAgaWYoIXJlZy5zdGFydHNXaXRoKCdeKD8nKSlcbiAgICAgICAgcnVsZS5yZWdleHAgPSBuZXcgUmVnRXhwKCdeKD86JyArIHJlZyArICcpJyk7XG59KTtcblxuLyoqXG4gKiBUb2tlbml6ZXIgQ2xhc3NcbiAqIEBwYXJhbSB7b2JqZWN0fSAgb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBpZ25vcmVDb21tZW50XG4gKi9cbmNsYXNzIFRva2VuaXplciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMub3B0aW9ucy5pZ25vcmVDb21tZW50ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0b2tlbml6ZShpbnB1dCA9ICcnKSB7XG4gICAgICAgIC8vIHNpbXBsaWZ5IG5ld2xpbmUgdG9rZW4gZGV0ZWN0XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgLy8gcmVtYWluZWQgaW5wdXRcbiAgICAgICAgdGhpcy5yZW1haW5lZCA9IGlucHV0O1xuICAgICAgICB0aGlzLmxpbmVubyA9IDE7XG4gICAgICAgIHRoaXMuc3RhdGVzID0gWydpbml0J107XG4gICAgICAgIHRoaXMuc3RhdGUgPSAnaW5pdCc7XG4gICAgICAgIHJldHVybiB0aGlzLnB1bXAoKTtcbiAgICB9XG5cbiAgICAvLyDkuIDmrKHmgKfovpPlh7rmiYDmnIl0b2tlbnNcbiAgICBwdW1wKCkge1xuICAgICAgICBsZXQgdG9rZW5zID0gW107XG4gICAgICAgIGxldCB0b2tlbjtcbiAgICAgICAgd2hpbGUodG9rZW4gPSB0aGlzLmxleCgpKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICBpZih0b2tlbi50eXBlID09PSAnRU9GJylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cblxuICAgIC8vID4+Pj4+PiDkuIDlrprkvJrmnInot7Pov4fnmoTpl67popjlkJfvvJ9cbiAgICAvLyDkvp3otZZuZXh0XG4gICAgbGV4KCkge1xuICAgICAgICBsZXQgdG9rZW4gPSB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRva2VuID8gdG9rZW4gOiB0aGlzLmxleCgpOyAvLyA+Pj4+Pj4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIG5leHQoKSB7XG4gICAgICAgIGxldCB0bXAsIHRva2VuO1xuXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCAkcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBydWxlID0gJHJ1bGVzW2ldOyAvL1tsaW5rW2ldXTtcbiAgICAgICAgICAgIC8vIOWMuemFjVxuICAgICAgICAgICAgdG1wID0gdGhpcy5yZW1haW5lZC5tYXRjaChydWxlLnJlZ2V4cCk7XG4gICAgICAgICAgICBpZighdG1wKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgLy8g55Sf5oiQdG9rZW5cbiAgICAgICAgICAgIHRva2VuID0gcnVsZS5hY3Rpb24uYXBwbHkodGhpcywgdG1wKTtcbiAgICAgICAgICAgIGlmKHRva2VuKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodG1wICYmIHRva2VuKSB7XG4gICAgICAgICAgICBsZXQgbGluZXMgPSB0bXBbMF0ubWF0Y2goLyg/OlxcclxcbnxbXFxuXFxyXFxmXSkuKi9nKTtcbiAgICAgICAgICAgIGlmKGxpbmVzKVxuICAgICAgICAgICAgICAgIHRoaXMubGluZW5vICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgICAgIHRva2VuLmxpbmVubyA9IHRoaXMubGluZW5vO1xuICAgICAgICAgICAgdGhpcy5yZW1haW5lZCA9IHRoaXMucmVtYWluZWQuc2xpY2UodG1wWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICBpZih0b2tlbi50eXBlID09PSAnV1MnKSB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5fcHJlSXNXUylcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJlSXNXUyA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmVJc1dTID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgdGhpcy5lcnJvcignVW5leHBlY3QgdG9rZW4gc3RhcnQnKTtcbiAgICB9XG5cbiAgICBwdXNoU3RhdGUoY29uZGl0aW9uKSB7XG4gICAgICAgIHRoaXMuc3RhdGVzLnB1c2goY29uZGl0aW9uKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IGNvbmRpdGlvbjtcbiAgICB9XG5cbiAgICBwb3BTdGF0ZSgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZXMucG9wKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlc1t0aGlzLnN0YXRlcy5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICBlcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIGxldCBlcnIgPSBuZXcgZXJyb3IuU3ludGF4RXJyb3IobWVzc2FnZSwgdGhpcy5saW5lbm8sIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIGVyci5jb2x1bW4gPSB0aGlzLl9nZXRDb2x1bW4oKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIF9nZXRDb2x1bW4oKSB7XG4gICAgICAgIGNvbnN0IG5ld2xpbmUgPSAvXltcXG5cXGZcXHJdLztcbiAgICAgICAgbGV0IG4gPSB0aGlzLmlucHV0Lmxlbmd0aCAtIHRoaXMucmVtYWluZWQubGVuZ3RoO1xuICAgICAgICBsZXQgY29sdW1uID0gMDtcbiAgICAgICAgZm9yKDsgbi0tOykge1xuICAgICAgICAgICAgaWYobmV3bGluZS50ZXN0KHRoaXMuaW5wdXQuY2hhckF0KG4pKSAmJiBuID49IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjb2x1bW4rK1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gX3RyYWNlRXJyb3I6IGZ1bmN0aW9uKG1lc3NhZ2Upe1xuICAgIC8vICAgICBsZXQgbWF0Y2hMZW5ndGggPSB0aGlzLmxlbmd0aCAtIHRoaXMucmVtYWluZWQubGVuZ3RoO1xuICAgIC8vICAgICBsZXQgb2Zmc2V0ID0gbWF0Y2hMZW5ndGggLSAxMDtcbiAgICAvLyAgICAgaWYob2Zmc2V0IDwgMCkgb2Zmc2V0ID0gMDtcbiAgICAvLyAgICAgbGV0IHBvaW50ZXIgPSBtYXRjaExlbmd0aCAtIG9mZnNldDtcbiAgICAvLyAgICAgbGV0IHBvc01lc3NhZ2UgPSB0aGlzLmlucHV0LnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgMjApXG4gICAgLy8gICAgIC8vIFRPRE86IOWKoOS4inRyYWNlIGluZm9cbiAgICAvLyAgICAgcmV0dXJuICdFcnJvciBvbiBsaW5lICcgKyAodGhpcy5saW5lbm8gKyAxKSArIFwiIFwiICtcbiAgICAvLyAgICAgICAgIChtZXNzYWdlIHx8ICcuIFVucmVjb2duaXplZCBpbnB1dC4nKSArIFwiXFxuXCIgKyAob2Zmc2V0ID09PSAwPyAnJzonLi4uJykgK1xuICAgIC8vICAgICAgICAgcG9zTWVzc2FnZSArIFwiLi4uXFxuXCIgKyBuZXcgQXJyYXkocG9pbnRlciArIChvZmZzZXQgPT09IDA/IDAgOiAzKSApLmpvaW4oJyAnKSArIG5ldyBBcnJheSgxMCkuam9pbihcIl5cIik7XG4gICAgLy8gfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUb2tlbml6ZXI7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy90b2tlbml6ZXIuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 2 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n// import fs from 'fs';\n// import mkdirp from 'mkdirp';\n// import path from 'path';\n// import tpl from './tpl';\n// import tpl from './tpl';\n\nvar returnTrue = function returnTrue() {\n    return true;\n};\n\nvar _ = {\n    accept: function accept(fn, list) {\n        if (!list || !list.length) return;\n\n        var tlist = list.map(function (item) {\n            if (!item) return returnTrue;\n\n            if (typeof item === 'function') return item;\n\n            return _.makePredicate(item);\n        });\n    }\n};\n\n/**\n * register regexp pattern\n * @return {[type]} [description]\n */\nvar $ = function () {\n    var table = {};\n    return function (name, pattern) {\n        if (!pattern) {\n            if (/^[a-zA-Z]+$/.test(name)) // $('WS');\n                return table[name];else {\n                // $(/.../);\n                pattern = name;\n                name = null;\n            }\n        }\n\n        if (typeof pattern !== 'string') pattern = String(pattern).slice(1, -1);\n\n        pattern = pattern.replace(/\\{([a-zA-Z]+)}/g, function (all, name) {\n            var p = table[name];\n            if (!p) throw Error('no register pattern ' + name + ' before');\n            var pstart = p.charAt(0),\n                pend = p.charAt(p.length - 1);\n            if (!(pstart === '[' && pend === ']') && !(pstart === '(' && pend === ')')) p = '(?:' + p + ')';\n            return p;\n        });\n\n        // register\n        name && (table[name] = pattern);\n        return new RegExp(pattern);\n    };\n}();\n\nvar toAssert = function toAssert(str) {\n    var arr = typeof str === 'string' ? str.split(/\\s+/) : str;\n    return function (word) {\n        return arr.includes(word);\n    };\n};\n\nvar makePredicate = toAssert;\n\nexports.$ = $;\nexports.toAssert = toAssert;\nexports.makePredicate = makePredicate;//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaGVscGVyL3V0aWwuanM/OTY4OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQU1BLElBQU0sYUFBYSxTQUFiLFVBQWE7QUFBQSxXQUFNLElBQU47QUFBQSxDQUFuQjs7QUFFQSxJQUFJLElBQUk7QUFDSixVQURJLGtCQUNHLEVBREgsRUFDTyxJQURQLEVBQ2E7QUFDYixZQUFHLENBQUMsSUFBRCxJQUFTLENBQUMsS0FBSyxNQUFsQixFQUNJOztBQUVKLFlBQUksUUFBUSxLQUFLLEdBQUwsQ0FBUyxVQUFDLElBQUQsRUFBVTtBQUMzQixnQkFBRyxDQUFDLElBQUosRUFDSSxPQUFPLFVBQVA7O0FBRUosZ0JBQUcsT0FBTyxJQUFQLEtBQWdCLFVBQW5CLEVBQ0ksT0FBTyxJQUFQOztBQUVKLG1CQUFPLEVBQUUsYUFBRixDQUFnQixJQUFoQixDQUFQO0FBQ0gsU0FSVyxDQUFaO0FBV0g7QUFoQkcsQ0FBUjs7Ozs7O0FBMEJBLElBQUksSUFBSyxZQUFXO0FBQ2hCLFFBQUksUUFBUSxFQUFaO0FBQ0EsV0FBTyxVQUFDLElBQUQsRUFBTyxPQUFQLEVBQW1CO0FBQ3RCLFlBQUcsQ0FBQyxPQUFKLEVBQWE7QUFDVCxnQkFBRyxjQUFjLElBQWQsQ0FBbUIsSUFBbkIsQ0FBSCxFO0FBQ0ksdUJBQU8sTUFBTSxJQUFOLENBQVAsQ0FESixLQUVLOztBQUNELDBCQUFVLElBQVY7QUFDQSx1QkFBTyxJQUFQO0FBQ0g7QUFDSjs7QUFFRCxZQUFHLE9BQU8sT0FBUCxLQUFtQixRQUF0QixFQUNJLFVBQVUsT0FBTyxPQUFQLEVBQWdCLEtBQWhCLENBQXNCLENBQXRCLEVBQXlCLENBQUMsQ0FBMUIsQ0FBVjs7QUFFSixrQkFBVSxRQUFRLE9BQVIsQ0FBZ0IsaUJBQWhCLEVBQW1DLFVBQUMsR0FBRCxFQUFNLElBQU4sRUFBZTtBQUN4RCxnQkFBSSxJQUFJLE1BQU0sSUFBTixDQUFSO0FBQ0EsZ0JBQUcsQ0FBQyxDQUFKLEVBQ0ksTUFBTSwrQkFBNkIsSUFBN0IsYUFBTjtBQUNKLGdCQUFJLFNBQVMsRUFBRSxNQUFGLENBQVMsQ0FBVCxDQUFiO2dCQUEwQixPQUFPLEVBQUUsTUFBRixDQUFTLEVBQUUsTUFBRixHQUFXLENBQXBCLENBQWpDO0FBQ0EsZ0JBQUcsRUFBRSxXQUFXLEdBQVgsSUFBa0IsU0FBUyxHQUE3QixLQUFxQyxFQUFFLFdBQVcsR0FBWCxJQUFrQixTQUFTLEdBQTdCLENBQXhDLEVBQ0ksSUFBSSxRQUFRLENBQVIsR0FBWSxHQUFoQjtBQUNKLG1CQUFPLENBQVA7QUFDSCxTQVJTLENBQVY7OztBQVdBLGlCQUFTLE1BQU0sSUFBTixJQUFjLE9BQXZCO0FBQ0EsZUFBTyxJQUFJLE1BQUosQ0FBVyxPQUFYLENBQVA7QUFDSCxLQTFCRDtBQTJCSCxDQTdCTyxFQUFSOztBQStCQSxJQUFJLFdBQVcsU0FBWCxRQUFXLENBQVMsR0FBVCxFQUFjO0FBQ3pCLFFBQUksTUFBTSxPQUFPLEdBQVAsS0FBZSxRQUFmLEdBQTBCLElBQUksS0FBSixDQUFVLEtBQVYsQ0FBMUIsR0FBNkMsR0FBdkQ7QUFDQSxXQUFPLFVBQUMsSUFBRDtBQUFBLGVBQVUsSUFBSSxRQUFKLENBQWEsSUFBYixDQUFWO0FBQUEsS0FBUDtBQUNILENBSEQ7O0FBS0EsSUFBSSxnQkFBZ0IsUUFBcEI7O1FBRVEsQyxHQUFBLEM7UUFBRyxRLEdBQUEsUTtRQUFVLGEsR0FBQSxhIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnQgZnMgZnJvbSAnZnMnO1xuLy8gaW1wb3J0IG1rZGlycCBmcm9tICdta2RpcnAnO1xuLy8gaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG4vLyBpbXBvcnQgdHBsIGZyb20gJy4vdHBsJztcbi8vIGltcG9ydCB0cGwgZnJvbSAnLi90cGwnO1xuXG5jb25zdCByZXR1cm5UcnVlID0gKCkgPT4gdHJ1ZTtcblxubGV0IF8gPSB7XG4gICAgYWNjZXB0KGZuLCBsaXN0KSB7XG4gICAgICAgIGlmKCFsaXN0IHx8ICFsaXN0Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBsZXQgdGxpc3QgPSBsaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYoIWl0ZW0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblRydWU7XG5cbiAgICAgICAgICAgIGlmKHR5cGVvZiBpdGVtID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuXG4gICAgICAgICAgICByZXR1cm4gXy5tYWtlUHJlZGljYXRlKGl0ZW0pO1xuICAgICAgICB9KTtcblxuXG4gICAgfSxcblxuXG5cbn07XG5cbi8qKlxuICogcmVnaXN0ZXIgcmVnZXhwIHBhdHRlcm5cbiAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICovXG5sZXQgJCA9IChmdW5jdGlvbigpIHtcbiAgICBsZXQgdGFibGUgPSB7fTtcbiAgICByZXR1cm4gKG5hbWUsIHBhdHRlcm4pID0+IHtcbiAgICAgICAgaWYoIXBhdHRlcm4pIHtcbiAgICAgICAgICAgIGlmKC9eW2EtekEtWl0rJC8udGVzdChuYW1lKSkgICAgLy8gJCgnV1MnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFibGVbbmFtZV07XG4gICAgICAgICAgICBlbHNlIHsgIC8vICQoLy4uLi8pO1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gPSBuYW1lO1xuICAgICAgICAgICAgICAgIG5hbWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYodHlwZW9mIHBhdHRlcm4gIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcGF0dGVybiA9IFN0cmluZyhwYXR0ZXJuKS5zbGljZSgxLCAtMSk7XG5cbiAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZSgvXFx7KFthLXpBLVpdKyl9L2csIChhbGwsIG5hbWUpID0+IHtcbiAgICAgICAgICAgIGxldCBwID0gdGFibGVbbmFtZV07XG4gICAgICAgICAgICBpZighcClcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgbm8gcmVnaXN0ZXIgcGF0dGVybiAke25hbWV9IGJlZm9yZWApO1xuICAgICAgICAgICAgbGV0IHBzdGFydCA9IHAuY2hhckF0KDApLCBwZW5kID0gcC5jaGFyQXQocC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGlmKCEocHN0YXJ0ID09PSAnWycgJiYgcGVuZCA9PT0gJ10nKSAmJiAhKHBzdGFydCA9PT0gJygnICYmIHBlbmQgPT09ICcpJykpXG4gICAgICAgICAgICAgICAgcCA9ICcoPzonICsgcCArICcpJztcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyByZWdpc3RlclxuICAgICAgICBuYW1lICYmICh0YWJsZVtuYW1lXSA9IHBhdHRlcm4pO1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuKTtcbiAgICB9XG59KSgpO1xuXG5sZXQgdG9Bc3NlcnQgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBsZXQgYXJyID0gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgPyBzdHIuc3BsaXQoL1xccysvKSA6IHN0cjtcbiAgICByZXR1cm4gKHdvcmQpID0+IGFyci5pbmNsdWRlcyh3b3JkKTtcbn1cblxubGV0IG1ha2VQcmVkaWNhdGUgPSB0b0Fzc2VydDtcblxuZXhwb3J0IHskLCB0b0Fzc2VydCwgbWFrZVByZWRpY2F0ZX1cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2hlbHBlci91dGlsLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _util = __webpack_require__(2);\n\nvar _ = _interopRequireWildcard(_util);\n\nvar _tree = __webpack_require__(4);\n\nvar tree = _interopRequireWildcard(_tree);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar STATES = {\n    // 进入filter\n    FILTER_DECLARATION: Symbol(),\n    // 失败则进入Ruleset\n    TRY_DECLARATION: Symbol(),\n    TRY_INTERPOLATION: Symbol(),\n    // 当遇到特殊属性时\n    FUNCTION_CALL: Symbol()\n};\nvar ASSIGNS = { '=': 1, '?=': 2, '^=': 3 };\nvar COMBOS = 'WS > ~ +';\n\nvar isSkipStart = _.makePredicate('WS NEWLINE COMMENT ;');\nvar isWSOrNewLine = _.makePredicate('WS NEWLINE');\nvar isCombo = _.makePredicate(COMBOS);\n\n// probably selector segment\nvar isSelectorSep = _.makePredicate('WS > ~ +' + 'PSEUDO_CLASS PSEUDO_ELEMENT ATTRIBUTE CLASS HASH & TEXT * # #{ : . % - compoundident DIMENSION');\n\nvar isOperator = _.makePredicate('+ - * /');\nvar isRelationOp = _.makePredicate('== >= <= < > !=');\nvar isCommaOrParen = _.makePredicate(', )');\nvar isDirectOperate = _.makePredicate('DIMENSION STRING BOOLEAN TEXT NULL');\n\nvar isColor = _.makePredicate(\"aliceblue antiquewhite aqua aquamarine azure beige bisque black blanchedalmond blue blueviolet brown burlywood cadetblue chartreuse chocolate coral cornflowerblue cornsilk crimson cyan darkblue darkcyan darkgoldenrod darkgray darkgrey darkgreen darkkhaki darkmagenta darkolivegreen darkorange darkorchid darkred darksalmon darkseagreen darkslateblue darkslategray darkslategrey darkturquoise darkviolet deeppink deepskyblue dimgray dimgrey dodgerblue firebrick floralwhite forestgreen fuchsia gainsboro ghostwhite gold goldenrod gray grey green greenyellow honeydew hotpink indianred indigo ivory khaki lavender lavenderblush lawngreen lemonchiffon lightblue lightcoral lightcyan lightgoldenrodyellow lightgray lightgrey lightgreen lightpink lightsalmon lightseagreen lightskyblue lightslategray lightslategrey lightsteelblue lightyellow lime limegreen linen magenta maroon mediumaquamarine mediumblue mediumorchid mediumpurple mediumseagreen mediumslateblue mediumspringgreen mediumturquoise mediumvioletred midnightblue mintcream mistyrose moccasin navajowhite navy oldlace olive olivedrab orange orangered orchid palegoldenrod palegreen paleturquoise palevioletred papayawhip peachpuff peru pink plum powderblue purple red rosybrown royalblue saddlebrown salmon sandybrown seagreen seashell sienna silver skyblue slateblue slategray slategrey snow springgreen steelblue tan teal thistle tomato turquoise violet wheat white whitesmoke yellow yellowgreen\");\nvar isShorthandProp = _.makePredicate('background font margin border border-top border-right border-bottom border-left border-width border-color border-style transition padding list-style border-radius.');\n\nvar isMcssAtKeyword = _.makePredicate('mixin extend var');\nvar isMcssFutureAtKeyword = _.makePredicate('if else css for');\nvar isCssAtKeyword = _.makePredicate('import page keyframe media font-face charset');\n\nvar Parser = function () {\n    function Parser() {\n        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n        _classCallCheck(this, Parser);\n\n        this.options = options;\n    }\n\n    _createClass(Parser, [{\n        key: 'parse',\n        value: function parse(tokens) {\n            // return new Promise((resolve, reject) => {\n            //     // >>>>>> @TODO: 这些要与import 合并 2013/5/12 0:29:42\n\n            // });\n            this._states = {};\n            this.lookahead = tokens;\n            this.p = 0;\n            this.length = this.lookahead.length;\n            this.marked = null;\n            var ast = this.stylesheet();\n            return ast;\n        }\n\n        // store intermedia state\n\n    }, {\n        key: 'state',\n        value: function state(_state) {\n            return this._states[_state] === true;\n        }\n\n        // enter some state\n\n    }, {\n        key: 'enter',\n        value: function enter(state) {\n            this._states[state] = true;\n        }\n\n        // enter some state\n\n    }, {\n        key: 'leave',\n        value: function leave(state) {\n            this._states[state] = false;\n        }\n    }, {\n        key: 'lookUpBefore',\n        value: function lookUpBefore(lookup, before) {\n            var i = 1,\n                la = void 0;\n            while (i++) {\n                if ((la = this.la(i)) === lookup) return true;\n                if (la === before || la === 'EOF' || la === '}') return false;\n            }\n            return false;\n        }\n\n        // Temporarily set to ll(3) parser,\n\n    }, {\n        key: 'll',\n        value: function ll() {\n            var k = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];\n\n            if (k < 0) k++;\n            var pos = this.p + k - 1;\n            if (pos > this.length - 1) pos = this.length - 1;\n            // return this.lookahead[(this.p + k - 1) % 3];\n            return this.lookahead[pos];\n        }\n\n        // read the next token\n        // @TODO return to token stream!\n\n    }, {\n        key: 'next',\n        value: function next() {\n            var k = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];\n\n            this.p += k;\n        }\n\n        // expect\n        // some times we need to ignored some lookahead , etc. NEWLINE\n        //\n        // while to eat ';'\n        // 1. eat ;\n        // 2. eat newLine;\n\n    }, {\n        key: 'eat',\n        value: function eat() {\n            var token = this.ll();\n\n            for (var _len = arguments.length, types = Array(_len), _key = 0; _key < _len; _key++) {\n                types[_key] = arguments[_key];\n            }\n\n            for (var i = 0; i < types.length; i++) {\n                if (token.type === types[i]) {\n                    this.next();\n                    return token;\n                }\n            }\n        }\n    }, {\n        key: 'match',\n        value: function match() {\n            var token = this.eat.apply(this, arguments);\n            if (!token) {\n                // >>>>>> ?为什么\n                token = this.ll();\n                this.error('expect: \"' + (arguments.length <= 0 ? undefined : arguments[0]) + '\" -> got: \"' + token.type + '\"', token.lineno);\n            } else return token;\n        }\n\n        //\n\n    }, {\n        key: 'skip',\n        value: function skip(type) {\n            var skiped = false;\n            while (true) {\n                var token = this.ll();\n                if (typeof type === 'string' ? type === token.type : type(token.type)) {\n                    this.next();\n                    skiped = true;\n                } else break;\n            }\n            return skiped;\n        }\n    }, {\n        key: 'skipStart',\n        value: function skipStart() {\n            return this.skip(isSkipStart);\n        }\n    }, {\n        key: 'skipWSOrNewline',\n        value: function skipWSOrNewline() {\n            return this.skip(isWSOrNewLine);\n        }\n\n        // type at pos is some type\n\n    }, {\n        key: 'is',\n        value: function is(pos, type) {\n            return this.ll(pos).type === type;\n        }\n\n        // 简单版本 只允许mark一次\n\n    }, {\n        key: 'mark',\n        value: function mark() {\n            this.marked = this.p;\n            return this;\n        }\n    }, {\n        key: 'restore',\n        value: function restore() {\n            // if(this.marked != undefined) this.p = this.marked;\n            // this.marked = null;\n            if (this.marked != null) {\n                this.p = this.marked;\n                this.marked = null;\n            }\n            return this;\n        }\n\n        // parse Function\n        // ===================\n\n        // stylesheet(topLevel)\n        //  : WS      {skipWhiteSpace}\n        //  | stmt EOF\n        //  ;\n        //\n\n    }, {\n        key: 'stylesheet',\n        value: function stylesheet() {\n            return this.block(true);\n        }\n\n        // statement\n        // stmt\n        //  : ruleset\n        //  | atrule\n        //  ;\n\n    }, {\n        key: 'stmt',\n        value: function stmt() {\n            var node = null;\n            var token = this.ll();\n            if (token.type === 'AT_KEYWORD') node = this.atrule();else if (token.type === 'VAR') {\n                switch (this.ll(2).type) {\n                    case '(':\n                        node = this.funcCall();\n                        this.matchSemiColonIfNoBlock();\n                        break;\n                    case ':':\n                        node = this.transparentCall();\n                        this.matchSemiColonIfNoBlock();\n                        break;\n                    case '=':\n                    case '?=':\n                    case '^=':\n                        node = this.assign();\n                        if (node.value.type !== 'func') this.matchSemiColonIfNoBlock();\n                        break;\n                    default:\n                        this.error('UNEXPECT token after VARIABLE', this.ll(2));\n                }\n            } else if (token.type === 'FUNCTION') {\n                node = this.funcCall();\n                this.matchSemiColonIfNoBlock();\n            } else if (isSelectorSep(token.type)) node = this.ruleset(true);\n\n            if (node) return node;else this.error('INVALID statementstart ' + token.type, token);\n        }\n\n        // atrule\n        //  : css-atrule(@import, @charset...)\n        //  : bi-atrule(@if, @else, @mixin...)\n        //  : directive\n        //  ;\n\n    }, {\n        key: 'atrule',\n        value: function atrule() {\n            var node = null;\n            var fullname = this.ll().value.toLowerCase();\n            var name = this._removePrefix(fullname);\n            if (typeof this[name] === 'function') node = this[name]();else node = this.directive();\n            node.fullname = fullname;\n            return node;\n        }\n\n        // >>>>>> 待补充\n        // 天然支持document、charset等等\n\n    }, {\n        key: 'directive',\n        value: function (_directive) {\n            function directive() {\n                return _directive.apply(this, arguments);\n            }\n\n            directive.toString = function () {\n                return _directive.toString();\n            };\n\n            return directive;\n        }(function () {\n            var token = this.ll();\n            var name = token.value.toLowerCase();\n            var dhook = directive.getDirective(name);\n            if (dhook) {\n                // this.error('undefined atrule: \"' + this.ll().value + '\"')\n                //@TODO add customer syntax\n                console.log('has hook');\n            } else {\n                this.match('AT_KEYWORD');\n                this.eat('WS');\n                var value = this.valuesList();\n                this.eat('WS');\n                if (this.eat(';')) {\n                    return tree.directive(name, value);\n                } else {\n                    var block = this.block();\n                    return tree.directive(name, value, block);\n                }\n                this.error('invalid customer directive define', ll);\n            }\n        })\n\n        /**\n         * @param  {Boolean} has '{}'\n         * @return {[type]}           [description]\n         */\n\n    }, {\n        key: 'block',\n        value: function block(noBlock) {\n            var node = new tree.Block();\n            this.eat('WS');\n            if (!noBlock) this.match('{');\n            var end = noBlock ? 'EOF' : '}';\n            this.skip('WS');\n            while (!this.eat(end)) {\n                var child = void 0;\n                if (noBlock) child = this.stmt();else child = this.mark().declaration() || this.restore().stmt();\n                node.list.push(child);\n                this.skipStart();\n            }\n            return node;\n        }\n\n        // ruleset\n        //  : selectorlist '{' rule ((NewLine|;) rule)* '}'\n\n    }, {\n        key: 'ruleset',\n        value: function ruleset() {\n            var node = new tree.RuleSet();\n            // 1. 是Selector Sep 2\n            // 2. 在是IDENT(Selector Sep之一)时后续不接: 代表不是declaration //  &&(la !== 'IDENT'|| this.la(2) !== ':'\n            // @changelog: 2 remove 这不需要\n            node.selector = this.selectorList();\n            this.eat('WS');\n            node.block = this.block();\n            return node;\n        }\n\n        // selectorList\n        //  : complexSelector (, complexSelector)*\n        //  ;\n\n    }, {\n        key: 'selectorList',\n        value: function selectorList() {\n            var node = new tree.SelectorList();\n            do {\n                node.list.push(this.selector());\n            } while (this.eat(','));\n            node.lineno = node.list[0].lineno;\n            return node;\n        }\n\n        // 简化处理，允许id、class、type插值\n\n    }, {\n        key: 'selector',\n        value: function selector() {\n            var node = new tree.Selector();\n            var selectorString = '';\n            var token = void 0;\n            var i = 0;\n            while (true) {\n                token = this.ll();\n                if (token.type === '#{' && this.ll(2).type !== '}') {\n                    var interpolation = this.interpolation();\n                    if (interpolation) {\n                        selectorString += '#{' + i++ + '}';\n                        node.interpolations.push(interpolation);\n                    } else break;\n                } else if (isSelectorSep(token.type)) {\n                    // >>>>>> 可以优化\n                    var value = token.type === 'DIMENSION' ? tree.toStr(token) : token.value || (token.type === 'WS' ? ' ' : token.type);\n                    selectorString += value;\n                    this.next();\n                } else break;\n            }\n            node.string = selectorString;\n            node.lineno = token.lineno;\n            return node;\n        }\n    }, {\n        key: 'declaration',\n        value: function declaration(noEnd) {\n            var node = new tree.Declaration();\n            var token1 = this.ll(1),\n                token2 = this.ll(2);\n            if (token1.type === '*' && token2.type === 'TEXT') {\n                this.next(1);\n                token2.value = '*' + token2.value;\n            }\n            // >>>>>>\n            node.property = this.compoundIdent();\n            // don't start with tag or don't ll(2) !== ':'\n            if (!node.property) return;\n            this.eat('WS');\n            if (!this.eat(':')) return;\n\n            // filter_declaration在IE下是支持一些不规则的语法\n            if (node.property.value && /filter$/.test(node.property.value.toLowerCase())) this.enter(STATES.FILTER_DECLARATION);\n            this.enter(STATES.TRY_DECLARATION);\n\n            try {\n                node.value = this.valuesList();\n                this.leave(STATES.TRY_DECLARATION);\n            } catch (error) {\n                this.leave(STATES.TRY_DECLARATION);\n                if (error.code === errors.DECLARION_FAIL) return;else throw error;\n            }\n\n            if (this.eat('IMPORTANT')) node.important = true;\n            if (!noEnd) this.matchSemiColonIfNoBlock();\n            this.leave(STATES.FILTER_DECLARATION);\n            return node;\n        }\n    }, {\n        key: 'assign',\n        value: function assign() {\n            var token = this.ll();\n            this.match('VAR');\n            var op = this.match('=', '?=', '^=').type;\n            var value = this.assignExpr(true);\n            //@FIXIT conflict with parenExpr\n            return new tree.Assign(token.value, value, ASSIGNS[op] || 1);\n        }\n\n        /**function();\n         * can be assign expression\n         * function | valueslist | values\n         * @param  {Boolean} hasComma whether has comma in the expression\n         * @return {mixin}\n         */\n\n    }, {\n        key: 'assignExpr',\n        value: function assignExpr(hasComma) {\n            var node = null;\n            var token = this.ll();\n            var fn = hasComma ? 'valuesList' : 'values';\n            if (token.type === '{') // 可能是parenExpr 也可能是function\n                return this.func();else if (token.type === '(') {\n                this.mark();\n                try {\n                    return this.func();\n                } catch (e) {\n                    if (e.expect && e.expect == '{' || e.expect == 'VAR' || e.expect == ')') {\n                        this.restore();\n                        return this[fn]();\n                    } else {\n                        throw e;\n                    }\n                }\n            } else {\n                return this[fn]();\n            }\n        }\n\n        // 1px 1px #fff, 1px 1px #fff ...\n        // comma separated values\n        // valuesList\n\n    }, {\n        key: 'valuesList',\n        value: function valuesList() {\n            var list = [];\n            do {\n                var values = this.values();\n                if (values) list.push(values);else break;\n            } while (this.eat(','));\n\n            if (list.length === 1) return list[0];else return new tree.ValuesList(list);\n        }\n        // component Values\n\n    }, {\n        key: 'values',\n        value: function values() {\n            var list = [];\n            while (true) {\n                var value = this.expression();\n                if (value) list.push(value);else break;\n            }\n\n            if (list.length === 0) return null;else if (list.length === 1) return list[0];else return new tree.Values(list);\n        }\n    }, {\n        key: 'expression',\n        value: function expression() {\n            this.eat('WS');\n            return this.logicOrExpr();\n        }\n\n        // ||\n\n    }, {\n        key: 'logicOrExpr',\n        value: function logicOrExpr() {\n            var left = this.logicAndExpr(),\n                right = void 0;\n            var token = void 0;\n            while ((token = this.ll()).type === '||') {\n                this.next();\n                right = this.logicAndExpr();\n                if (!right) this.error(token.type + ' require right operand', left);\n\n                var bValue = tree.toBoolean(left);\n                if (bValue !== null) {\n                    if (bValue === false) left = right;\n                } else left = new tree.Operator(token.type, left, right);\n                this.eat('WS');\n            }\n            return left;\n        }\n\n        // &&\n\n    }, {\n        key: 'logicAndExpr',\n        value: function logicAndExpr() {\n            var node = this.relationExpr(),\n                right = void 0;\n            var token = void 0;\n            while ((token = this.ll()).type === '&&') {\n                this.next();\n                right = this.relationExpr();\n                if (!right) this.error(token.type + ' require right operand', node);\n\n                var bValue = tree.toBoolean(node);\n                if (bValue != null) {\n                    if (bValue === true) node = right;\n                } else node = new tree.Operator(token.type, node, right);\n                this.eat('WS');\n            }\n            return node;\n        }\n\n        // ==\n        // !=\n        // >=\n        // <=\n        // >\n        // <\n\n    }, {\n        key: 'relationExpr',\n        value: function relationExpr() {\n            var left = this.binop1(),\n                right = void 0;\n            var token = void 0;\n            while (isRelationOp(token = this.ll().type)) {\n                this.next();\n                this.eat('WS');\n                right = this.binop1();\n                if (!right) this.error(token.type + ' require right operand', left);\n\n                if (tree.isPrimary(left.type) && tree.isPrimary(right.type)) left = binop.relation.call(this, left, right, token.type);else left = new tree.Operator(token.type, left, right);\n                this.eat('WS');\n            }\n            return left;\n        }\n\n        // + -\n\n    }, {\n        key: 'binop1',\n        value: function binop1() {\n            var left = this.binop2(),\n                right = void 0;\n            var token = void 0;\n            this.eat('WS');\n            while ((token = this.ll()).type === '+' || token.type === '-') {\n                this.next();\n                this.eat('WS');\n                right = this.binop2();\n                if (!right) this.error(la + ' require right operand', left);\n\n                if (right.type === 'DIMENSION' && left.type === 'DIMENSION') left = binop[token.type].call(this, left, right);else left = new tree.Operator(token.type, left, right);\n                this.eat('WS');\n            }\n            return left;\n        }\n\n        // * / % ... (@TODO 将range与binop2结合, 即同一优先级)\n\n    }, {\n        key: 'binop2',\n        value: function binop2() {\n            var left = this.unary(),\n                right = void 0;\n            var ws = !!this.eat('WS');\n\n            var token = this.ll();\n            // >>>>>>\n            if (token.type === '...') {\n                this.next();\n                this.eat('WS');\n                right = this.unary();\n                return tree.range(left, right, left.lineno);\n            }\n            while (token.type === '*' || token.type === '/' || token.type === '%') {\n                // 即一个空格也没有\n                if (token.type == '/' && !ws && this.ll(2).type !== 'WS') return left;\n                this.next();\n                this.eat('WS');\n                right = this.unary();\n                if (!right) this.error(token.type + ' require right operand', left);\n\n                if (right.type === 'DIMENSION' && left.type === 'DIMENSION') left = binop[token.type].call(this, left, right);else left = new tree.Operator(token.type, left, right);\n                this.eat('WS');\n                token = this.ll();\n            }\n            return left;\n        }\n\n        // range: function(){\n        //     var left = this.ll(),\n        //         node = new tree.ValuesList(),\n        //         right, lc, rc, reverse;\n        //     this.match('DIMENSION')\n        //     this.eat('...');\n        //     right = this.ll();\n        //     this.match(left.type);\n        //     lc = left.value;\n        //     rc = right.value;\n        //     reverse = lc > rc;\n\n        //     for(; lc != rc ;){\n        //         node.list.push({\n        //             type: left.type,\n        //             value: lc\n        //         })\n        //         if(reverse)  lc -= 1\n        //         else lc += 1\n        //     }\n        //     node.list.push({\n        //         type: left.type,\n        //         value: lc\n        //     })\n        //     return node;\n        // },\n\n        // 一元数\n        // @TODO : 加入 ！一元数\n\n    }, {\n        key: 'unary',\n        value: function unary() {\n            var token = this.ll();\n            if (token.type === '-' || token.type === '+' || token.type === '!') {\n                this.next();\n                this.eat('WS');\n                var value = this.unary();\n                var node = new tree.Unary(value, token.type);\n                node.lineno = token.lineno;\n                return node;\n            } else return this.primary();\n        }\n\n        // primary\n        //  : Ident\n        //  : Dimension\n        //  : function\n        //  : Var\n\n    }, {\n        key: 'primary',\n        value: function primary() {\n            var node = null;\n            var token = this.ll();\n            switch (token.type) {\n                case '(':\n                    return this.parenExpr();\n                case '=':\n                    // filter: alpha(xx=80, xx=xx, ddd=xx)\n                    if (this.state(STATES.FILTER_DECLARATION) && this.state(STATES.FUNCTION_CALL)) {\n                        this.next();\n                        return token;\n                    }\n                    break;\n                case '/':\n                    this.next();\n                    return token;\n                case '-':\n                    var token2 = this.ll(2);\n                    if (token2.type === 'TEXT' || token2.type === '#{') return this.compoundIdent();\n                case '#{':\n                case 'TEXT':\n                    return this.compoundIdent();\n                case 'FUNCTION':\n                    return this.funcCall();\n                case 'HASH':\n                    this.next();\n                    var value = token.value;\n                    if (/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(value)) {\n                        node = new tree.Color(value);\n                        node.lineno = token.lineno;\n                    } else node = new tree.Unknown(token.value);\n                    return node;\n                // TODO 插值\n                case 'STRING':\n                case 'DIMENSION':\n                case 'BOOLEAN':\n                case 'VAR':\n                case 'NULL':\n                case 'URL':\n                    this.next();\n                    return token;\n                case '>':\n                case '~':\n                case '+':\n                case '.':\n                case '#':\n                case '&':\n                case '{':\n                case ':':\n                case '*':\n                case 'PSEUDO_CLASS':\n                case 'CLASS':\n                case 'ATTRIBUTE':\n                    if (this.state(STATES.TRY_DECLARATION)) {\n                        this.error(errors.DECLARION_FAIL);\n                        break;\n                    }\n                default:\n                    return null;\n            }\n        }\n\n        //  : '#{' values '}'\n\n    }, {\n        key: 'interpolation',\n        value: function interpolation() {\n            this.match('#{');\n            var node = this.valuesList();\n            this.match('}');\n            return node;\n        }\n\n        // parenExpr\n        //  : '(' expresion ')'\n\n    }, {\n        key: 'parenExpr',\n        value: function parenExpr() {\n            this.match('(');\n            this.eat('WS');\n            var node = this.valuesList();\n            node.lineno = this.ll().lineno;\n            this.eat('WS');\n            this.match(')');\n            return node;\n        }\n\n        // compoundIdent 组合Ident\n        //  : (interpolation | TEXT) +\n\n    }, {\n        key: 'compoundIdent',\n        value: function compoundIdent() {\n            var node = void 0;\n            var list = [];\n            var token = void 0;\n            var sep = void 0;\n            while (true) {\n                token = this.ll();\n                if (token.type === '#{') {\n                    sep = this.interpolation();\n                    list.push(sep);\n                } else if (token.type === 'TEXT' || token.type === '-') {\n                    this.next();\n                    list.push(token.value || token.type);\n                } else break;\n            }\n            if (!sep) {\n                if (!list.length) return null;else return { type: 'TEXT', value: list[0], lineno: token.lineno };\n            } else {\n                node = new tree.CompoundIdent(list);\n                node.lineno = token.lineno;\n                return node;\n            }\n        }\n    }, {\n        key: 'func',\n        value: function func() {\n            var params = void 0;\n            if (this.eat('(')) {\n                this.eat('WS');\n                params = this.params();\n                this.match(')');\n            }\n            var block = this.block();\n            return new tree.Func(params, block);\n        }\n    }, {\n        key: 'params',\n        value: function params() {\n            var rest = 0,\n                params = [];\n            var token = this.ll();\n            if (token.type !== ')') {\n                do {\n                    var param = this.param();\n                    if (param.rest) rest++;\n                    params.push(param);\n                } while (this.eat(','));\n                if (rest >= 2) this.error('can not have more than 2 rest param', token.lineno);\n                this.eat('WS');\n            }\n            return params;\n        }\n\n        // mixin' params\n\n    }, {\n        key: 'param',\n        value: function param() {\n            var token = this.ll();\n            var name = token.value,\n                dft = void 0,\n                rest = false;\n            this.match('VAR');\n            if (this.eat('...')) rest = true;\n            if (this.eat('=')) {\n                if (rest) this.error('rest type param can\"t have default params', token.lineno);\n                dft = this.values();\n            }\n            return new tree.Param(name, dft, rest);\n        }\n\n        // funcCall\n        //  : CALL FUNCTION '('  expresion * ')'\n\n    }, {\n        key: 'funcCall',\n        value: function funcCall() {\n            var token = this.ll();\n            this.match('FUNCTION', 'VAR');\n            if (token.args) return new tree.FuncCall(token.value, token.args, null, token.lineno);\n            this.eat('WS');\n            this.match('(');\n            this.enter(STATES.FUNCTION_CALL);\n            this.eat('WS');\n            var pargs = this.ll().type !== ')' ? this.args() : { args: [] };\n            this.leave(states.FUNCTION_CALL);\n            this.match(')');\n            return new tree.FuncCall(token.value, pargs.args, pargs.named, token.lineno);\n        }\n\n        //@TODO start named arguments\n\n    }, {\n        key: 'args',\n        value: function args(end) {\n            var token = void 0;\n            var named = null;\n            var args = [];\n            var i = 0;\n            do {\n                token = this.ll();\n                if (token.type === 'VAR' && this.ll(2).type === '=') {\n                    this.next(2);\n                    if (!named) named = {};\n                    named[token.value] = i;\n                }\n                args.push(this.assignExpr());\n                this.skip('WS');\n                i++;\n            } while (this.eat(','));\n\n            return { args: args, named: named };\n        }\n\n        // stylus inspired feature;\n\n    }, {\n        key: 'transparentCall',\n        value: function transparentCall() {\n            var token = this.ll();\n            this.match('VAR');\n            this.match(':');\n            this.eat('WS');\n            var pargs = this.args();\n            // if(args.type === 'values'){\n            //     args = new tree.ValuesList(args.list);\n            // }\n\n            // if(args.type !== 'valueslist') args = [args];\n            // else args = args.list;\n            return tree.FuncCall(token.value, pargs.args, pargs.named, token.lineno);\n        }\n\n        /**\n         * remove at-rule prefix\n         */\n\n    }, {\n        key: '_removePrefix',\n        value: function _removePrefix(str) {\n            return str.replace(/^-\\w+-/, '');\n        }\n    }, {\n        key: 'matchSemiColonIfNoBlock',\n        value: function matchSemiColonIfNoBlock() {\n            this.eat('WS');\n            if (this.ll().type !== '}') this.match(';');\n        }\n    }]);\n\n    return Parser;\n}();\n\nexports.default = Parser;//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFyc2VyLmpzPzI2MTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7SUFBWSxDOztBQUNaOztJQUFZLEk7Ozs7OztBQUVaLElBQU0sU0FBUzs7QUFFWCx3QkFBb0IsUUFGVDs7QUFJWCxxQkFBaUIsUUFKTjtBQUtYLHVCQUFtQixRQUxSOztBQU9YLG1CQUFlO0FBUEosQ0FBZjtBQVNBLElBQU0sVUFBVSxFQUFDLEtBQUssQ0FBTixFQUFTLE1BQU0sQ0FBZixFQUFrQixNQUFNLENBQXhCLEVBQWhCO0FBQ0EsSUFBTSxTQUFTLFVBQWY7O0FBRUEsSUFBSSxjQUFjLEVBQUUsYUFBRixDQUFnQixzQkFBaEIsQ0FBbEI7QUFDQSxJQUFJLGdCQUFnQixFQUFFLGFBQUYsQ0FBZ0IsWUFBaEIsQ0FBcEI7QUFDQSxJQUFJLFVBQVUsRUFBRSxhQUFGLENBQWdCLE1BQWhCLENBQWQ7OztBQUdBLElBQUksZ0JBQWdCLEVBQUUsYUFBRixDQUFnQixhQUFhLGdHQUE3QixDQUFwQjs7QUFFQSxJQUFJLGFBQWEsRUFBRSxhQUFGLENBQWdCLFNBQWhCLENBQWpCO0FBQ0EsSUFBSSxlQUFlLEVBQUUsYUFBRixDQUFnQixpQkFBaEIsQ0FBbkI7QUFDQSxJQUFJLGlCQUFpQixFQUFFLGFBQUYsQ0FBZ0IsS0FBaEIsQ0FBckI7QUFDQSxJQUFJLGtCQUFrQixFQUFFLGFBQUYsQ0FBZ0Isb0NBQWhCLENBQXRCOztBQUVBLElBQUksVUFBVSxFQUFFLGFBQUYsQ0FBZ0IsaTdDQUFoQixDQUFkO0FBQ0EsSUFBSSxrQkFBa0IsRUFBRSxhQUFGLENBQWdCLHFLQUFoQixDQUF0Qjs7QUFFQSxJQUFJLGtCQUFrQixFQUFFLGFBQUYsQ0FBZ0Isa0JBQWhCLENBQXRCO0FBQ0EsSUFBSSx3QkFBd0IsRUFBRSxhQUFGLENBQWdCLGlCQUFoQixDQUE1QjtBQUNBLElBQUksaUJBQWlCLEVBQUUsYUFBRixDQUFnQiw4Q0FBaEIsQ0FBckI7O0lBS00s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MEJBQU0sTUFBTSxLQUFaLElBQXFCLENBQXJCO0FBQ0g7QUFDRCxxQkFBSyxJQUFMLENBQVUsS0FBSyxVQUFMLEVBQVY7QUFDQSxxQkFBSyxJQUFMLENBQVUsSUFBVjtBQUNBO0FBQ0gsYUFWRCxRQVVRLEtBQUssR0FBTCxDQUFTLEdBQVQsQ0FWUjs7QUFZQSxtQkFBTyxFQUFDLFVBQUQsRUFBTyxZQUFQLEVBQVA7QUFDSDs7Ozs7OzBDQUdpQjtBQUNkLGdCQUFJLFFBQVEsS0FBSyxFQUFMLEVBQVo7QUFDQSxpQkFBSyxLQUFMLENBQVcsS0FBWDtBQUNBLGlCQUFLLEtBQUwsQ0FBVyxHQUFYO0FBQ0EsaUJBQUssR0FBTCxDQUFTLElBQVQ7QUFDQSxnQkFBSSxRQUFRLEtBQUssSUFBTCxFQUFaOzs7Ozs7O0FBT0EsbUJBQU8sS0FBSyxRQUFMLENBQWMsTUFBTSxLQUFwQixFQUEyQixNQUFNLElBQWpDLEVBQXVDLE1BQU0sS0FBN0MsRUFBb0QsTUFBTSxNQUExRCxDQUFQO0FBQ0g7Ozs7Ozs7O3NDQUthLEcsRUFBSztBQUNmLG1CQUFPLElBQUksT0FBSixDQUFZLFFBQVosRUFBc0IsRUFBdEIsQ0FBUDtBQUNIOzs7a0RBRXlCO0FBQ3RCLGlCQUFLLEdBQUwsQ0FBUyxJQUFUO0FBQ0EsZ0JBQUcsS0FBSyxFQUFMLEdBQVUsSUFBVixLQUFtQixHQUF0QixFQUNJLEtBQUssS0FBTCxDQUFXLEdBQVg7QUFDUDs7Ozs7O2tCQUdVLE0iLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIF8gZnJvbSAnLi9oZWxwZXIvdXRpbC5qcyc7XG5pbXBvcnQgKiBhcyB0cmVlIGZyb20gJy4vdHJlZSc7XG5cbmNvbnN0IFNUQVRFUyA9IHtcbiAgICAvLyDov5vlhaVmaWx0ZXJcbiAgICBGSUxURVJfREVDTEFSQVRJT046IFN5bWJvbCgpLFxuICAgIC8vIOWksei0peWImei/m+WFpVJ1bGVzZXRcbiAgICBUUllfREVDTEFSQVRJT046IFN5bWJvbCgpLFxuICAgIFRSWV9JTlRFUlBPTEFUSU9OOiBTeW1ib2woKSxcbiAgICAvLyDlvZPpgYfliLDnibnmrorlsZ7mgKfml7ZcbiAgICBGVU5DVElPTl9DQUxMOiBTeW1ib2woKVxufTtcbmNvbnN0IEFTU0lHTlMgPSB7Jz0nOiAxLCAnPz0nOiAyLCAnXj0nOiAzfTtcbmNvbnN0IENPTUJPUyA9ICdXUyA+IH4gKyc7XG5cbmxldCBpc1NraXBTdGFydCA9IF8ubWFrZVByZWRpY2F0ZSgnV1MgTkVXTElORSBDT01NRU5UIDsnKTtcbmxldCBpc1dTT3JOZXdMaW5lID0gXy5tYWtlUHJlZGljYXRlKCdXUyBORVdMSU5FJyk7XG5sZXQgaXNDb21ibyA9IF8ubWFrZVByZWRpY2F0ZShDT01CT1MpO1xuXG4vLyBwcm9iYWJseSBzZWxlY3RvciBzZWdtZW50XG5sZXQgaXNTZWxlY3RvclNlcCA9IF8ubWFrZVByZWRpY2F0ZSgnV1MgPiB+ICsnICsgJ1BTRVVET19DTEFTUyBQU0VVRE9fRUxFTUVOVCBBVFRSSUJVVEUgQ0xBU1MgSEFTSCAmIFRFWFQgKiAjICN7IDogLiAlIC0gY29tcG91bmRpZGVudCBESU1FTlNJT04nKTtcblxubGV0IGlzT3BlcmF0b3IgPSBfLm1ha2VQcmVkaWNhdGUoJysgLSAqIC8nKTtcbmxldCBpc1JlbGF0aW9uT3AgPSBfLm1ha2VQcmVkaWNhdGUoJz09ID49IDw9IDwgPiAhPScpO1xubGV0IGlzQ29tbWFPclBhcmVuID0gXy5tYWtlUHJlZGljYXRlKCcsICknKTtcbmxldCBpc0RpcmVjdE9wZXJhdGUgPSBfLm1ha2VQcmVkaWNhdGUoJ0RJTUVOU0lPTiBTVFJJTkcgQk9PTEVBTiBURVhUIE5VTEwnKTtcblxubGV0IGlzQ29sb3IgPSBfLm1ha2VQcmVkaWNhdGUoXCJhbGljZWJsdWUgYW50aXF1ZXdoaXRlIGFxdWEgYXF1YW1hcmluZSBhenVyZSBiZWlnZSBiaXNxdWUgYmxhY2sgYmxhbmNoZWRhbG1vbmQgYmx1ZSBibHVldmlvbGV0IGJyb3duIGJ1cmx5d29vZCBjYWRldGJsdWUgY2hhcnRyZXVzZSBjaG9jb2xhdGUgY29yYWwgY29ybmZsb3dlcmJsdWUgY29ybnNpbGsgY3JpbXNvbiBjeWFuIGRhcmtibHVlIGRhcmtjeWFuIGRhcmtnb2xkZW5yb2QgZGFya2dyYXkgZGFya2dyZXkgZGFya2dyZWVuIGRhcmtraGFraSBkYXJrbWFnZW50YSBkYXJrb2xpdmVncmVlbiBkYXJrb3JhbmdlIGRhcmtvcmNoaWQgZGFya3JlZCBkYXJrc2FsbW9uIGRhcmtzZWFncmVlbiBkYXJrc2xhdGVibHVlIGRhcmtzbGF0ZWdyYXkgZGFya3NsYXRlZ3JleSBkYXJrdHVycXVvaXNlIGRhcmt2aW9sZXQgZGVlcHBpbmsgZGVlcHNreWJsdWUgZGltZ3JheSBkaW1ncmV5IGRvZGdlcmJsdWUgZmlyZWJyaWNrIGZsb3JhbHdoaXRlIGZvcmVzdGdyZWVuIGZ1Y2hzaWEgZ2FpbnNib3JvIGdob3N0d2hpdGUgZ29sZCBnb2xkZW5yb2QgZ3JheSBncmV5IGdyZWVuIGdyZWVueWVsbG93IGhvbmV5ZGV3IGhvdHBpbmsgaW5kaWFucmVkIGluZGlnbyBpdm9yeSBraGFraSBsYXZlbmRlciBsYXZlbmRlcmJsdXNoIGxhd25ncmVlbiBsZW1vbmNoaWZmb24gbGlnaHRibHVlIGxpZ2h0Y29yYWwgbGlnaHRjeWFuIGxpZ2h0Z29sZGVucm9keWVsbG93IGxpZ2h0Z3JheSBsaWdodGdyZXkgbGlnaHRncmVlbiBsaWdodHBpbmsgbGlnaHRzYWxtb24gbGlnaHRzZWFncmVlbiBsaWdodHNreWJsdWUgbGlnaHRzbGF0ZWdyYXkgbGlnaHRzbGF0ZWdyZXkgbGlnaHRzdGVlbGJsdWUgbGlnaHR5ZWxsb3cgbGltZSBsaW1lZ3JlZW4gbGluZW4gbWFnZW50YSBtYXJvb24gbWVkaXVtYXF1YW1hcmluZSBtZWRpdW1ibHVlIG1lZGl1bW9yY2hpZCBtZWRpdW1wdXJwbGUgbWVkaXVtc2VhZ3JlZW4gbWVkaXVtc2xhdGVibHVlIG1lZGl1bXNwcmluZ2dyZWVuIG1lZGl1bXR1cnF1b2lzZSBtZWRpdW12aW9sZXRyZWQgbWlkbmlnaHRibHVlIG1pbnRjcmVhbSBtaXN0eXJvc2UgbW9jY2FzaW4gbmF2YWpvd2hpdGUgbmF2eSBvbGRsYWNlIG9saXZlIG9saXZlZHJhYiBvcmFuZ2Ugb3JhbmdlcmVkIG9yY2hpZCBwYWxlZ29sZGVucm9kIHBhbGVncmVlbiBwYWxldHVycXVvaXNlIHBhbGV2aW9sZXRyZWQgcGFwYXlhd2hpcCBwZWFjaHB1ZmYgcGVydSBwaW5rIHBsdW0gcG93ZGVyYmx1ZSBwdXJwbGUgcmVkIHJvc3licm93biByb3lhbGJsdWUgc2FkZGxlYnJvd24gc2FsbW9uIHNhbmR5YnJvd24gc2VhZ3JlZW4gc2Vhc2hlbGwgc2llbm5hIHNpbHZlciBza3libHVlIHNsYXRlYmx1ZSBzbGF0ZWdyYXkgc2xhdGVncmV5IHNub3cgc3ByaW5nZ3JlZW4gc3RlZWxibHVlIHRhbiB0ZWFsIHRoaXN0bGUgdG9tYXRvIHR1cnF1b2lzZSB2aW9sZXQgd2hlYXQgd2hpdGUgd2hpdGVzbW9rZSB5ZWxsb3cgeWVsbG93Z3JlZW5cIilcbmxldCBpc1Nob3J0aGFuZFByb3AgPSBfLm1ha2VQcmVkaWNhdGUoJ2JhY2tncm91bmQgZm9udCBtYXJnaW4gYm9yZGVyIGJvcmRlci10b3AgYm9yZGVyLXJpZ2h0IGJvcmRlci1ib3R0b20gYm9yZGVyLWxlZnQgYm9yZGVyLXdpZHRoIGJvcmRlci1jb2xvciBib3JkZXItc3R5bGUgdHJhbnNpdGlvbiBwYWRkaW5nIGxpc3Qtc3R5bGUgYm9yZGVyLXJhZGl1cy4nKVxuXG5sZXQgaXNNY3NzQXRLZXl3b3JkID0gXy5tYWtlUHJlZGljYXRlKCdtaXhpbiBleHRlbmQgdmFyJyk7XG5sZXQgaXNNY3NzRnV0dXJlQXRLZXl3b3JkID0gXy5tYWtlUHJlZGljYXRlKCdpZiBlbHNlIGNzcyBmb3InKTtcbmxldCBpc0Nzc0F0S2V5d29yZCA9IF8ubWFrZVByZWRpY2F0ZSgnaW1wb3J0IHBhZ2Uga2V5ZnJhbWUgbWVkaWEgZm9udC1mYWNlIGNoYXJzZXQnKTtcblxuXG5cblxuY2xhc3MgUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG5cbiAgICBwYXJzZSh0b2tlbnMpIHtcbiAgICAgICAgLy8gcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgLy8gICAgIC8vID4+Pj4+PiBAVE9ETzog6L+Z5Lqb6KaB5LiOaW1wb3J0IOWQiOW5tiAyMDEzLzUvMTIgMDoyOTo0MlxuXG4gICAgICAgIC8vIH0pO1xuICAgICAgICB0aGlzLl9zdGF0ZXMgPSB7fTtcbiAgICAgICAgdGhpcy5sb29rYWhlYWQgPSB0b2tlbnM7XG4gICAgICAgIHRoaXMucCA9IDA7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5sb29rYWhlYWQubGVuZ3RoO1xuICAgICAgICB0aGlzLm1hcmtlZCA9IG51bGw7XG4gICAgICAgIGxldCBhc3QgPSB0aGlzLnN0eWxlc2hlZXQoKTtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICB9XG5cbiAgICAvLyBzdG9yZSBpbnRlcm1lZGlhIHN0YXRlXG4gICAgc3RhdGUoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlc1tzdGF0ZV0gPT09IHRydWU7XG4gICAgfVxuXG4gICAgLy8gZW50ZXIgc29tZSBzdGF0ZVxuICAgIGVudGVyKHN0YXRlKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlc1tzdGF0ZV0gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGVudGVyIHNvbWUgc3RhdGVcbiAgICBsZWF2ZShzdGF0ZSkge1xuICAgICAgICB0aGlzLl9zdGF0ZXNbc3RhdGVdID0gZmFsc2U7XG4gICAgfVxuXG4gICAgbG9va1VwQmVmb3JlKGxvb2t1cCwgYmVmb3JlKSB7XG4gICAgICAgIGxldCBpID0gMSwgbGE7XG4gICAgICAgIHdoaWxlKGkrKykge1xuICAgICAgICAgICAgaWYoKGxhID0gdGhpcy5sYShpKSkgPT09IGxvb2t1cClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmKGxhID09PSBiZWZvcmUgfHwgbGEgPT09ICdFT0YnIHx8IGxhID09PSAnfScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBUZW1wb3JhcmlseSBzZXQgdG8gbGwoMykgcGFyc2VyLFxuICAgIGxsKGsgPSAxKSB7XG4gICAgICAgIGlmKGsgPCAwKVxuICAgICAgICAgICAgaysrO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5wICsgayAtIDE7XG4gICAgICAgIGlmKHBvcyA+IHRoaXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgIHBvcyA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgICAgLy8gcmV0dXJuIHRoaXMubG9va2FoZWFkWyh0aGlzLnAgKyBrIC0gMSkgJSAzXTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9va2FoZWFkW3Bvc107XG4gICAgfVxuXG4gICAgLy8gcmVhZCB0aGUgbmV4dCB0b2tlblxuICAgIC8vIEBUT0RPIHJldHVybiB0byB0b2tlbiBzdHJlYW0hXG4gICAgbmV4dChrID0gMSkge1xuICAgICAgICB0aGlzLnAgKz0gaztcbiAgICB9XG5cbiAgICAvLyBleHBlY3RcbiAgICAvLyBzb21lIHRpbWVzIHdlIG5lZWQgdG8gaWdub3JlZCBzb21lIGxvb2thaGVhZCAsIGV0Yy4gTkVXTElORVxuICAgIC8vXG4gICAgLy8gd2hpbGUgdG8gZWF0ICc7J1xuICAgIC8vIDEuIGVhdCA7XG4gICAgLy8gMi4gZWF0IG5ld0xpbmU7XG4gICAgZWF0KC4uLnR5cGVzKSB7XG4gICAgICAgIGxldCB0b2tlbiA9IHRoaXMubGwoKTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZih0b2tlbi50eXBlID09PSB0eXBlc1tpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1hdGNoKC4uLnR5cGVzKSB7XG4gICAgICAgIGxldCB0b2tlbiA9IHRoaXMuZWF0KC4uLnR5cGVzKTtcbiAgICAgICAgaWYoIXRva2VuKSB7XG4gICAgICAgICAgICAvLyA+Pj4+Pj4gP+S4uuS7gOS5iFxuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLmxsKCk7XG4gICAgICAgICAgICB0aGlzLmVycm9yKCdleHBlY3Q6IFwiJyArIHR5cGVzWzBdICsgJ1wiIC0+IGdvdDogXCInICsgdG9rZW4udHlwZSArICdcIicsIHRva2VuLmxpbmVubyk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cblxuICAgIC8vXG4gICAgc2tpcCh0eXBlKSB7XG4gICAgICAgIGxldCBza2lwZWQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUodHJ1ZSkge1xuICAgICAgICAgICAgbGV0IHRva2VuID0gdGhpcy5sbCgpO1xuICAgICAgICAgICAgaWYodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gdHlwZSA9PT0gdG9rZW4udHlwZSA6IHR5cGUodG9rZW4udHlwZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgICAgICBza2lwZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNraXBlZDtcbiAgICB9XG5cbiAgICBza2lwU3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNraXAoaXNTa2lwU3RhcnQpO1xuICAgIH1cblxuICAgIHNraXBXU09yTmV3bGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2tpcChpc1dTT3JOZXdMaW5lKTtcbiAgICB9XG5cblxuXG4gICAgLy8gdHlwZSBhdCBwb3MgaXMgc29tZSB0eXBlXG4gICAgaXMocG9zLCB0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxsKHBvcykudHlwZSA9PT0gdHlwZTtcbiAgICB9XG5cbiAgICAvLyDnroDljZXniYjmnKwg5Y+q5YWB6K64bWFya+S4gOasoVxuICAgIG1hcmsoKSB7XG4gICAgICAgIHRoaXMubWFya2VkID0gdGhpcy5wO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXN0b3JlKCkge1xuICAgICAgICAvLyBpZih0aGlzLm1hcmtlZCAhPSB1bmRlZmluZWQpIHRoaXMucCA9IHRoaXMubWFya2VkO1xuICAgICAgICAvLyB0aGlzLm1hcmtlZCA9IG51bGw7XG4gICAgICAgIGlmKHRoaXMubWFya2VkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucCA9IHRoaXMubWFya2VkO1xuICAgICAgICAgICAgdGhpcy5tYXJrZWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIHBhcnNlIEZ1bmN0aW9uXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PVxuXG4gICAgLy8gc3R5bGVzaGVldCh0b3BMZXZlbClcbiAgICAvLyAgOiBXUyAgICAgIHtza2lwV2hpdGVTcGFjZX1cbiAgICAvLyAgfCBzdG10IEVPRlxuICAgIC8vICA7XG4gICAgLy9cbiAgICBzdHlsZXNoZWV0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibG9jayh0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBzdGF0ZW1lbnRcbiAgICAvLyBzdG10XG4gICAgLy8gIDogcnVsZXNldFxuICAgIC8vICB8IGF0cnVsZVxuICAgIC8vICA7XG4gICAgc3RtdCgpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBudWxsO1xuICAgICAgICBsZXQgdG9rZW4gPSB0aGlzLmxsKCk7XG4gICAgICAgIGlmKHRva2VuLnR5cGUgPT09ICdBVF9LRVlXT1JEJylcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLmF0cnVsZSgpO1xuICAgICAgICBlbHNlIGlmKHRva2VuLnR5cGUgPT09ICdWQVInKSB7XG4gICAgICAgICAgICBzd2l0Y2godGhpcy5sbCgyKS50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnKCc6XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLmZ1bmNDYWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hTZW1pQ29sb25JZk5vQmxvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnOic6XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLnRyYW5zcGFyZW50Q2FsbCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoU2VtaUNvbG9uSWZOb0Jsb2NrKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJz0nOlxuICAgICAgICAgICAgICAgIGNhc2UgJz89JzpcbiAgICAgICAgICAgICAgICBjYXNlICdePSc6XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLmFzc2lnbigpO1xuICAgICAgICAgICAgICAgICAgICBpZihub2RlLnZhbHVlLnR5cGUgIT09ICdmdW5jJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hTZW1pQ29sb25JZk5vQmxvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcignVU5FWFBFQ1QgdG9rZW4gYWZ0ZXIgVkFSSUFCTEUnLCB0aGlzLmxsKDIpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYodG9rZW4udHlwZSA9PT0gJ0ZVTkNUSU9OJykge1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMuZnVuY0NhbGwoKTtcbiAgICAgICAgICAgIHRoaXMubWF0Y2hTZW1pQ29sb25JZk5vQmxvY2soKTtcbiAgICAgICAgfSBlbHNlIGlmKGlzU2VsZWN0b3JTZXAodG9rZW4udHlwZSkpXG4gICAgICAgICAgICBub2RlID0gdGhpcy5ydWxlc2V0KHRydWUpO1xuXG4gICAgICAgIGlmKG5vZGUpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5lcnJvcignSU5WQUxJRCBzdGF0ZW1lbnRzdGFydCAnICsgdG9rZW4udHlwZSwgdG9rZW4pO1xuICAgIH1cblxuICAgIC8vIGF0cnVsZVxuICAgIC8vICA6IGNzcy1hdHJ1bGUoQGltcG9ydCwgQGNoYXJzZXQuLi4pXG4gICAgLy8gIDogYmktYXRydWxlKEBpZiwgQGVsc2UsIEBtaXhpbi4uLilcbiAgICAvLyAgOiBkaXJlY3RpdmVcbiAgICAvLyAgO1xuICAgIGF0cnVsZSgpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBudWxsO1xuICAgICAgICBsZXQgZnVsbG5hbWUgPSB0aGlzLmxsKCkudmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbGV0IG5hbWUgPSB0aGlzLl9yZW1vdmVQcmVmaXgoZnVsbG5hbWUpO1xuICAgICAgICBpZih0eXBlb2YgdGhpc1tuYW1lXSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzW25hbWVdKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLmRpcmVjdGl2ZSgpO1xuICAgICAgICBub2RlLmZ1bGxuYW1lID0gZnVsbG5hbWU7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIC8vID4+Pj4+PiDlvoXooaXlhYVcbiAgICAvLyDlpKnnhLbmlK/mjIFkb2N1bWVudOOAgWNoYXJzZXTnrYnnrYlcbiAgICBkaXJlY3RpdmUoKSB7XG4gICAgICAgIGxldCB0b2tlbiA9IHRoaXMubGwoKTtcbiAgICAgICAgbGV0IG5hbWUgPSB0b2tlbi52YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBsZXQgZGhvb2sgPSBkaXJlY3RpdmUuZ2V0RGlyZWN0aXZlKG5hbWUpO1xuICAgICAgICBpZihkaG9vaykge1xuICAgICAgICAgICAgLy8gdGhpcy5lcnJvcigndW5kZWZpbmVkIGF0cnVsZTogXCInICsgdGhpcy5sbCgpLnZhbHVlICsgJ1wiJylcbiAgICAgICAgICAgIC8vQFRPRE8gYWRkIGN1c3RvbWVyIHN5bnRheFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ2hhcyBob29rJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1hdGNoKCdBVF9LRVlXT1JEJyk7XG4gICAgICAgICAgICB0aGlzLmVhdCgnV1MnKVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZXNMaXN0KCk7XG4gICAgICAgICAgICB0aGlzLmVhdCgnV1MnKTtcbiAgICAgICAgICAgIGlmKHRoaXMuZWF0KCc7JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJlZS5kaXJlY3RpdmUobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSB0aGlzLmJsb2NrKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyZWUuZGlyZWN0aXZlKG5hbWUsIHZhbHVlLCBibG9jayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVycm9yKCdpbnZhbGlkIGN1c3RvbWVyIGRpcmVjdGl2ZSBkZWZpbmUnLCBsbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBoYXMgJ3t9J1xuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICBibG9jayhub0Jsb2NrKSB7XG4gICAgICAgIGxldCBub2RlID0gbmV3IHRyZWUuQmxvY2soKTtcbiAgICAgICAgdGhpcy5lYXQoJ1dTJyk7XG4gICAgICAgIGlmKCFub0Jsb2NrKSB0aGlzLm1hdGNoKCd7Jyk7XG4gICAgICAgIGxldCBlbmQgPSBub0Jsb2NrID8gJ0VPRicgOiAnfSc7XG4gICAgICAgIHRoaXMuc2tpcCgnV1MnKTtcbiAgICAgICAgd2hpbGUoIXRoaXMuZWF0KGVuZCkpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZDtcbiAgICAgICAgICAgIGlmKG5vQmxvY2spXG4gICAgICAgICAgICAgICAgY2hpbGQgPSB0aGlzLnN0bXQoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjaGlsZCA9IHRoaXMubWFyaygpLmRlY2xhcmF0aW9uKCkgfHwgdGhpcy5yZXN0b3JlKCkuc3RtdCgpO1xuICAgICAgICAgICAgbm9kZS5saXN0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgdGhpcy5za2lwU3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICAvLyBydWxlc2V0XG4gICAgLy8gIDogc2VsZWN0b3JsaXN0ICd7JyBydWxlICgoTmV3TGluZXw7KSBydWxlKSogJ30nXG5cbiAgICBydWxlc2V0KCkge1xuICAgICAgICBsZXQgbm9kZSA9IG5ldyB0cmVlLlJ1bGVTZXQoKTtcbiAgICAgICAgLy8gMS4g5pivU2VsZWN0b3IgU2VwIDJcbiAgICAgICAgLy8gMi4g5Zyo5pivSURFTlQoU2VsZWN0b3IgU2Vw5LmL5LiAKeaXtuWQjue7reS4jeaOpTog5Luj6KGo5LiN5pivZGVjbGFyYXRpb24gLy8gICYmKGxhICE9PSAnSURFTlQnfHwgdGhpcy5sYSgyKSAhPT0gJzonXG4gICAgICAgIC8vIEBjaGFuZ2Vsb2c6IDIgcmVtb3ZlIOi/meS4jemcgOimgVxuICAgICAgICBub2RlLnNlbGVjdG9yID0gdGhpcy5zZWxlY3Rvckxpc3QoKTtcbiAgICAgICAgdGhpcy5lYXQoJ1dTJyk7XG4gICAgICAgIG5vZGUuYmxvY2sgPSB0aGlzLmJsb2NrKCk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIC8vIHNlbGVjdG9yTGlzdFxuICAgIC8vICA6IGNvbXBsZXhTZWxlY3RvciAoLCBjb21wbGV4U2VsZWN0b3IpKlxuICAgIC8vICA7XG4gICAgc2VsZWN0b3JMaXN0KCkge1xuICAgICAgICBsZXQgbm9kZSA9IG5ldyB0cmVlLlNlbGVjdG9yTGlzdCgpO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBub2RlLmxpc3QucHVzaCh0aGlzLnNlbGVjdG9yKCkpO1xuICAgICAgICB9IHdoaWxlKHRoaXMuZWF0KCcsJykpO1xuICAgICAgICBub2RlLmxpbmVubyA9IG5vZGUubGlzdFswXS5saW5lbm87XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIC8vIOeugOWMluWkhOeQhu+8jOWFgeiuuGlk44CBY2xhc3PjgIF0eXBl5o+S5YC8XG4gICAgc2VsZWN0b3IoKSB7XG4gICAgICAgIGxldCBub2RlID0gbmV3IHRyZWUuU2VsZWN0b3IoKTtcbiAgICAgICAgbGV0IHNlbGVjdG9yU3RyaW5nID0gJyc7XG4gICAgICAgIGxldCB0b2tlbjtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB3aGlsZSh0cnVlKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMubGwoKTtcbiAgICAgICAgICAgIGlmKHRva2VuLnR5cGUgPT09ICcjeycgJiYgdGhpcy5sbCgyKS50eXBlICE9PSAnfScpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW50ZXJwb2xhdGlvbiA9IHRoaXMuaW50ZXJwb2xhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmKGludGVycG9sYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JTdHJpbmcgKz0gJyN7JyArIChpKyspICsgJ30nO1xuICAgICAgICAgICAgICAgICAgICBub2RlLmludGVycG9sYXRpb25zLnB1c2goaW50ZXJwb2xhdGlvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIGlmKGlzU2VsZWN0b3JTZXAodG9rZW4udHlwZSkpIHtcbiAgICAgICAgICAgICAgICAvLyA+Pj4+Pj4g5Y+v5Lul5LyY5YyWXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gdG9rZW4udHlwZSA9PT0gJ0RJTUVOU0lPTicgPyB0cmVlLnRvU3RyKHRva2VuKSA6ICh0b2tlbi52YWx1ZSB8fCAodG9rZW4udHlwZSA9PT0gJ1dTJyA/ICcgJyA6IHRva2VuLnR5cGUpKTtcbiAgICAgICAgICAgICAgICBzZWxlY3RvclN0cmluZyArPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuc3RyaW5nID0gc2VsZWN0b3JTdHJpbmc7XG4gICAgICAgIG5vZGUubGluZW5vID0gdG9rZW4ubGluZW5vO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICBkZWNsYXJhdGlvbihub0VuZCkge1xuICAgICAgICBsZXQgbm9kZSA9IG5ldyB0cmVlLkRlY2xhcmF0aW9uKCk7XG4gICAgICAgIGxldCB0b2tlbjEgPSB0aGlzLmxsKDEpLCB0b2tlbjIgPSB0aGlzLmxsKDIpO1xuICAgICAgICBpZih0b2tlbjEudHlwZSA9PT0gJyonICYmIHRva2VuMi50eXBlID09PSAnVEVYVCcpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgxKTtcbiAgICAgICAgICAgIHRva2VuMi52YWx1ZSA9ICcqJyArIHRva2VuMi52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyA+Pj4+Pj5cbiAgICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMuY29tcG91bmRJZGVudCgpO1xuICAgICAgICAvLyBkb24ndCBzdGFydCB3aXRoIHRhZyBvciBkb24ndCBsbCgyKSAhPT0gJzonXG4gICAgICAgIGlmKCFub2RlLnByb3BlcnR5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmVhdCgnV1MnKTtcbiAgICAgICAgaWYoIXRoaXMuZWF0KCc6JykpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgLy8gZmlsdGVyX2RlY2xhcmF0aW9u5ZyoSUXkuIvmmK/mlK/mjIHkuIDkupvkuI3op4TliJnnmoTor63ms5VcbiAgICAgICAgaWYobm9kZS5wcm9wZXJ0eS52YWx1ZSAmJiAvZmlsdGVyJC8udGVzdChub2RlLnByb3BlcnR5LnZhbHVlLnRvTG93ZXJDYXNlKCkpKVxuICAgICAgICAgICAgdGhpcy5lbnRlcihTVEFURVMuRklMVEVSX0RFQ0xBUkFUSU9OKTtcbiAgICAgICAgdGhpcy5lbnRlcihTVEFURVMuVFJZX0RFQ0xBUkFUSU9OKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IHRoaXMudmFsdWVzTGlzdCgpO1xuICAgICAgICAgICAgdGhpcy5sZWF2ZShTVEFURVMuVFJZX0RFQ0xBUkFUSU9OKTtcbiAgICAgICAgfWNhdGNoKGVycm9yKXtcbiAgICAgICAgICAgIHRoaXMubGVhdmUoU1RBVEVTLlRSWV9ERUNMQVJBVElPTik7XG4gICAgICAgICAgICBpZihlcnJvci5jb2RlID09PSBlcnJvcnMuREVDTEFSSU9OX0ZBSUwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5lYXQoJ0lNUE9SVEFOVCcpKVxuICAgICAgICAgICAgbm9kZS5pbXBvcnRhbnQgPSB0cnVlO1xuICAgICAgICBpZighbm9FbmQpXG4gICAgICAgICAgICB0aGlzLm1hdGNoU2VtaUNvbG9uSWZOb0Jsb2NrKCk7XG4gICAgICAgIHRoaXMubGVhdmUoU1RBVEVTLkZJTFRFUl9ERUNMQVJBVElPTik7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIGFzc2lnbigpIHtcbiAgICAgICAgbGV0IHRva2VuID0gdGhpcy5sbCgpO1xuICAgICAgICB0aGlzLm1hdGNoKCdWQVInKTtcbiAgICAgICAgbGV0IG9wID0gdGhpcy5tYXRjaCgnPScsICc/PScsICdePScpLnR5cGU7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuYXNzaWduRXhwcih0cnVlKTtcbiAgICAgICAgLy9ARklYSVQgY29uZmxpY3Qgd2l0aCBwYXJlbkV4cHJcbiAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkFzc2lnbih0b2tlbi52YWx1ZSwgdmFsdWUsIEFTU0lHTlNbb3BdIHx8IDEpO1xuICAgIH1cblxuICAgIC8qKmZ1bmN0aW9uKCk7XG4gICAgICogY2FuIGJlIGFzc2lnbiBleHByZXNzaW9uXG4gICAgICogZnVuY3Rpb24gfCB2YWx1ZXNsaXN0IHwgdmFsdWVzXG4gICAgICogQHBhcmFtICB7Qm9vbGVhbn0gaGFzQ29tbWEgd2hldGhlciBoYXMgY29tbWEgaW4gdGhlIGV4cHJlc3Npb25cbiAgICAgKiBAcmV0dXJuIHttaXhpbn1cbiAgICAgKi9cbiAgICBhc3NpZ25FeHByKGhhc0NvbW1hKSB7XG4gICAgICAgIGxldCBub2RlID0gbnVsbDtcbiAgICAgICAgbGV0IHRva2VuID0gdGhpcy5sbCgpO1xuICAgICAgICBsZXQgZm4gPSBoYXNDb21tYSA/ICd2YWx1ZXNMaXN0JyA6ICd2YWx1ZXMnO1xuICAgICAgICBpZih0b2tlbi50eXBlID09PSAneycpICAgIC8vIOWPr+iDveaYr3BhcmVuRXhwciDkuZ/lj6/og73mmK9mdW5jdGlvblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnVuYygpO1xuICAgICAgICBlbHNlIGlmKHRva2VuLnR5cGUgPT09ICcoJykge1xuICAgICAgICAgICAgdGhpcy5tYXJrKCk7XG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnVuYygpO1xuICAgICAgICAgICAgfWNhdGNoKGUpe1xuICAgICAgICAgICAgICAgIGlmKGUuZXhwZWN0ICYmIGUuZXhwZWN0ID09ICd7JyB8fCBlLmV4cGVjdCA9PSdWQVInIHx8IGUuZXhwZWN0ID09ICcpJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbZm5dKCk7XG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW2ZuXSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gMXB4IDFweCAjZmZmLCAxcHggMXB4ICNmZmYgLi4uXG4gICAgLy8gY29tbWEgc2VwYXJhdGVkIHZhbHVlc1xuICAgIC8vIHZhbHVlc0xpc3RcbiAgICB2YWx1ZXNMaXN0KCkge1xuICAgICAgICBsZXQgbGlzdCA9IFtdO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBsZXQgdmFsdWVzID0gdGhpcy52YWx1ZXMoKTtcbiAgICAgICAgICAgIGlmKHZhbHVlcylcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2godmFsdWVzKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfSB3aGlsZSh0aGlzLmVhdCgnLCcpKTtcblxuICAgICAgICBpZihsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiBsaXN0WzBdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuVmFsdWVzTGlzdChsaXN0KTtcbiAgICB9XG4gICAgLy8gY29tcG9uZW50IFZhbHVlc1xuICAgIHZhbHVlcygpIHtcbiAgICAgICAgbGV0IGxpc3QgPSBbXTtcbiAgICAgICAgd2hpbGUodHJ1ZSkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5leHByZXNzaW9uKCk7XG4gICAgICAgICAgICBpZih2YWx1ZSlcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYobGlzdC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZWxzZSBpZihsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiBsaXN0WzBdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuVmFsdWVzKGxpc3QpO1xuICAgIH1cblxuICAgIGV4cHJlc3Npb24oKSB7XG4gICAgICAgIHRoaXMuZWF0KCdXUycpO1xuICAgICAgICByZXR1cm4gdGhpcy5sb2dpY09yRXhwcigpO1xuICAgIH1cblxuICAgIC8vIHx8XG4gICAgbG9naWNPckV4cHIoKSB7XG4gICAgICAgIGxldCBsZWZ0ID0gdGhpcy5sb2dpY0FuZEV4cHIoKSwgcmlnaHQ7XG4gICAgICAgIGxldCB0b2tlbjtcbiAgICAgICAgd2hpbGUoKHRva2VuID0gdGhpcy5sbCgpKS50eXBlID09PSAnfHwnKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5sb2dpY0FuZEV4cHIoKTtcbiAgICAgICAgICAgIGlmKCFyaWdodClcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKHRva2VuLnR5cGUgKyAnIHJlcXVpcmUgcmlnaHQgb3BlcmFuZCcsIGxlZnQpO1xuXG4gICAgICAgICAgICBsZXQgYlZhbHVlID0gdHJlZS50b0Jvb2xlYW4obGVmdCk7XG4gICAgICAgICAgICBpZihiVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZihiVmFsdWUgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gcmlnaHQ7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbmV3IHRyZWUuT3BlcmF0b3IodG9rZW4udHlwZSwgbGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgdGhpcy5lYXQoJ1dTJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgfVxuXG4gICAgLy8gJiZcbiAgICBsb2dpY0FuZEV4cHIoKSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5yZWxhdGlvbkV4cHIoKSwgcmlnaHQ7XG4gICAgICAgIGxldCB0b2tlbjtcbiAgICAgICAgd2hpbGUoKHRva2VuID0gdGhpcy5sbCgpKS50eXBlID09PSAnJiYnKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5yZWxhdGlvbkV4cHIoKTtcbiAgICAgICAgICAgIGlmKCFyaWdodClcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKHRva2VuLnR5cGUgKyAnIHJlcXVpcmUgcmlnaHQgb3BlcmFuZCcsIG5vZGUpO1xuXG4gICAgICAgICAgICBsZXQgYlZhbHVlID0gdHJlZS50b0Jvb2xlYW4obm9kZSk7XG4gICAgICAgICAgICBpZihiVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmKGJWYWx1ZSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHJpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5ldyB0cmVlLk9wZXJhdG9yKHRva2VuLnR5cGUsIG5vZGUsIHJpZ2h0KVxuICAgICAgICAgICAgdGhpcy5lYXQoJ1dTJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuXG4gICAgLy8gPT1cbiAgICAvLyAhPVxuICAgIC8vID49XG4gICAgLy8gPD1cbiAgICAvLyA+XG4gICAgLy8gPFxuICAgIHJlbGF0aW9uRXhwcigpIHtcbiAgICAgICAgbGV0IGxlZnQgPSB0aGlzLmJpbm9wMSgpLCByaWdodDtcbiAgICAgICAgbGV0IHRva2VuO1xuICAgICAgICB3aGlsZShpc1JlbGF0aW9uT3AodG9rZW4gPSB0aGlzLmxsKCkudHlwZSkpe1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICB0aGlzLmVhdCgnV1MnKTtcbiAgICAgICAgICAgIHJpZ2h0ID0gdGhpcy5iaW5vcDEoKTtcbiAgICAgICAgICAgIGlmKCFyaWdodClcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKHRva2VuLnR5cGUgKyAnIHJlcXVpcmUgcmlnaHQgb3BlcmFuZCcsIGxlZnQpO1xuXG4gICAgICAgICAgICBpZih0cmVlLmlzUHJpbWFyeShsZWZ0LnR5cGUpICYmIHRyZWUuaXNQcmltYXJ5KHJpZ2h0LnR5cGUpKVxuICAgICAgICAgICAgICAgIGxlZnQgPSBiaW5vcC5yZWxhdGlvbi5jYWxsKHRoaXMsbGVmdCwgcmlnaHQsIHRva2VuLnR5cGUpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGxlZnQgPSBuZXcgdHJlZS5PcGVyYXRvcih0b2tlbi50eXBlLCBsZWZ0LCByaWdodClcbiAgICAgICAgICAgIHRoaXMuZWF0KCdXUycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWZ0O1xuICAgIH1cblxuICAgIC8vICsgLVxuICAgIGJpbm9wMSgpIHtcbiAgICAgICAgbGV0IGxlZnQgPSB0aGlzLmJpbm9wMigpLCByaWdodDtcbiAgICAgICAgbGV0IHRva2VuO1xuICAgICAgICB0aGlzLmVhdCgnV1MnKTtcbiAgICAgICAgd2hpbGUoKHRva2VuID0gdGhpcy5sbCgpKS50eXBlID09PSAnKycgfHwgdG9rZW4udHlwZSA9PT0gJy0nKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIHRoaXMuZWF0KCdXUycpO1xuICAgICAgICAgICAgcmlnaHQgPSB0aGlzLmJpbm9wMigpO1xuICAgICAgICAgICAgaWYoIXJpZ2h0KVxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IobGEgKyAnIHJlcXVpcmUgcmlnaHQgb3BlcmFuZCcsIGxlZnQpXG5cbiAgICAgICAgICAgIGlmKHJpZ2h0LnR5cGUgPT09ICdESU1FTlNJT04nICYmIGxlZnQudHlwZSA9PT0gJ0RJTUVOU0lPTicpXG4gICAgICAgICAgICAgICAgbGVmdCA9IGJpbm9wW3Rva2VuLnR5cGVdLmNhbGwodGhpcywgbGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGxlZnQgPSBuZXcgdHJlZS5PcGVyYXRvcih0b2tlbi50eXBlLCBsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICB0aGlzLmVhdCgnV1MnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVmdDtcbiAgICB9XG5cbiAgICAvLyAqIC8gJSAuLi4gKEBUT0RPIOWwhnJhbmdl5LiOYmlub3Ay57uT5ZCILCDljbPlkIzkuIDkvJjlhYjnuqcpXG4gICAgYmlub3AyKCkge1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMudW5hcnkoKSwgcmlnaHQ7XG4gICAgICAgIGxldCB3cyA9ICEhdGhpcy5lYXQoJ1dTJyk7XG5cbiAgICAgICAgbGV0IHRva2VuID0gdGhpcy5sbCgpO1xuICAgICAgICAvLyA+Pj4+Pj5cbiAgICAgICAgaWYodG9rZW4udHlwZSA9PT0gJy4uLicpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgdGhpcy5lYXQoJ1dTJyk7XG4gICAgICAgICAgICByaWdodCA9IHRoaXMudW5hcnkoKTtcbiAgICAgICAgICAgIHJldHVybiB0cmVlLnJhbmdlKGxlZnQsIHJpZ2h0LCBsZWZ0LmxpbmVubyk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUodG9rZW4udHlwZSA9PT0gJyonIHx8IHRva2VuLnR5cGUgPT09ICcvJyB8fCB0b2tlbi50eXBlID09PSAnJScpIHtcbiAgICAgICAgICAgIC8vIOWNs+S4gOS4quepuuagvOS5n+ayoeaciVxuICAgICAgICAgICAgaWYodG9rZW4udHlwZSA9PSAnLycgJiYgIXdzICYmIHRoaXMubGwoMikudHlwZSAhPT0gJ1dTJylcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgdGhpcy5lYXQoJ1dTJyk7XG4gICAgICAgICAgICByaWdodCA9IHRoaXMudW5hcnkoKTtcbiAgICAgICAgICAgIGlmKCFyaWdodClcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKHRva2VuLnR5cGUgKyAnIHJlcXVpcmUgcmlnaHQgb3BlcmFuZCcsIGxlZnQpO1xuXG4gICAgICAgICAgICBpZihyaWdodC50eXBlID09PSAnRElNRU5TSU9OJyAmJiBsZWZ0LnR5cGUgPT09ICdESU1FTlNJT04nKVxuICAgICAgICAgICAgICAgIGxlZnQgPSBiaW5vcFt0b2tlbi50eXBlXS5jYWxsKHRoaXMsIGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbmV3IHRyZWUuT3BlcmF0b3IodG9rZW4udHlwZSwgbGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgdGhpcy5lYXQoJ1dTJyk7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMubGwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVmdDtcbiAgICB9XG5cbiAgICAvLyByYW5nZTogZnVuY3Rpb24oKXtcbiAgICAvLyAgICAgdmFyIGxlZnQgPSB0aGlzLmxsKCksXG4gICAgLy8gICAgICAgICBub2RlID0gbmV3IHRyZWUuVmFsdWVzTGlzdCgpLFxuICAgIC8vICAgICAgICAgcmlnaHQsIGxjLCByYywgcmV2ZXJzZTtcbiAgICAvLyAgICAgdGhpcy5tYXRjaCgnRElNRU5TSU9OJylcbiAgICAvLyAgICAgdGhpcy5lYXQoJy4uLicpO1xuICAgIC8vICAgICByaWdodCA9IHRoaXMubGwoKTtcbiAgICAvLyAgICAgdGhpcy5tYXRjaChsZWZ0LnR5cGUpO1xuICAgIC8vICAgICBsYyA9IGxlZnQudmFsdWU7XG4gICAgLy8gICAgIHJjID0gcmlnaHQudmFsdWU7XG4gICAgLy8gICAgIHJldmVyc2UgPSBsYyA+IHJjO1xuXG4gICAgLy8gICAgIGZvcig7IGxjICE9IHJjIDspe1xuICAgIC8vICAgICAgICAgbm9kZS5saXN0LnB1c2goe1xuICAgIC8vICAgICAgICAgICAgIHR5cGU6IGxlZnQudHlwZSxcbiAgICAvLyAgICAgICAgICAgICB2YWx1ZTogbGNcbiAgICAvLyAgICAgICAgIH0pXG4gICAgLy8gICAgICAgICBpZihyZXZlcnNlKSAgbGMgLT0gMVxuICAgIC8vICAgICAgICAgZWxzZSBsYyArPSAxXG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgbm9kZS5saXN0LnB1c2goe1xuICAgIC8vICAgICAgICAgdHlwZTogbGVmdC50eXBlLFxuICAgIC8vICAgICAgICAgdmFsdWU6IGxjXG4gICAgLy8gICAgIH0pXG4gICAgLy8gICAgIHJldHVybiBub2RlO1xuICAgIC8vIH0sXG5cbiAgICAvLyDkuIDlhYPmlbBcbiAgICAvLyBAVE9ETyA6IOWKoOWFpSDvvIHkuIDlhYPmlbBcbiAgICB1bmFyeSgpIHtcbiAgICAgICAgbGV0IHRva2VuID0gdGhpcy5sbCgpO1xuICAgICAgICBpZih0b2tlbi50eXBlID09PSAnLScgfHwgdG9rZW4udHlwZSA9PT0gJysnIHx8IHRva2VuLnR5cGUgPT09ICchJyApIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgdGhpcy5lYXQoJ1dTJyk7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLnVuYXJ5KCk7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5ldyB0cmVlLlVuYXJ5KHZhbHVlLCB0b2tlbi50eXBlKTtcbiAgICAgICAgICAgIG5vZGUubGluZW5vID0gdG9rZW4ubGluZW5vO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJpbWFyeSgpO1xuICAgIH1cblxuICAgIC8vIHByaW1hcnlcbiAgICAvLyAgOiBJZGVudFxuICAgIC8vICA6IERpbWVuc2lvblxuICAgIC8vICA6IGZ1bmN0aW9uXG4gICAgLy8gIDogVmFyXG4gICAgcHJpbWFyeSgpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBudWxsO1xuICAgICAgICBsZXQgdG9rZW4gPSB0aGlzLmxsKCk7XG4gICAgICAgIHN3aXRjaCh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbkV4cHIoKTtcbiAgICAgICAgICAgIGNhc2UgJz0nOlxuICAgICAgICAgICAgICAgIC8vIGZpbHRlcjogYWxwaGEoeHg9ODAsIHh4PXh4LCBkZGQ9eHgpXG4gICAgICAgICAgICAgICAgaWYodGhpcy5zdGF0ZShTVEFURVMuRklMVEVSX0RFQ0xBUkFUSU9OKVxuICAgICAgICAgICAgICAgICAgICAmJiB0aGlzLnN0YXRlKFNUQVRFUy5GVU5DVElPTl9DQUxMKSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgbGV0IHRva2VuMiA9IHRoaXMubGwoMik7XG4gICAgICAgICAgICAgICAgaWYodG9rZW4yLnR5cGUgPT09ICdURVhUJyB8fCB0b2tlbjIudHlwZSA9PT0gJyN7JylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcG91bmRJZGVudCgpO1xuICAgICAgICAgICAgY2FzZSAnI3snOlxuICAgICAgICAgICAgY2FzZSAnVEVYVCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcG91bmRJZGVudCgpO1xuICAgICAgICAgICAgY2FzZSAnRlVOQ1RJT04nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bmNDYWxsKCk7XG4gICAgICAgICAgICBjYXNlICdIQVNIJzpcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZigvXiMoWzAtOWEtZkEtRl17M318WzAtOWEtZkEtRl17Nn0pJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5ldyB0cmVlLkNvbG9yKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5saW5lbm8gPSB0b2tlbi5saW5lbm87XG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBuZXcgdHJlZS5Vbmtub3duKHRva2VuLnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIC8vIFRPRE8g5o+S5YC8XG4gICAgICAgICAgICBjYXNlICdTVFJJTkcnOlxuICAgICAgICAgICAgY2FzZSAnRElNRU5TSU9OJzpcbiAgICAgICAgICAgIGNhc2UgJ0JPT0xFQU4nOlxuICAgICAgICAgICAgY2FzZSAnVkFSJzpcbiAgICAgICAgICAgIGNhc2UgJ05VTEwnOlxuICAgICAgICAgICAgY2FzZSAnVVJMJzpcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgIGNhc2UgJ34nOlxuICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICBjYXNlICcuJzpcbiAgICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgIGNhc2UgJzonOlxuICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICBjYXNlICdQU0VVRE9fQ0xBU1MnOlxuICAgICAgICAgICAgY2FzZSAnQ0xBU1MnOlxuICAgICAgICAgICAgY2FzZSAnQVRUUklCVVRFJzpcbiAgICAgICAgICAgICAgICBpZih0aGlzLnN0YXRlKFNUQVRFUy5UUllfREVDTEFSQVRJT04pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoZXJyb3JzLkRFQ0xBUklPTl9GQUlMKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgfVxuXG5cbiAgICAvLyAgOiAnI3snIHZhbHVlcyAnfSdcbiAgICBpbnRlcnBvbGF0aW9uKCkge1xuICAgICAgICB0aGlzLm1hdGNoKCcjeycpO1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMudmFsdWVzTGlzdCgpO1xuICAgICAgICB0aGlzLm1hdGNoKCd9Jyk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIC8vIHBhcmVuRXhwclxuICAgIC8vICA6ICcoJyBleHByZXNpb24gJyknXG4gICAgcGFyZW5FeHByKCkge1xuICAgICAgICB0aGlzLm1hdGNoKCcoJyk7XG4gICAgICAgIHRoaXMuZWF0KCdXUycpO1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMudmFsdWVzTGlzdCgpO1xuICAgICAgICBub2RlLmxpbmVubyA9IHRoaXMubGwoKS5saW5lbm87XG4gICAgICAgIHRoaXMuZWF0KCdXUycpO1xuICAgICAgICB0aGlzLm1hdGNoKCcpJyk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIC8vIGNvbXBvdW5kSWRlbnQg57uE5ZCISWRlbnRcbiAgICAvLyAgOiAoaW50ZXJwb2xhdGlvbiB8IFRFWFQpICtcbiAgICBjb21wb3VuZElkZW50KCkge1xuICAgICAgICBsZXQgbm9kZTtcbiAgICAgICAgbGV0IGxpc3QgPSBbXTtcbiAgICAgICAgbGV0IHRva2VuO1xuICAgICAgICBsZXQgc2VwO1xuICAgICAgICB3aGlsZSh0cnVlKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMubGwoKTtcbiAgICAgICAgICAgIGlmKHRva2VuLnR5cGUgPT09ICcjeycpIHtcbiAgICAgICAgICAgICAgICBzZXAgPSB0aGlzLmludGVycG9sYXRpb24oKTtcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2goc2VwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZih0b2tlbi50eXBlID09PSAnVEVYVCcgfHwgdG9rZW4udHlwZSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKHRva2VuLnZhbHVlIHx8IHRva2VuLnR5cGUpO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYoIXNlcCkge1xuICAgICAgICAgICAgaWYoIWxpc3QubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiB7dHlwZTogJ1RFWFQnLCB2YWx1ZTogbGlzdFswXSwgbGluZW5vOiB0b2tlbi5saW5lbm99O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IG5ldyB0cmVlLkNvbXBvdW5kSWRlbnQobGlzdCk7XG4gICAgICAgICAgICBub2RlLmxpbmVubyA9IHRva2VuLmxpbmVubztcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuYygpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYodGhpcy5lYXQoJygnKSkge1xuICAgICAgICAgICAgdGhpcy5lYXQoJ1dTJyk7XG4gICAgICAgICAgICBwYXJhbXMgPSB0aGlzLnBhcmFtcygpO1xuICAgICAgICAgICAgdGhpcy5tYXRjaCgnKScpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBibG9jayA9IHRoaXMuYmxvY2soKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0cmVlLkZ1bmMocGFyYW1zLCBibG9jayk7XG4gICAgfVxuXG4gICAgcGFyYW1zKCkge1xuICAgICAgICBsZXQgcmVzdCA9IDAsIHBhcmFtcyA9IFtdO1xuICAgICAgICBsZXQgdG9rZW4gPSB0aGlzLmxsKCk7XG4gICAgICAgIGlmKHRva2VuLnR5cGUgIT09ICcpJykge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbSA9IHRoaXMucGFyYW0oKTtcbiAgICAgICAgICAgICAgICBpZihwYXJhbS5yZXN0KSByZXN0Kys7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgfSB3aGlsZSh0aGlzLmVhdCgnLCcpKTtcbiAgICAgICAgICAgIGlmKHJlc3QgPj0gMilcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKCdjYW4gbm90IGhhdmUgbW9yZSB0aGFuIDIgcmVzdCBwYXJhbScsIHRva2VuLmxpbmVubyk7XG4gICAgICAgICAgICB0aGlzLmVhdCgnV1MnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1cblxuICAgIC8vIG1peGluJyBwYXJhbXNcbiAgICBwYXJhbSgpIHtcbiAgICAgICAgbGV0IHRva2VuID0gdGhpcy5sbCgpO1xuICAgICAgICBsZXQgbmFtZSA9IHRva2VuLnZhbHVlLCBkZnQsIHJlc3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tYXRjaCgnVkFSJyk7XG4gICAgICAgIGlmKHRoaXMuZWF0KCcuLi4nKSlcbiAgICAgICAgICAgIHJlc3QgPSB0cnVlO1xuICAgICAgICBpZih0aGlzLmVhdCgnPScpKSB7XG4gICAgICAgICAgICBpZihyZXN0KVxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoJ3Jlc3QgdHlwZSBwYXJhbSBjYW5cInQgaGF2ZSBkZWZhdWx0IHBhcmFtcycsIHRva2VuLmxpbmVubyk7XG4gICAgICAgICAgICBkZnQgPSB0aGlzLnZhbHVlcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdHJlZS5QYXJhbShuYW1lLCBkZnQsIHJlc3QpO1xuICAgIH1cblxuXG4gICAgLy8gZnVuY0NhbGxcbiAgICAvLyAgOiBDQUxMIEZVTkNUSU9OICcoJyAgZXhwcmVzaW9uICogJyknXG4gICAgZnVuY0NhbGwoKSB7XG4gICAgICAgIGxldCB0b2tlbiA9IHRoaXMubGwoKTtcbiAgICAgICAgdGhpcy5tYXRjaCgnRlVOQ1RJT04nLCAnVkFSJyk7XG4gICAgICAgIGlmKHRva2VuLmFyZ3MpXG4gICAgICAgICAgICByZXR1cm4gbmV3IHRyZWUuRnVuY0NhbGwodG9rZW4udmFsdWUsIHRva2VuLmFyZ3MsIG51bGwsIHRva2VuLmxpbmVubyk7XG4gICAgICAgIHRoaXMuZWF0KCdXUycpO1xuICAgICAgICB0aGlzLm1hdGNoKCcoJyk7XG4gICAgICAgIHRoaXMuZW50ZXIoU1RBVEVTLkZVTkNUSU9OX0NBTEwpO1xuICAgICAgICB0aGlzLmVhdCgnV1MnKTtcbiAgICAgICAgbGV0IHBhcmdzID0gdGhpcy5sbCgpLnR5cGUgIT09ICcpJyA/IHRoaXMuYXJncygpIDoge2FyZ3M6W119O1xuICAgICAgICB0aGlzLmxlYXZlKHN0YXRlcy5GVU5DVElPTl9DQUxMKTtcbiAgICAgICAgdGhpcy5tYXRjaCgnKScpO1xuICAgICAgICByZXR1cm4gbmV3IHRyZWUuRnVuY0NhbGwodG9rZW4udmFsdWUsIHBhcmdzLmFyZ3MsIHBhcmdzLm5hbWVkLCB0b2tlbi5saW5lbm8pO1xuICAgIH1cblxuICAgIC8vQFRPRE8gc3RhcnQgbmFtZWQgYXJndW1lbnRzXG4gICAgYXJncyhlbmQpIHtcbiAgICAgICAgbGV0IHRva2VuO1xuICAgICAgICBsZXQgbmFtZWQgPSBudWxsO1xuICAgICAgICBsZXQgYXJncyA9IFtdO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy5sbCgpO1xuICAgICAgICAgICAgaWYodG9rZW4udHlwZSA9PT0gJ1ZBUicgJiYgdGhpcy5sbCgyKS50eXBlID09PSAnPScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQoMik7XG4gICAgICAgICAgICAgICAgaWYoIW5hbWVkKSBuYW1lZCA9IHt9O1xuICAgICAgICAgICAgICAgIG5hbWVkW3Rva2VuLnZhbHVlXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmdzLnB1c2godGhpcy5hc3NpZ25FeHByKCkpO1xuICAgICAgICAgICAgdGhpcy5za2lwKCdXUycpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9IHdoaWxlKHRoaXMuZWF0KCcsJykpO1xuXG4gICAgICAgIHJldHVybiB7YXJncywgbmFtZWR9O1xuICAgIH1cblxuICAgIC8vIHN0eWx1cyBpbnNwaXJlZCBmZWF0dXJlO1xuICAgIHRyYW5zcGFyZW50Q2FsbCgpIHtcbiAgICAgICAgbGV0IHRva2VuID0gdGhpcy5sbCgpO1xuICAgICAgICB0aGlzLm1hdGNoKCdWQVInKTtcbiAgICAgICAgdGhpcy5tYXRjaCgnOicpO1xuICAgICAgICB0aGlzLmVhdCgnV1MnKVxuICAgICAgICB2YXIgcGFyZ3MgPSB0aGlzLmFyZ3MoKTtcbiAgICAgICAgLy8gaWYoYXJncy50eXBlID09PSAndmFsdWVzJyl7XG4gICAgICAgIC8vICAgICBhcmdzID0gbmV3IHRyZWUuVmFsdWVzTGlzdChhcmdzLmxpc3QpO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gaWYoYXJncy50eXBlICE9PSAndmFsdWVzbGlzdCcpIGFyZ3MgPSBbYXJnc107XG4gICAgICAgIC8vIGVsc2UgYXJncyA9IGFyZ3MubGlzdDtcbiAgICAgICAgcmV0dXJuIHRyZWUuRnVuY0NhbGwodG9rZW4udmFsdWUsIHBhcmdzLmFyZ3MsIHBhcmdzLm5hbWVkLCB0b2tlbi5saW5lbm8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBhdC1ydWxlIHByZWZpeFxuICAgICAqL1xuICAgIF9yZW1vdmVQcmVmaXgoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXi1cXHcrLS8sICcnKTtcbiAgICB9XG5cbiAgICBtYXRjaFNlbWlDb2xvbklmTm9CbG9jaygpIHtcbiAgICAgICAgdGhpcy5lYXQoJ1dTJyk7XG4gICAgICAgIGlmKHRoaXMubGwoKS50eXBlICE9PSAnfScpXG4gICAgICAgICAgICB0aGlzLm1hdGNoKCc7Jyk7XG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQYXJzZXI7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9wYXJzZXIuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 4 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Node = function () {\n    function Node() {\n        _classCallCheck(this, Node);\n    }\n\n    _createClass(Node, [{\n        key: 'clone',\n        value: function clone() {}\n    }]);\n\n    return Node;\n}();\n\nvar StyleSheet = function () {\n    function StyleSheet() {\n        var list = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\n        _classCallCheck(this, StyleSheet);\n\n        this.list = list;\n    }\n\n    _createClass(StyleSheet, [{\n        key: 'clone',\n        value: function clone() {\n            // >>>>>> cloneNode没有实现\n            return new StyleSheet(cloneNode(this.list));\n        }\n\n        // >>>>>> 不知道作用\n\n    }, {\n        key: 'exclude',\n        value: function exclude() {\n            var ret = [];\n            for (var i = this.list.length; i--;) {\n                var _item = this.list[i];\n                if (_item.type === 'media') ret.unshift(list.splice(i, 1)[0]);\n            }\n            return ret;\n        }\n    }, {\n        key: 'abstract',\n        value: function abstract() {\n            this.list.forEach(function (ruleset) {\n                return ruleset && (ruleset.abstract = true);\n            });\n            return this;\n        }\n    }]);\n\n    return StyleSheet;\n}();\n\nvar SelectorList = function () {\n    function SelectorList() {\n        var list = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n        var lineno = arguments[1];\n\n        _classCallCheck(this, SelectorList);\n\n        this.list = list;\n        this.lineno = lineno;\n    }\n\n    _createClass(SelectorList, [{\n        key: 'clone',\n        value: function clone() {\n            return new SelectorList(cloneNode(this.list));\n        }\n    }, {\n        key: 'length',\n        value: function length() {\n            return this.list.length;\n        }\n    }]);\n\n    return SelectorList;\n}();\n\n// 复选择器\n\n\nvar Selector = function () {\n    function Selector(string) {\n        var interpolations = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n\n        _classCallCheck(this, Selector);\n\n        this.string = string;\n        this.interpolations = interpolations;\n    }\n\n    _createClass(Selector, [{\n        key: 'clone',\n        value: function clone() {\n            return new ComplexSelector(this.string, cloneNode(this.interpolations));\n        }\n    }]);\n\n    return Selector;\n}();\n\nvar RuleSet = function () {\n    function RuleSet(selector, block) {\n        var abstract = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n        _classCallCheck(this, RuleSet);\n\n        this.selector = selector;\n        this.block = block;\n        // >>>>>> @TODO for mixin\n        this.ref = [];\n        this.abstract = abstract;\n    }\n\n    _createClass(RuleSet, [{\n        key: 'addRef',\n        value: function addRef(ruleset) {\n            if (!this.ref.includes(item)) this.ref.push(ruleset);\n        }\n    }, {\n        key: 'getSelectors',\n        value: function getSelectors() {\n            if (this.selector._compute === true) return this.selector.list;\n\n            var selectors = this.selector.list;\n            var plist = void 0;\n            if (this.parent && (plist = this.parent.getSelectors()) && plist.length) selectors = this._concatSelector(selectors, plist);\n\n            if (!this.parent) this.selector.list.forEach(function (selector) {\n                return selector.string = selector.string.replace(/&/g, '');\n            });\n\n            if (this.ref.length) {\n                this.ref.forEach(function (ruleset) {\n                    return selectors = [].concat(_toConsumableArray(selectors), _toConsumableArray(ruleset.getSelectors()));\n                });\n                this.ref = [];\n            }\n\n            this.selector.list = selectors;\n            this.selector._compute = true;\n            return selectors;\n        }\n    }]);\n\n    return RuleSet;\n}();\n\nvar Block = function () {\n    function Block() {\n        var list = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\n        _classCallCheck(this, Block);\n\n        this.list = list;\n    }\n\n    _createClass(Block, [{\n        key: 'exclude',\n        value: function exclude(isMedia) {\n            var ret = [];\n        }\n    }]);\n\n    return Block;\n}();\n\nvar Declaration = function Declaration(property, value) {\n    var important = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n    _classCallCheck(this, Declaration);\n\n    Object.assign(this, { property: property, value: value, important: important });\n};\n\nvar ValuesList = function () {\n    function ValuesList() {\n        var list = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n        var lineno = arguments[1];\n\n        _classCallCheck(this, ValuesList);\n\n        this.list = list;\n        this.lineno = lineno;\n    }\n\n    _createClass(ValuesList, [{\n        key: 'flatten',\n        value: function flatten() {\n            var list = this.list,\n                i = list.length,\n                values;\n            for (; i--;) {\n                values = list[i];\n                if (values.type == 'valueslist') {\n                    splice.apply(list, [i, 1].concat(values.list));\n                }\n            }\n            return this;\n        }\n    }, {\n        key: 'first',\n        value: function first() {\n            return this.list[0].list[0];\n        }\n    }]);\n\n    return ValuesList;\n}();\n\nvar Values = function () {\n    function Values() {\n        var list = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\n        _classCallCheck(this, Values);\n\n        this.list = list;\n    }\n\n    _createClass(Values, [{\n        key: 'flatten',\n        value: function flatten() {\n            var list = this.list,\n                i = list.length,\n                value;\n            for (; i--;) {\n                value = list[i];\n                if (value.type == 'values') {\n                    splice.apply(this, [i, 1].concat(value.list));\n                }\n            }\n            return this;\n        }\n    }]);\n\n    return Values;\n}();\n\n// 所有侦测不出的类似统一放置在这里\n\n\nvar Unknown = function Unknown(name) {\n    _classCallCheck(this, Unknown);\n\n    this.name = name;\n};\n\nvar Assign = function Assign(name, value) {\n    var mode = arguments.length <= 2 || arguments[2] === undefined ? 1 : arguments[2];\n\n    _classCallCheck(this, Assign);\n\n    Object.assign(this, { name: name, value: value, mode: mode });\n};\n\nvar Operator = function Operator(op, left, right) {\n    _classCallCheck(this, Operator);\n\n    Object.assign(this, { op: op, left: left, right: right });\n};\n\nvar Range = function Range(left, right) {\n    _classCallCheck(this, Range);\n\n    this.left = left;\n    this.right = right;\n};\n\nvar Unary = function Unary(value, op) {\n    _classCallCheck(this, Unary);\n\n    this.value = value;\n    this.op = op;\n};\n\nvar Dimension = function () {\n    function Dimension(value, unit) {\n        _classCallCheck(this, Dimension);\n\n        this.value = value;\n        this.unit = unit;\n    }\n\n    _createClass(Dimension, [{\n        key: 'toString',\n        value: function toString() {\n            return this.value + (this.unit || '');\n        }\n    }]);\n\n    return Dimension;\n}();\n\nvar CompoundIdent = function () {\n    function CompoundIdent() {\n        var list = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n\n        _classCallCheck(this, CompoundIdent);\n\n        this.list = list;\n    }\n\n    _createClass(CompoundIdent, [{\n        key: 'toString',\n        value: function toString() {\n            return this.list.join('');\n        }\n    }]);\n\n    return CompoundIdent;\n}();\n\n// list is a block statement\n// defaults is default params\n\n\nvar Func = function Func() {\n    var params = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];\n    var block = arguments[1];\n    var name = arguments[2];\n\n    _classCallCheck(this, Func);\n\n    Object.assign(this, { params: params, block: block, name: name });\n};\n\nvar Param = function Param(name, dft) {\n    var rest = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n    _classCallCheck(this, Param);\n\n    Object.assign(this, { name: name, dft: dft, rest: rest });\n};\n\nvar FuncCall = function FuncCall(name, args, named, lineno) {\n    _classCallCheck(this, FuncCall);\n\n    Object.assign(this, { name: name, args: args, named: named, lineno: lineno });\n};\n\nexports.Node = Node;\nexports.StyleSheet = StyleSheet;\nexports.RuleSet = RuleSet;\nexports.SelectorList = SelectorList;\nexports.Selector = Selector;\nexports.Block = Block;\nexports.Declaration = Declaration;\nexports.ValuesList = ValuesList;\nexports.Values = Values;\nexports.Unknown = Unknown;\nexports.Assign = Assign;\nexports.Operator = Operator;\nexports.Range = Range;\nexports.Unary = Unary;\nexports.Dimension = Dimension;\nexports.Func = Func;\nexports.Param = Param;\nexports.FuncCall = FuncCall;//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdHJlZS9pbmRleC5qcz83MTYzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQUFNLEk7QUFDRixvQkFBYztBQUFBO0FBRWI7Ozs7Z0NBRU8sQ0FFUDs7Ozs7O0lBR0MsVTtBQUNGLDBCQUF1QjtBQUFBLFlBQVgsSUFBVyx5REFBSixFQUFJOztBQUFBOztBQUNuQixhQUFLLElBQUwsR0FBWSxJQUFaO0FBQ0g7Ozs7Z0NBRU87O0FBRUosbUJBQU8sSUFBSSxVQUFKLENBQWUsVUFBVSxLQUFLLElBQWYsQ0FBZixDQUFQO0FBQ0g7Ozs7OztrQ0FHUztBQUNOLGdCQUFJLE1BQU0sRUFBVjtBQUNBLGlCQUFJLElBQUksSUFBSSxLQUFLLElBQUwsQ0FBVSxNQUF0QixFQUE4QixHQUE5QixHQUFvQztBQUNoQyxvQkFBSSxRQUFPLEtBQUssSUFBTCxDQUFVLENBQVYsQ0FBWDtBQUNBLG9CQUFHLE1BQUssSUFBTCxLQUFjLE9BQWpCLEVBQ0ksSUFBSSxPQUFKLENBQVksS0FBSyxNQUFMLENBQVksQ0FBWixFQUFlLENBQWYsRUFBa0IsQ0FBbEIsQ0FBWjtBQUNQO0FBQ0QsbUJBQU8sR0FBUDtBQUNIOzs7bUNBRVU7QUFDUCxpQkFBSyxJQUFMLENBQVUsT0FBVixDQUFrQixVQUFDLE9BQUQ7QUFBQSx1QkFBYSxZQUFZLFFBQVEsUUFBUixHQUFtQixJQUEvQixDQUFiO0FBQUEsYUFBbEI7QUFDQSxtQkFBTyxJQUFQO0FBQ0g7Ozs7OztJQUdDLFk7QUFDRiw0QkFBK0I7QUFBQSxZQUFuQixJQUFtQix5REFBWixFQUFZO0FBQUEsWUFBUixNQUFROztBQUFBOztBQUMzQixhQUFLLElBQUwsR0FBWSxJQUFaO0FBQ0EsYUFBSyxNQUFMLEdBQWMsTUFBZDtBQUNIOzs7O2dDQUVPO0FBQ0osbUJBQU8sSUFBSSxZQUFKLENBQWlCLFVBQVUsS0FBSyxJQUFmLENBQWpCLENBQVA7QUFDSDs7O2lDQUVRO0FBQ0wsbUJBQU8sS0FBSyxJ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d0IsS0FBeEIsRUFBK0IsTUFBL0IsRUFBdUM7QUFBQTs7QUFDbkMsV0FBTyxNQUFQLENBQWMsSUFBZCxFQUFvQixFQUFDLFVBQUQsRUFBTyxVQUFQLEVBQWEsWUFBYixFQUFvQixjQUFwQixFQUFwQjtBQUNILEM7O1FBS0QsSSxHQUFBLEk7UUFDQSxVLEdBQUEsVTtRQUNBLE8sR0FBQSxPO1FBQ0EsWSxHQUFBLFk7UUFDQSxRLEdBQUEsUTtRQUNBLEssR0FBQSxLO1FBQ0EsVyxHQUFBLFc7UUFDQSxVLEdBQUEsVTtRQUNBLE0sR0FBQSxNO1FBQ0EsTyxHQUFBLE87UUFDQSxNLEdBQUEsTTtRQUNBLFEsR0FBQSxRO1FBQ0EsSyxHQUFBLEs7UUFDQSxLLEdBQUEsSztRQUNBLFMsR0FBQSxTO1FBQ0EsSSxHQUFBLEk7UUFDQSxLLEdBQUEsSztRQUNBLFEsR0FBQSxRIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgIH1cblxuICAgIGNsb25lKCkge1xuXG4gICAgfVxufVxuXG5jbGFzcyBTdHlsZVNoZWV0IHtcbiAgICBjb25zdHJ1Y3RvcihsaXN0ID0gW10pIHtcbiAgICAgICAgdGhpcy5saXN0ID0gbGlzdDtcbiAgICB9XG5cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgLy8gPj4+Pj4+IGNsb25lTm9kZeayoeacieWunueOsFxuICAgICAgICByZXR1cm4gbmV3IFN0eWxlU2hlZXQoY2xvbmVOb2RlKHRoaXMubGlzdCkpO1xuICAgIH1cblxuICAgIC8vID4+Pj4+PiDkuI3nn6XpgZPkvZznlKhcbiAgICBleGNsdWRlKCkge1xuICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgIGZvcihsZXQgaSA9IHRoaXMubGlzdC5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gdGhpcy5saXN0W2ldO1xuICAgICAgICAgICAgaWYoaXRlbS50eXBlID09PSAnbWVkaWEnKVxuICAgICAgICAgICAgICAgIHJldC51bnNoaWZ0KGxpc3Quc3BsaWNlKGksIDEpWzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGFic3RyYWN0KCkge1xuICAgICAgICB0aGlzLmxpc3QuZm9yRWFjaCgocnVsZXNldCkgPT4gcnVsZXNldCAmJiAocnVsZXNldC5hYnN0cmFjdCA9IHRydWUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5jbGFzcyBTZWxlY3Rvckxpc3Qge1xuICAgIGNvbnN0cnVjdG9yKGxpc3QgPSBbXSwgbGluZW5vKSB7XG4gICAgICAgIHRoaXMubGlzdCA9IGxpc3Q7XG4gICAgICAgIHRoaXMubGluZW5vID0gbGluZW5vO1xuICAgIH1cblxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNlbGVjdG9yTGlzdChjbG9uZU5vZGUodGhpcy5saXN0KSk7XG4gICAgfVxuXG4gICAgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0Lmxlbmd0aDtcbiAgICB9XG59XG5cbi8vIOWkjemAieaLqeWZqFxuY2xhc3MgU2VsZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZywgaW50ZXJwb2xhdGlvbnMgPSBbXSkge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICAgICAgdGhpcy5pbnRlcnBvbGF0aW9ucyA9IGludGVycG9sYXRpb25zO1xuICAgIH1cblxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBsZXhTZWxlY3Rvcih0aGlzLnN0cmluZywgY2xvbmVOb2RlKHRoaXMuaW50ZXJwb2xhdGlvbnMpKTtcbiAgICB9XG59XG5cbmNsYXNzIFJ1bGVTZXQge1xuICAgIGNvbnN0cnVjdG9yKHNlbGVjdG9yLCBibG9jaywgYWJzdHJhY3QgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMuYmxvY2sgPSBibG9jaztcbiAgICAgICAgLy8gPj4+Pj4+IEBUT0RPIGZvciBtaXhpblxuICAgICAgICB0aGlzLnJlZiA9IFtdO1xuICAgICAgICB0aGlzLmFic3RyYWN0ID0gYWJzdHJhY3Q7XG4gICAgfVxuXG4gICAgYWRkUmVmKHJ1bGVzZXQpIHtcbiAgICAgICAgaWYoIXRoaXMucmVmLmluY2x1ZGVzKGl0ZW0pKVxuICAgICAgICAgICAgdGhpcy5yZWYucHVzaChydWxlc2V0KTtcbiAgICB9XG5cbiAgICBnZXRTZWxlY3RvcnMoKSB7XG4gICAgICAgIGlmKHRoaXMuc2VsZWN0b3IuX2NvbXB1dGUgPT09IHRydWUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rvci5saXN0O1xuXG4gICAgICAgIGxldCBzZWxlY3RvcnMgPSB0aGlzLnNlbGVjdG9yLmxpc3Q7XG4gICAgICAgIGxldCBwbGlzdDtcbiAgICAgICAgaWYodGhpcy5wYXJlbnQgJiYgKHBsaXN0ID0gdGhpcy5wYXJlbnQuZ2V0U2VsZWN0b3JzKCkpICYmIHBsaXN0Lmxlbmd0aClcbiAgICAgICAgICAgIHNlbGVjdG9ycyA9IHRoaXMuX2NvbmNhdFNlbGVjdG9yKHNlbGVjdG9ycywgcGxpc3QpO1xuXG4gICAgICAgIGlmKCF0aGlzLnBhcmVudClcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IubGlzdC5mb3JFYWNoKChzZWxlY3RvcikgPT5cbiAgICAgICAgICAgICAgICBzZWxlY3Rvci5zdHJpbmcgPSBzZWxlY3Rvci5zdHJpbmcucmVwbGFjZSgvJi9nLCAnJykpO1xuXG4gICAgICAgIGlmKHRoaXMucmVmLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5yZWYuZm9yRWFjaCgocnVsZXNldCkgPT5cbiAgICAgICAgICAgICAgICBzZWxlY3RvcnMgPSBbLi4uc2VsZWN0b3JzLCAuLi5ydWxlc2V0LmdldFNlbGVjdG9ycygpXSk7XG4gICAgICAgICAgICB0aGlzLnJlZiA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZWxlY3Rvci5saXN0ID0gc2VsZWN0b3JzO1xuICAgICAgICB0aGlzLnNlbGVjdG9yLl9jb21wdXRlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9ycztcbiAgICB9XG5cbn1cblxuY2xhc3MgQmxvY2sge1xuICAgIGNvbnN0cnVjdG9yKGxpc3QgPSBbXSkge1xuICAgICAgICB0aGlzLmxpc3QgPSBsaXN0O1xuICAgIH1cblxuICAgIGV4Y2x1ZGUoaXNNZWRpYSkge1xuICAgICAgICBsZXQgcmV0ID0gW107XG4gICAgfVxufVxuXG5jbGFzcyBEZWNsYXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHksIHZhbHVlLCBpbXBvcnRhbnQgPSBmYWxzZSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtwcm9wZXJ0eSwgdmFsdWUsIGltcG9ydGFudH0pO1xuICAgIH1cbn1cblxuY2xhc3MgVmFsdWVzTGlzdCB7XG4gICAgY29uc3RydWN0b3IobGlzdCA9IFtdLCBsaW5lbm8pIHtcbiAgICAgICAgdGhpcy5saXN0ID0gbGlzdDtcbiAgICAgICAgdGhpcy5saW5lbm8gPSBsaW5lbm87XG4gICAgfVxuXG4gICAgZmxhdHRlbigpIHtcbiAgICAgICAgdmFyIGxpc3QgPSB0aGlzLmxpc3QsXG4gICAgICAgICAgICBpID0gbGlzdC5sZW5ndGgsXG4gICAgICAgICAgICB2YWx1ZXM7XG4gICAgICAgIGZvcig7aS0tOyl7XG4gICAgICAgICAgICB2YWx1ZXMgPSBsaXN0W2ldO1xuICAgICAgICAgICAgaWYodmFsdWVzLnR5cGUgPT0gJ3ZhbHVlc2xpc3QnKXtcbiAgICAgICAgICAgICAgICBzcGxpY2UuYXBwbHkobGlzdCwgW2ksIDFdLmNvbmNhdCh2YWx1ZXMubGlzdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZpcnN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0WzBdLmxpc3RbMF07XG4gICAgfVxufVxuXG5jbGFzcyBWYWx1ZXMge1xuICAgIGNvbnN0cnVjdG9yKGxpc3QgPSBbXSkge1xuICAgICAgICB0aGlzLmxpc3QgPSBsaXN0O1xuICAgIH1cblxuICAgIGZsYXR0ZW4oKSB7XG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5saXN0LFxuICAgICAgICAgICAgaSA9IGxpc3QubGVuZ3RoLFxuICAgICAgICAgICAgdmFsdWU7XG4gICAgICAgIGZvcig7aS0tOyl7XG4gICAgICAgICAgICB2YWx1ZSA9IGxpc3RbaV07XG4gICAgICAgICAgICBpZih2YWx1ZS50eXBlID09ICd2YWx1ZXMnKXtcbiAgICAgICAgICAgICAgICBzcGxpY2UuYXBwbHkodGhpcywgW2ksIDFdLmNvbmNhdCh2YWx1ZS5saXN0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG4vLyDmiYDmnInkvqbmtYvkuI3lh7rnmoTnsbvkvLznu5/kuIDmlL7nva7lnKjov5nph4xcbmNsYXNzIFVua25vd24ge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG59XG5cbmNsYXNzIEFzc2lnbiB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgdmFsdWUsIG1vZGUgPSAxKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywge25hbWUsIHZhbHVlLCBtb2RlfSk7XG4gICAgfVxufVxuXG5jbGFzcyBPcGVyYXRvciB7XG4gICAgY29uc3RydWN0b3Iob3AsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywge29wLCBsZWZ0LCByaWdodH0pO1xuICAgIH1cbn1cblxuY2xhc3MgUmFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICB9XG59XG5cbmNsYXNzIFVuYXJ5IHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgb3ApIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm9wID0gb3A7XG4gICAgfVxufVxuXG5jbGFzcyBEaW1lbnNpb24ge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCB1bml0KSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51bml0ID0gdW5pdDtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgKyAodGhpcy51bml0IHx8ICcnKTtcbiAgICB9XG59XG5cbmNsYXNzIENvbXBvdW5kSWRlbnQge1xuICAgIGNvbnN0cnVjdG9yKGxpc3QgPSBbXSkge1xuICAgICAgICB0aGlzLmxpc3QgPSBsaXN0O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0LmpvaW4oJycpO1xuICAgIH1cbn1cblxuLy8gbGlzdCBpcyBhIGJsb2NrIHN0YXRlbWVudFxuLy8gZGVmYXVsdHMgaXMgZGVmYXVsdCBwYXJhbXNcbmNsYXNzIEZ1bmMge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcyA9IFtdLCBibG9jaywgbmFtZSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtwYXJhbXMsIGJsb2NrLCBuYW1lfSk7XG4gICAgfVxufVxuXG5jbGFzcyBQYXJhbSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgZGZ0LCByZXN0ID0gZmFsc2UpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7bmFtZSwgZGZ0LCByZXN0fSk7XG4gICAgfVxufVxuXG5jbGFzcyBGdW5jQ2FsbCB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgYXJncywgbmFtZWQsIGxpbmVubykge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtuYW1lLCBhcmdzLCBuYW1lZCwgbGluZW5vfSk7XG4gICAgfVxufVxuXG5cbmV4cG9ydCB7XG4gICAgTm9kZSxcbiAgICBTdHlsZVNoZWV0LFxuICAgIFJ1bGVTZXQsXG4gICAgU2VsZWN0b3JMaXN0LFxuICAgIFNlbGVjdG9yLFxuICAgIEJsb2NrLFxuICAgIERlY2xhcmF0aW9uLFxuICAgIFZhbHVlc0xpc3QsXG4gICAgVmFsdWVzLFxuICAgIFVua25vd24sXG4gICAgQXNzaWduLFxuICAgIE9wZXJhdG9yLFxuICAgIFJhbmdlLFxuICAgIFVuYXJ5LFxuICAgIERpbWVuc2lvbixcbiAgICBGdW5jLFxuICAgIFBhcmFtLFxuICAgIEZ1bmNDYWxsXG59XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy90cmVlL2luZGV4LmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }
/******/ ])
});
;